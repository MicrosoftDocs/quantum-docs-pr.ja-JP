---
uid: Microsoft.Quantum.AmplitudeAmplification
title: AmplitudeAmplification 名前空間
ms.date: 1/23/2021 12:00:00 AM
ms.topic: managed-reference
qsharp.kind: namespace
qsharp.name: Microsoft.Quantum.AmplitudeAmplification
qsharp.summary: This namespace contains functions and operations for performing amplitude amplification.
ms.openlocfilehash: a014f923de62c5e660c1c0fc839fbe60e80f8ba9
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/26/2021
ms.locfileid: "98845829"
---
# <a name="microsoftquantumamplitudeamplification-namespace"></a><span data-ttu-id="3a44c-102">AmplitudeAmplification 名前空間</span><span class="sxs-lookup"><span data-stu-id="3a44c-102">Microsoft.Quantum.AmplitudeAmplification namespace</span></span>

<span data-ttu-id="3a44c-103">この名前空間には、振幅増幅を実行するための関数と操作が含まれています。</span><span class="sxs-lookup"><span data-stu-id="3a44c-103">This namespace contains functions and operations for performing amplitude amplification.</span></span>



## <a name="description"></a><span data-ttu-id="3a44c-104">説明</span><span class="sxs-lookup"><span data-stu-id="3a44c-104">Description</span></span>

<span data-ttu-id="3a44c-105">無関係の部分反射を使用した振幅増幅は、ここで実装されている振幅増幅の最も一般的な形式です。</span><span class="sxs-lookup"><span data-stu-id="3a44c-105">Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here.</span></span>

<span data-ttu-id="3a44c-106">これは、操作 AmpAmpObliviousByReflectionPhases を通じて呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-106">This is called through the operation AmpAmpObliviousByReflectionPhases.</span></span>

<span data-ttu-id="3a44c-107">これには、との2つのレジスタがあり `ancillaRegister` `systemRegister` ます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-107">This has two registers: `ancillaRegister` and `systemRegister`.</span></span>

<span data-ttu-id="3a44c-108">これは `ReflectionOracle` 、レジスタにのみ作用する型の反射に対して、2つの oracles を受け入れ `ancillaRegister` ます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-108">This accepts two oracles for these reflections of type `ReflectionOracle` which act only on the `ancillaRegister` register.</span></span>

<span data-ttu-id="3a44c-109">これは、 `ObliviousOracle` 両方のレジスタに共同で動作する、型の無関係の特殊な振幅増幅を許可します。</span><span class="sxs-lookup"><span data-stu-id="3a44c-109">This accepts an oracle special to oblivious amplitude amplification of type `ObliviousOracle` which acts jointly on both register.</span></span>

<span data-ttu-id="3a44c-110">への入力状態は、 `ancillaRegister` 最初のリフレクション演算子 $I-2 \ k {s} \ bra {s} $ という一意の $-$1 eigenstate と想定されます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-110">The input state to `ancillaRegister` is assumed to be the unique $-1$ eigenstate of the first reflection operator $I - 2\ket{s}\bra{s}$.</span></span>

<span data-ttu-id="3a44c-111">ターゲットクォンタムの状態に関する反射は、多くの場合、計算ベース $ \ket{0\cdots 0} $ からその状態を準備する oracle へのアクセスを前提として実装されます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-111">Reflections about a target quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis $\ket{0\cdots 0}$.</span></span>

<span data-ttu-id="3a44c-112">これらの oracles の規則では、2つのレジスタが必要です。1つはシングル qubit レジスタ、もう1つはフロントシャー `flagQubit` ドレジスタレジスタに登録します。</span><span class="sxs-lookup"><span data-stu-id="3a44c-112">Our convention for these oracles requires two registers: a single-qubit `flagQubit` register, and a register for everything else on the ancillaRegister register.</span></span>

<span data-ttu-id="3a44c-113">型の oracle は、 `StateOracle` 両方のレジスタに共同で動作し、レジスタ内の $ \ket $ によってフラグが設定されたターゲット状態を、 {1} `flagQubit` いくつかの実際の振幅で作成します。</span><span class="sxs-lookup"><span data-stu-id="3a44c-113">The oracle of type `StateOracle` acts jointly on both registers to create the target state flagged by $\ket{1}$ in the `flagQubit` register with some real amplitude.</span></span>

<span data-ttu-id="3a44c-114">`ReflectionOracle`このフラグの状態に関するリフレクションは、操作によって生成され `TargetStateReflectionOracle` ます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-114">The reflection `ReflectionOracle` about the this flag state is generated by the operation `TargetStateReflectionOracle`.</span></span>

<span data-ttu-id="3a44c-115">への `ReflectionOracle` 入力状態に関するリフレクション `ancillaRegister` は、を反転することによって生成され、$ \ket{0\cdots 0} $ と ReflectionStart () を反映します。</span><span class="sxs-lookup"><span data-stu-id="3a44c-115">The reflection `ReflectionOracle` about the input state to `ancillaRegister` is generated by the inverting StateOracle and then reflecting about $\ket{0\cdots 0}$ with ReflectionStart().</span></span>

<span data-ttu-id="3a44c-116">型の oracle は、 `DeterministicStateOracle` レジスタに対して動作し、 `qubitState` フラグなしでターゲットの状態を正確に作成します。</span><span class="sxs-lookup"><span data-stu-id="3a44c-116">The oracle of type `DeterministicStateOracle` acts on the `qubitState` registers to create the target state exactly with no flag.</span></span>

<span data-ttu-id="3a44c-117">`AmpAmpObliviousByOraclePhases` は、反射ではなく oracles とを受け入れる無関係の振幅増幅のバージョンです `StateOracle` `ObliviousOracle` 。</span><span class="sxs-lookup"><span data-stu-id="3a44c-117">`AmpAmpObliviousByOraclePhases` is a version of oblivious amplitude amplification that accepts oracles `StateOracle` and `ObliviousOracle` instead of reflections.</span></span>

<span data-ttu-id="3a44c-118">振幅増幅は特殊なケースで、無関係の振幅増幅であることに注意してください。 `ObliviousOracle` は id 演算子で、システム qubits は存在しません。つまり、 `systemRegister` は空です。</span><span class="sxs-lookup"><span data-stu-id="3a44c-118">Note that amplitude amplification is a special case of oblivious amplitude amplification where `ObliviousOracle` is the identity operator, and there are no system qubits i.e. `systemRegister` is empty.</span></span>

<span data-ttu-id="3a44c-119">これは、操作とを通じて呼び出され `AmpAmByReflectionPhases` `AmpAmpByOraclePhases` ます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-119">This is called through the operation `AmpAmByReflectionPhases` and `AmpAmpByOraclePhases`.</span></span>

<span data-ttu-id="3a44c-120">Grover search の標準的なケースでの部分的な反射のフェーズは、AmpAmpPhasesStandard 関数によって提供されます。</span><span class="sxs-lookup"><span data-stu-id="3a44c-120">The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard.</span></span>

<span data-ttu-id="3a44c-121">たとえば、AmpAmpByOracle >-> AmpAmpObliviousByOraclePhases-> AmpAmpObliviousByReflectionPhases という依存関係があります。</span><span class="sxs-lookup"><span data-stu-id="3a44c-121">For instance, we have the following dependencies: AmpAmpByOracle -> AmpAmpByOraclePhases -> AmpAmpObliviousByOraclePhases -> AmpAmpObliviousByReflectionPhases.</span></span>