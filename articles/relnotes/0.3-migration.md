---
title: QDK 0.3 言語レビューおよび移行ガイド
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: 041de6484d95aa89394309813ca4b1dd09072cdf
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/29/2020
ms.locfileid: "76820846"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a><span data-ttu-id="d9b56-102">QDK 0.3 言語リリースノートおよび移行ガイド</span><span class="sxs-lookup"><span data-stu-id="d9b56-102">QDK 0.3 language release notes and migration guide</span></span>

<span data-ttu-id="d9b56-103">Quantum 開発キットの最新の更新プログラムを紹介します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-103">We are excited to introduce the newest update to the Quantum Development Kit.</span></span>  <span data-ttu-id="d9b56-104">このページでは、新しい Q # 言語機能の概要を示し、既存の Q # プログラムを新しい構文に[移行](#Migration)する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-104">This page gives an overview of the new Q# language features and describes how to [migrate](#Migration) existing Q# programs to the new syntax.</span></span>  <span data-ttu-id="d9b56-105">Q # 言語の詳細については、[こちら](xref:microsoft.quantum.language.intro)の完全なドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="d9b56-105">See our complete documentation for the full description of the Q# language [here](xref:microsoft.quantum.language.intro).</span></span>


## <a name="whats-new"></a><span data-ttu-id="d9b56-106">新機能</span><span class="sxs-lookup"><span data-stu-id="d9b56-106">What's New</span></span> 

<span data-ttu-id="d9b56-107">0\.3 更新プログラムには、さまざまな言語とエディターの機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-107">The 0.3 update comes with a range of new language and editor features.</span></span>

### <a name="overview-of-features"></a><span data-ttu-id="d9b56-108">機能の概要</span><span class="sxs-lookup"><span data-stu-id="d9b56-108">Overview of Features</span></span>

- <span data-ttu-id="d9b56-109">以下を含む、Visual Studio および Visual Studio Code 用の強化された開発ツールの統合。</span><span class="sxs-lookup"><span data-stu-id="d9b56-109">Enhanced development tool integration for Visual Studio and Visual Studio Code, including:</span></span>
    - <span data-ttu-id="d9b56-110">入力時のライブコンパイルとフィードバック (*別名*)</span><span class="sxs-lookup"><span data-stu-id="d9b56-110">Live compilation and feedback on typing (*a.k.a.*</span></span> <span data-ttu-id="d9b56-111">波下線)。</span><span class="sxs-lookup"><span data-stu-id="d9b56-111">squiggly underlining).</span></span>
    - <span data-ttu-id="d9b56-112">ドキュメントの概要や種類の署名などのホバー情報。</span><span class="sxs-lookup"><span data-stu-id="d9b56-112">Hover information including documentation summaries and type signatures.</span></span>
    - <span data-ttu-id="d9b56-113">[定義へのジャンプ] のサポート。</span><span class="sxs-lookup"><span data-stu-id="d9b56-113">Support for go to definition.</span></span>
    - <span data-ttu-id="d9b56-114">名前空間、操作、関数、型の宣言に簡単に移動できます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-114">Easy navigation to namespace, operation, function, and type declarations.</span></span>
    - <span data-ttu-id="d9b56-115">診断メッセージが改善されました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-115">Improved diagnostic messages.</span></span>
- <span data-ttu-id="d9b56-116">言語の機能強化</span><span class="sxs-lookup"><span data-stu-id="d9b56-116">Language improvements</span></span>
    - <span data-ttu-id="d9b56-117">使用と借りにおける単一の qubit とタプルの初期化</span><span class="sxs-lookup"><span data-stu-id="d9b56-117">Single qubit and tuple initializations within using and borrowing</span></span>
    - <span data-ttu-id="d9b56-118">すべての割り当てに対するタプル分解</span><span class="sxs-lookup"><span data-stu-id="d9b56-118">Tuple deconstruction on all assignments</span></span>
    - <span data-ttu-id="d9b56-119">配列の反復処理</span><span class="sxs-lookup"><span data-stu-id="d9b56-119">Iteration over arrays</span></span>
    - <span data-ttu-id="d9b56-120">条件式</span><span class="sxs-lookup"><span data-stu-id="d9b56-120">Conditional expressions</span></span>
    - <span data-ttu-id="d9b56-121">操作の既定の特殊化略称</span><span class="sxs-lookup"><span data-stu-id="d9b56-121">Default-specialization abbreviation for operations</span></span>
    - <span data-ttu-id="d9b56-122">自動生成型コンストラクター</span><span class="sxs-lookup"><span data-stu-id="d9b56-122">Auto-generated type constructors</span></span>
    - <span data-ttu-id="d9b56-123">式の修飾子</span><span class="sxs-lookup"><span data-stu-id="d9b56-123">Expression modifiers</span></span>


## <a name="editor-features"></a><span data-ttu-id="d9b56-124">エディターの機能</span><span class="sxs-lookup"><span data-stu-id="d9b56-124">Editor Features</span></span>

<span data-ttu-id="d9b56-125">Quantum Development Kit には、Visual Studio および Visual Studio Code 用のクライアント統合だけでなく、Q # 用の言語サーバーが含まれるようになりました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-125">The Quantum Development Kit now includes a language server for Q#, as well as the client integrations for Visual Studio and Visual Studio Code.</span></span>
<span data-ttu-id="d9b56-126">これにより、波下線が付いたエラーおよび警告形式での入力時のライブ フィードバックと共に、IntelliSense 機能の新しいセットが有効になります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-126">This enables a new set of IntelliSense features along with live feedback on typing in form of squiggly underlinings of errors and warnings.</span></span>
<span data-ttu-id="d9b56-127">特に、[定義へ移動] がサポートされるようになりました。ホバー情報には、型情報と、コメントをドキュメント化した情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-127">In particular, go to definition is now supported and hover information is displayed containing type information as well as information from documenting comments.</span></span> <span data-ttu-id="d9b56-128">また、定義されている名前空間、操作、関数、型に関するシンボル情報が使用可能であり、が宣言にすばやく移動できるようになります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-128">Additionally, symbol information about defined namespaces, operations, functions, and types is available and allows to quickly navigate to declarations.</span></span>    
<span data-ttu-id="d9b56-129">この更新により、一般的には診断メッセージが大幅に改善され、診断のための移動が容易になり、診断の範囲が正確になり、表示されるホバー情報の詳細が追加されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-129">This update greatly improves diagnostic messages in general, with easy navigation to and precise ranges for diagnostics and additional details in the displayed hover information.</span></span> 

<span data-ttu-id="d9b56-130">この0.3 リリースでは、Quantum 開発キットに含まれている言語サーバーでは、複数のワークスペースがサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-130">For this 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
<span data-ttu-id="d9b56-131">VS Code でプロジェクトを操作するには、プロジェクト自体とすべての参照先プロジェクトを含むルートフォルダーを開きます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-131">In order to work with a project in VS Code, open the root folder containing the project itself and all referenced projects.</span></span>
<span data-ttu-id="d9b56-132">Visual Studio でソリューションを操作するには、ソリューションに含まれるすべてのプロジェクトが、ソリューションと同じフォルダーまたはそのサブフォルダーのいずれかに存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-132">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>

## <a name="language-features"></a><span data-ttu-id="d9b56-133">言語機能</span><span class="sxs-lookup"><span data-stu-id="d9b56-133">Language Features</span></span>

<span data-ttu-id="d9b56-134">言語機能に関しては、この更新プログラムによって、さまざまな言語パターンの扱いが統一されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-134">In terms of language features, this update unifies the treatment of a range of language patterns.</span></span>
<span data-ttu-id="d9b56-135">たとえば、型コンストラクターは、ユーザー定義型ごとに生成され、他の関数と同じように部分的に適用できます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-135">Type constructors, as an example, are generated for each user defined type and can be partially applied much like any other function.</span></span>
<span data-ttu-id="d9b56-136">もう1つの例として、タプル分解があります。これは、すべての割り当てで完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-136">Another example is tuple deconstruction, which is now fully supported within all assignments.</span></span> <span data-ttu-id="d9b56-137">これには、let、mutable、および set ステートメントだけでなく、for ループの繰り返し変数に加えて、およびを使用した割り当ても含まれます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-137">This includes not only let-, mutable-, and set-statements, but also the iteration variable in for-loops as well as using- and borrowing-allocations.</span></span> <span data-ttu-id="d9b56-138">また、部分的な deconstructions は、0.3 update で新たにサポートされています。deconstructions のアンダースコアは、無視される値の一部を示します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-138">Additionally, partial deconstructions are newly supported with the 0.3 update; underscores in deconstructions indicate parts of the value that are to be ignored.</span></span> 

<span data-ttu-id="d9b56-139">次のコードは、いくつかの新機能を示しています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-139">The following code illustrates some of the new features:</span></span>
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
<span data-ttu-id="d9b56-140">最後の set ステートメントでは、0.3 更新プログラムで導入された新しい三項演算子を使用して、条件式をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-140">The last set statement uses a new ternary operator that is introduced with the 0.3 update to support conditional expressions.</span></span>
<span data-ttu-id="d9b56-141">条件式は、`condition ? caseTrue | caseFalse`形式の式です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-141">A conditional expression is an expression of the form `condition ? caseTrue | caseFalse`.</span></span>
<span data-ttu-id="d9b56-142">上の例からわかるように、配列に対する反復処理もサポートされるようになりました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-142">As can be seen from the example above, iteration over arrays is now also supported.</span></span>

<span data-ttu-id="d9b56-143">`using` と `borrowing` 内の割り当ては、1つの qubits、qubits 配列、および入れ子になった組で新しく可能になります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-143">Allocations within `using` and `borrowing` are newly possible for single qubits, qubit arrays, and nested tuples thereof:</span></span>
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

<span data-ttu-id="d9b56-144">`auto` に加えて `invert` および `distribute` の2つの新しい特殊化ジェネレーターディレクティブが導入されました。これにより、ファンの特殊化の生成方法の制御が強化されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-144">Two new specialization generator directives `invert` and `distribute` in addition to `auto` are introduced to increase control over how functor specializations are generated.</span></span>
<span data-ttu-id="d9b56-145">既定の `body` 特殊化の明示的な宣言は、必須ではなくなりました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-145">An explicit declaration of the default `body` specialization within operations is no longer mandatory.</span></span>
<span data-ttu-id="d9b56-146">関数と同様に、操作内で他の特殊化が宣言されていない場合は、ステートメントを操作宣言自体に直接追加することができます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-146">Similar to functions, statements may be directly added to the operation declaration itself if no other specialization is declared within the operation.</span></span>
<span data-ttu-id="d9b56-147">移行スクリプトは、既存のコードを移行したり、新しい言語機能を活用したりするためにリリースに含まれています ([移行スクリプトの「」セクション](#MigrationScript)を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="d9b56-147">A migration script is included in the release to help migrating existing code and taking advantage of new language features (see the [section on the migration script](#MigrationScript)).</span></span>

<span data-ttu-id="d9b56-148">ユーザー定義型の処理方法に関する主な変更は、0.3 更新プログラムを使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-148">A major change in how user-defined types are treated comes with the 0.3 update.</span></span> <span data-ttu-id="d9b56-149">以前のリリースでは、ユーザー定義型はその基になる型のサブタイプとして扱われていましたが、今後はこれが行われなくなりました ([重大な変更に関するセクション](#BreakingChanges)も参照してください)。</span><span class="sxs-lookup"><span data-stu-id="d9b56-149">While prior releases treated user defined types as subtypes of their underlying type, this is no longer the case going forward (see also the [section on breaking changes](#BreakingChanges)).</span></span>  
<span data-ttu-id="d9b56-150">この変更の一環として、特定の式に適用できる式修飾子が導入されました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-150">As part of this change we introduce expression modifiers that can be applied to certain expressions.</span></span> <span data-ttu-id="d9b56-151">修飾子を適用できる "アトミック" 式は、識別子、配列項目式、およびアリティ1組です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-151">The "atomic" expressions that modifiers can be applied to are identifiers, array item expressions, and arity-1 tuples.</span></span>
<span data-ttu-id="d9b56-152">修飾子は、他の式連結子よりも厳密にバインドされます。また、特に、呼び出し式の連結子 `(` `)`よりも厳密になります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-152">Modifiers bind tighter than any other expression combinator, and in particular tighter than the call-expression combinator `(` `)`.</span></span> 
<span data-ttu-id="d9b56-153">`Adjoint`、`Controlled`、および新しい "ラップ解除" 後置演算子 `!` は、式修飾子として扱われます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-153">`Adjoint`, `Controlled`, and a new "unwrap" postfix operator `!` are treated as expression modifiers.</span></span> <span data-ttu-id="d9b56-154">`Adjoint` と `Controlled` を式の修飾子として扱うと、多くの場合にかっこの必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-154">Treating `Adjoint` and `Controlled` as expression modifiers eliminates the need for parenthesis for a lot of cases.</span></span> <span data-ttu-id="d9b56-155">たとえば、次の式は、`Op`、一連のユニタリ演算、`opArr` の一連の処理を実行し、適切な引数を `arg` するために有効です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-155">The expressions below for example are valid going forward for `Op`, a unitary operation, `opArr` an array of unitary operations, and `arg` a suitable argument:</span></span> 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
<span data-ttu-id="d9b56-156">移行スクリプトを実行すると、不要なかっこの大半が削除され、新機能を最大限に活用できます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-156">The migration script will drop most of the unnecessary parenthesis and take full advantage of the new features.</span></span> <span data-ttu-id="d9b56-157">ただし、スクリプトではコードが解釈されないことに注意してください。また、まれなケース (部分的なアプリケーションとの組み合わせにのみ関係します) の `Controlled` ファンクタの解釈が異なることを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="d9b56-157">However, be advised that the script does not interpret the code, and will not account for the different interpretation of the `Controlled` functor in rare cases (only relevant in combination with partial applications).</span></span>

<span data-ttu-id="d9b56-158">新しい修飾子 `!`、ユーザー定義型を基になる型にキャストします。</span><span class="sxs-lookup"><span data-stu-id="d9b56-158">The new modifier `!` casts a user-defined type to its underlying type.</span></span> <span data-ttu-id="d9b56-159">このキャストは、以前のリリースではアップキャストと見なされており、自動的に実行されました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-159">This cast has been considered an upcast in previous releases and was executed automatically.</span></span> <span data-ttu-id="d9b56-160">ユーザー定義型の新しい解釈を使用すると、このようなことはなくなり、キャストを明示的に行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-160">With the new interpretation of user defined types this is no longer the case and the cast needs to be made explicit.</span></span>    
<span data-ttu-id="d9b56-161">New 修飾子の使用方法を次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-161">The following example illustrates how to use the new modifier:</span></span> 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
<span data-ttu-id="d9b56-162">例からわかるように、`!` は `Controlled` や `Adjoint`などのプレフィックス修飾子よりも厳密にバインドされます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-162">As can be seen from the example, `!` binds tighter than prefix modifiers, like `Controlled` and `Adjoint`.</span></span>

## <a name="BreakingChanges"></a><span data-ttu-id="d9b56-163">重大な変更</span><span class="sxs-lookup"><span data-stu-id="d9b56-163">Breaking Changes</span></span> 

<span data-ttu-id="d9b56-164">0\.3 更新プログラムには新しいコンパイラが付属しており、いくつかの互換性に影響する変更が含まれています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-164">The 0.3 update comes with a new compiler and contains a handful of breaking changes.</span></span>
<span data-ttu-id="d9b56-165">既存のコードの更新を容易にするために、コンパイラには、有効または無効なコードをコンパイルし、ビルドされたコンパイルに基づいて書式設定された Q # コードを出力する書式設定オプションも用意されています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-165">To facilitate updating existing code, the compiler also provides a formatting option that compiles valid or invalid code and emits formatted Q# code based on the built compilation.</span></span>
<span data-ttu-id="d9b56-166">すべての構文の変更は、提供されたツールによって自動的に処理されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-166">All syntax changes will be processed automatically by the provided tool.</span></span> <span data-ttu-id="d9b56-167">ただし、有効なコードを解釈する (セマンティックの変更) 方法の変更は、手動で行う必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-167">However, changes in how valid code is interpreted (semantic changes) may need to be made manually.</span></span> 

<span data-ttu-id="d9b56-168">次に示す変更に加えて、パターン `__*__` ます。 \* は空白以外の文字のシーケンスは内部使用のために予約されており、シンボル名として使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-168">In addition to the changes listed below, the pattern `__*__` where \* is any sequence of non-whitespace characters is reserved for internal use and cannot be used as a symbol name.</span></span>  

## <a name="syntax-changes"></a><span data-ttu-id="d9b56-169">構文の変更</span><span class="sxs-lookup"><span data-stu-id="d9b56-169">Syntax Changes</span></span> 

- <span data-ttu-id="d9b56-170">バージョン0.3 以降では、配列項目はセミコロンで区切られなくなりましたが、代わりにコンマで区切られています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-170">Starting with the version 0.3, array items are no longer separated by semicolons, but are separated by commas instead.</span></span>
- <span data-ttu-id="d9b56-171">それ以外の場合は、特殊化宣言の自動生成ディレクティブの後にセミコロンが必要です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-171">A semicolon on the other hand is required after an auto-generation directive for specialization declarations.</span></span>
- <span data-ttu-id="d9b56-172">If-、elif、および until 句の条件は、かっこ内にカプセル化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-172">Conditions in if-, elif-, and until-clauses need to be encapsulated in parenthesis.</span></span> 

<span data-ttu-id="d9b56-173">他のすべての構文の変更では、古い構文が使用されている場合、コンパイラは単に警告を生成します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-173">For all other syntax changes the compiler will simply generate a warning if the old syntax is used.</span></span>     
<span data-ttu-id="d9b56-174">このような変更の1つの例として、ユーザー定義の特殊化のシンボルの組があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-174">One example for such a change is the symbol tuple in user-defined specializations.</span></span> <span data-ttu-id="d9b56-175">以前のリリースでは、制御された、または制御された-adjoint 特殊化宣言で1つのシンボル引数が指定されていましたが、0.3 以降では、必要に応じてコンパイラが呼び出し可能な宣言からシンボルを移行することを示す `...` のすべての特殊化にこのような記号の組を提供することをお勧め</span><span class="sxs-lookup"><span data-stu-id="d9b56-175">While in previous releases a controlled or controlled-adjoint specialization declaration specified a single symbol argument, starting in 0.3 it is encouraged to provide such a symbol tuple for all specialization with `...` indicating that the compiler should migrate the symbols from the callable declaration if needed.</span></span> 

## <a name="semantic-changes"></a><span data-ttu-id="d9b56-176">セマンティックの変更</span><span class="sxs-lookup"><span data-stu-id="d9b56-176">Semantic Changes</span></span> 

<span data-ttu-id="d9b56-177">0\.3 リリースの最もインパクトな中断は、ユーザー定義型を型システムに統合する方法です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-177">The most impactful breaking for the 0.3 release is how user-defined types are integrated into the type system.</span></span> <span data-ttu-id="d9b56-178">以前のリリースでは、ユーザー定義型はその基になる型のサブタイプと見なされていました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-178">In prior releases user defined types were considered to be a subtype of their underlying type.</span></span> <span data-ttu-id="d9b56-179">今回のリリースでは、今後この問題が発生することはありません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-179">With this release and going forward this is no longer the case.</span></span> <span data-ttu-id="d9b56-180">ユーザー定義型は、独自の別個の型と見なされるようになりました。ユーザー定義型とその基になる型の間の自動キャストは存在しません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-180">User defined types are now considered to be their own distinct type, and no automatic cast between a user defined type and its underlying type exists.</span></span> <span data-ttu-id="d9b56-181">"ラップ解除" `!`演算子を使用してすべてのキャストを明示的にする必要があります。また、特にユーザー定義型のオブジェクトのコンテンツにアクセスするには、キャストが必要です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-181">All casts need to be made explicit via an "unwrap" operator `!`, and a cast is needed in particular to access the content of a object of user defined type.</span></span>  

<span data-ttu-id="d9b56-182">型システムに加えられた変更には、配列の分散動作や、パラメーター化された型オブジェクトの処理も含まれます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-182">The modifications to the type system also include the variance behavior of arrays, and the treatment of type parameterized objects.</span></span> <span data-ttu-id="d9b56-183">0\.3 以降では、変更可能な配列と変更できない配列の両方が不変です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-183">Starting in 0.3, both mutable and immutable arrays are invariant.</span></span> <span data-ttu-id="d9b56-184">また、呼び出し可能に渡される引数は、パラメーター化された型にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-184">Additionally, arguments passed to a callable cannot be type parameterized.</span></span> <span data-ttu-id="d9b56-185">このような場合は、型引数を識別子と共に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-185">In these cases, type arguments must be passed along with the identifer.</span></span>

<span data-ttu-id="d9b56-186">Q # コンパイラの以前のリリースでは、関数値が正しい入力および出力型である限り、操作値が必要な場所に関数値を指定できました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-186">Previous releases of the Q# compiler allowed a function value to be provided where an operation value was expected, as long as the function value had the correct input and output types.</span></span> <span data-ttu-id="d9b56-187">これは、Q # 言語仕様では指定されていない意図しない動作でした。</span><span class="sxs-lookup"><span data-stu-id="d9b56-187">This was unintended behavior that is not specified in the Q# language specification.</span></span>
<span data-ttu-id="d9b56-188">0\.3 コンパイラでは、関数の値が操作値と見なされなくなるように、この動作が削除されました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-188">In the 0.3 compiler, we have removed this behavior so that function values are no longer considered operation values.</span></span>
<span data-ttu-id="d9b56-189">このバグに依存している既存のコードの中断を最小限に抑えるために、同じ入力と出力の種類を持つ操作に関数を明示的に変換する ToOperation 関数を、現在の Quantum 名前空間に追加しました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-189">To minimize the disruption to existing code that relied on this bug, we have added the ToOperation function in the Microsoft.Quantum.Canon namespace that will explicitly convert a function into an operation with the same input and output types.</span></span>

<span data-ttu-id="d9b56-190">次の例は、`ToOperation` 関数を使用して、関数 `Square` を操作 `op`に変更する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-190">The following example illustrates how to use the `ToOperation` function to change a function `Square` to an operation `op`:</span></span> 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a><span data-ttu-id="d9b56-191">前提条件</span><span class="sxs-lookup"><span data-stu-id="d9b56-191">Requirements</span></span> 

<span data-ttu-id="d9b56-192">リリースは、Windows 10 の場合は Visual Studio 2017 バージョン15.8 以降、Windows 10、macOS、Linux の場合は Visual Studio Code バージョン1.27.2 以降でサポートされています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-192">The release is supported on Visual Studio 2017 version 15.8 or later for Windows 10, and on Visual Studio Code version 1.27.2 or later for Windows 10, macOS, and Linux.</span></span>

<span data-ttu-id="d9b56-193">Quantum Development Kit では、.NET Core SDK (2.0 以降) が使用されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-193">The Quantum Development Kit uses the .NET Core SDK (2.0 or later).</span></span>

## <a name="installation"></a><span data-ttu-id="d9b56-194">インストール</span><span class="sxs-lookup"><span data-stu-id="d9b56-194">Installation</span></span>  

<span data-ttu-id="d9b56-195">[こちら](../install-guide/index.md)のインストール手順に従ってください。</span><span class="sxs-lookup"><span data-stu-id="d9b56-195">Follow the installation instructions [here](../install-guide/index.md).</span></span>

<span data-ttu-id="d9b56-196">現在のバージョンの .NET Core SDK が最新ではない場合は、警告が表示されることがあります ("' ' の異なるバージョン間で競合が見つかりました。")。</span><span class="sxs-lookup"><span data-stu-id="d9b56-196">You may see warnings ("Found conflicts between different versions of "System.Reflection.Metadata" that could not be resolved.") if your current version of .NET Core SDK is not up to date.</span></span>  <span data-ttu-id="d9b56-197">ただし、.NET Core SDK (2.0 以降) を使用している場合、これらの警告は無視される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-197">However, if you are using .NET Core SDK (2.0 or later), these warnings may be ignored.</span></span>


- <span data-ttu-id="d9b56-198">このリリースは、さまざまなサンプルと共に提供されています。これは、Quantum 開発キットの既存の機能と、このリリースで使用できる新機能の両方を使用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-198">The release is provided along with a number of different samples showing how to use both existing features of the Quantum Development Kit, and the new features available with this release.</span></span> <span data-ttu-id="d9b56-199">これらのサンプルは、GitHub の[Microsoft/Quantum](https://github.com/Microsoft/Quantum)リポジトリで入手できます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-199">These samples can be can be found on GitHub at the [Microsoft/Quantum](https://github.com/Microsoft/Quantum) repository.</span></span>


## <a name="Migration"></a><span data-ttu-id="d9b56-200">既存のプロジェクトを Q # 0.3 に移行する</span><span class="sxs-lookup"><span data-stu-id="d9b56-200">Migrating Existing Projects to Q# 0.3</span></span> 

<span data-ttu-id="d9b56-201">クォンタム開発キットのバージョン0.2 の既存の Q # プロジェクトがある場合は、これらのプロジェクトを最新バージョンに移行するための手順を次に示します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-201">If you have existing Q# projects from version 0.2 of the Quantum Development Kit, the following are the steps to migrate those projects to the newest version.</span></span> <span data-ttu-id="d9b56-202">また、このプロセスに役立つ[移行スクリプト](#MigrationScript)も提供します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-202">We also provide a [migration script](#MigrationScript) to help you with the process.</span></span>

> [!NOTE]
> <span data-ttu-id="d9b56-203">プロジェクトは順にアップグレードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-203">Projects need to be upgraded in order.</span></span> <span data-ttu-id="d9b56-204">複数のプロジェクトを含むソリューションがある場合は、各プロジェクトが参照されている順序で更新されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-204">If you have a solution with multiple projects update each project in the order they are referenced.</span></span>


1. <span data-ttu-id="d9b56-205">コマンド ラインから、`dotnet clean` を実行して、既存のバイナリと中間ファイルをすべて削除します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-205">From a command line, Run `dotnet clean` to remove all existing binaries and intermediate files.</span></span>
2. <span data-ttu-id="d9b56-206">テキストエディターで、.csproj ファイルを編集して、すべての "0.3.1811.2802 `PackageReference`" のバージョンをバージョン-preview に変更します。次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-206">In a text editor, edit the .csproj file to change the version of all the "Microsoft.Quantum" `PackageReference` to version 0.3.1811.2802-preview, for example:</span></span>
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. <span data-ttu-id="d9b56-207">コマンドラインから、コマンドラインコンパイラに統合された書式設定ツールを使用して、次のコマンドを実行してすべての構文の変更に対処します。 `dotnet msbuild /t:qsharpformat`</span><span class="sxs-lookup"><span data-stu-id="d9b56-207">From the command line, use the formatting tool integrated into the command line compiler to address all syntax changes by running this command: `dotnet msbuild /t:qsharpformat`</span></span>  
    - <span data-ttu-id="d9b56-208">ファイルはインプレースで移行されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-208">Your files will be migrated in-place.</span></span> <span data-ttu-id="d9b56-209">すべての元のファイルのバックアップがにコピーされ `obj\qsharp\.backup`</span><span class="sxs-lookup"><span data-stu-id="d9b56-209">A backup of all the original files will be copied to `obj\qsharp\.backup`</span></span>
    - <span data-ttu-id="d9b56-210">書式設定ツールは、すべてのコンパイルエラーを無視してプロジェクトをコンパイルし、ビルドのコンパイルに基づいて書式設定された Q # コードを生成します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-210">The formatting tool will compile the project ignoring all compilation errors and generate formatted Q# code based on the build compilation.</span></span> 
       <span data-ttu-id="d9b56-211">未定義のシンボル (未定義の変数名など) は、書式設定後に手動で置き換える必要があるプレースホルダーテキストに置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-211">Any unrecognized symbol (e.g. an undefined variable name) will be replaced by a placeholder text that needs to be replaced manually after formatting.</span></span> <span data-ttu-id="d9b56-212">この場合、影響を受けたファイルに対して警告を生成するときに、書式設定が正常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-212">In this case, the formatting succeeds while generating a warning for the affected file.</span></span>     
    - <span data-ttu-id="d9b56-213">書式設定と、特にファイル内の空白文字は、出力されたコード内で変更されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-213">The formatting and in particular any white space in the file will be changed in the emitted code.</span></span> <span data-ttu-id="d9b56-214">コメントは保持されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-214">Comments will be preserved.</span></span>   
5. <span data-ttu-id="d9b56-215">これを実行した後も、コードのセマンティック解釈が変更された場合には、セマンティックの変更に手動で対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-215">After running this, you might still need to manually address semantic changes in cases where the semantic interpretation of the code has changed.</span></span> <span data-ttu-id="d9b56-216">これらのエラーはすべて、Visual Studio または Visual Studio Code の IntelliSense によって報告されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-216">All these errors will be reported by IntelliSense in Visual Studio or Visual Studio Code.</span></span>
    - <span data-ttu-id="d9b56-217">Visual Studio 2017 または Visual Studio Code で、プロジェクトまたはそれを含むソリューションのルートフォルダーを開きます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-217">Open the root folder of the project or the containing solution in Visual Studio 2017 or Visual Studio Code.</span></span>
    - <span data-ttu-id="d9b56-218">エディターで .qs ファイルを開いた後、出力ウィンドウに Q# 言語拡張機能の出力が表示されるはずです。</span><span class="sxs-lookup"><span data-stu-id="d9b56-218">After opening a .qs file in the editor, you should see the output of the Q# language extension in the output window.</span></span>
    - <span data-ttu-id="d9b56-219">プロジェクトが正常に読み込まれた (出力ウィンドウに示された) 後、各ファイルを開き、手動で残りのすべての問題に対処します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-219">After the project has loaded successfully (indicated in the output window) open each file and manually to address all remaining issues.</span></span>


> [!NOTE]
> * <span data-ttu-id="d9b56-220">0\.3 リリースでは、Quantum 開発キットに含まれている言語サーバーでは、複数のワークスペースがサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="d9b56-220">For the 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
> * <span data-ttu-id="d9b56-221">Visual Studio Code でプロジェクトを操作するには、プロジェクト自体とすべての参照先プロジェクトを含むルート フォルダーを開きます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-221">In order to work with a project in Visual Studio Code, open the root folder containing the project itself and all referenced projects.</span></span>   
> * <span data-ttu-id="d9b56-222">Visual Studio でソリューションを操作するには、ソリューションに含まれるすべてのプロジェクトが、ソリューションと同じフォルダーまたはそのサブフォルダーのいずれかに存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-222">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>  
> * <span data-ttu-id="d9b56-223">0\.3 以上に移行されたプロジェクトと、古いバージョンのパッケージを使用するプロジェクト間の参照はサポートされて**いません**。</span><span class="sxs-lookup"><span data-stu-id="d9b56-223">References between projects migrated to 0.3 and higher and projects using older package versions are **not** supported.</span></span>




## <a name="MigrationScript"></a><span data-ttu-id="d9b56-224">移行スクリプト</span><span class="sxs-lookup"><span data-stu-id="d9b56-224">Migration script</span></span> 

<span data-ttu-id="d9b56-225">プロジェクトの移行を容易にするために、[ここで](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)ダウンロードできる PowerShell スクリプトが用意されています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-225">In order to facilitate project migration, a PowerShell script is provided that can be downloaded [here](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span></span>
<span data-ttu-id="d9b56-226">このスクリプトは、バージョン0.2 の Quantum 開発キットのプロジェクトをバージョン0.3 を使用するように移行するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-226">This script helps migrate projects from version 0.2 of the Quantum Development Kit to use version 0.3.</span></span>

> [!NOTE]
> <span data-ttu-id="d9b56-227">移行スクリプトを実行するには、Windows PowerShell または PowerShell Core が必要です。</span><span class="sxs-lookup"><span data-stu-id="d9b56-227">The migration script requires Windows PowerShell or PowerShell Core to run.</span></span>
> <span data-ttu-id="d9b56-228">Windows PowerShell は、Windows 10 と共にプレインストールされています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-228">Windows PowerShell comes pre-installed with Windows 10.</span></span>
> <span data-ttu-id="d9b56-229">Windows、macOS、または Linux 用の PowerShell Core を https://github.com/PowerShell/PowerShell でダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="d9b56-229">Download PowerShell Core for Windows, macOS, or Linux at https://github.com/PowerShell/PowerShell.</span></span>

<span data-ttu-id="d9b56-230">このスクリプトでは、次の4つの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-230">The script executes the following four steps:</span></span>

- <span data-ttu-id="d9b56-231">このプロジェクトは、移行が成功する可能性があることを確認するために、以前のバージョンの Quantum 開発キットでビルドされています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-231">The project is built with the previous version of the Quantum Development Kit to ensure that migration is likely to succeed.</span></span> <span data-ttu-id="d9b56-232">このステップをスキップするには、スクリプトの `-Force` パラメーターを使用します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-232">This step can be skipped by using the `-Force` parameter to the script.</span></span>
- <span data-ttu-id="d9b56-233">新しいプロジェクトテンプレートがインストールされます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-233">New project templates are installed.</span></span>
- <span data-ttu-id="d9b56-234">現在のバージョンの Quantum Development Kit を使用するようにプロジェクトが更新されました。</span><span class="sxs-lookup"><span data-stu-id="d9b56-234">The project is updated to use the current version of the Quantum Development Kit.</span></span>
- <span data-ttu-id="d9b56-235">クォンタム開発キットのバージョン0.3 で提供されている書式設定ツールは、上記の重大な変更のほとんどに自動的に対応するために適用されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-235">The formatting tool provided with version 0.3 of the Quantum Development Kit is applied to automatically address most of the breaking changes documented above.</span></span>

<span data-ttu-id="d9b56-236">この4つの手順を完了すると、移行に関するいくつかの問題が発生し、手動で処理する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-236">After these four steps complete, there may be some remaining migration issues which must be handled manually.</span></span>
<span data-ttu-id="d9b56-237">最新バージョンの Visual Studio 2017 および Visual Studio Code 用の Quantum Development Kit 拡張機能を使用すると、これらの問題を簡単に見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-237">Using the latest version of the Quantum Development Kit extensions for Visual Studio 2017 and Visual Studio Code can help find these issues easily.</span></span>

<span data-ttu-id="d9b56-238">スクリプトのドキュメントを取得するには、スクリプトが配置されているフォルダー内の次のいずれかのコマンドを実行します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-238">The documentation for the script can be obtained by running one of the following commands in the folder where the script is located:</span></span>

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> <span data-ttu-id="d9b56-239">既定では、Windows では、セキュリティ対策としてすべてのスクリプトの実行が禁止されています。</span><span class="sxs-lookup"><span data-stu-id="d9b56-239">By default, Windows prevents the execution of any scripts as a security measure.</span></span>
> <span data-ttu-id="d9b56-240">`qdk-migrate.ps1` などのスクリプトを Windows で実行できるようにするには、実行ポリシーの変更が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="d9b56-240">To allow scripts such as `qdk-migrate.ps1` to run on Windows, you may need to change the execution policy.</span></span>
> <span data-ttu-id="d9b56-241">これを行うには、`Set-ExecutionPolicy` コマンドを実行します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-241">To do so, run the `Set-ExecutionPolicy` command:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> <span data-ttu-id="d9b56-242">PowerShell を終了すると、実行ポリシーが元に戻されます。</span><span class="sxs-lookup"><span data-stu-id="d9b56-242">The execution policy will then be reverted when you exit PowerShell.</span></span>
> <span data-ttu-id="d9b56-243">実行ポリシーを保存する場合は、`-Scope`に別の値を使用します。</span><span class="sxs-lookup"><span data-stu-id="d9b56-243">If you would like to save the execution policy, use a different value for `-Scope`:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

