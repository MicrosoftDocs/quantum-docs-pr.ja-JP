---
title: 'Q # の式'
description: 'Q # の式として、定数、変数、演算子、操作、関数を指定、参照、および結合する方法について説明します。'
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.language.expressions
ms.openlocfilehash: fbde873f220d737db17f889d00be33541e3eb59b
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907411"
---
# <a name="expressions"></a>式

## <a name="grouping"></a>グループ化

任意の式を指定すると、かっこで囲まれた同じ式が同じ型の式になります。
たとえば、`(7)` は `Int` 式で、`([1,2,3])` は `Int`s の型配列の式であり、`((1,2))` は型 `(Int, Int)`の式です。

[型モデル](xref:microsoft.quantum.language.type-model#tuple-types)で記述されている単純値と単一要素の組の等価性により、`(6)` とグループとしてのあいまいさが解消され、単一要素のタプルとして `(6)` ます。

## <a name="symbols"></a>記号

`'T` 型の値にバインドまたは割り当てられたシンボルの名前は `'T`型の式です。
たとえば、シンボル `count` が整数値 `5`にバインドされている場合、`count` は整数式になります。

## <a name="numeric-expressions"></a>数値式

数値式は `Int`、`BigInt`、または `Double`型の式です。
つまり、整数または浮動小数点数のいずれかです。

Q # のリテラル `Int` は、のC#整数リテラルと同じですが、末尾の "l" または "l" が不要 (または許可) である点が異なります。
16進数とバイナリ整数は、それぞれ "0x" プレフィックスと "0b" プレフィックスでサポートされています。

Q # のリテラル `BigInt` は、.NET では、末尾に "l" または "L" が付いた大きな整数の文字列と同じです。
16進数の大きな整数は、プレフィックス "0x" でサポートされています。
したがって、`BigInt` リテラルのすべての有効な使用法を次に示します。

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

Q # のリテラル `Double` は、の2つのC#リテラルと同じですが、末尾の "d" または "d" が不要 (または許可) である点が異なります。

任意の要素型の配列式が指定されている場合、`Length` の組み込み関数を使用して `Int` 式を作成できます。また、かっこ、`(`、および `)`で囲まれた配列式を使用します。
たとえば、`a` が配列にバインドされている場合、`Length(a)` は整数式になります。
`b` が整数の配列の配列である場合、`Int[][]`、`Length(b)` は `b`内のサブ配列の数、`Length(b[1])` は `b`の2番目のサブ配列の整数の数です。

同じ型の2つの数値式を指定した場合、2項演算子 `+`、`-`、`*`、および `/` を使用して、新しい数値式を作成できます。
新しい式の型は、構成式の型と同じになります。

2つの整数式を指定すると、二項演算子 `^` (累乗) を使用して新しい整数式を作成できます。
同様に、2つの double 式で `^` を使用して、新しい double 式を作成することもできます。
最後に、`^` は、左側の大きな整数と右にある整数を使用して、新しい大きな整数式を形成できます。
この場合、2番目のパラメーターは32ビットにする必要があります。それ以外の場合は、ランタイムエラーが発生します。

2つの整数または整数式が指定されている場合は、`%` (剰余)、`&&&` (ビット演算 AND)、`|||` (ビットごとの OR) 演算子、または `^^^` (ビットごとの XOR) 演算子を使用して、新しい整数または大きな整数式が形成される可能性があります。

左側に整数または整数式が指定されていて、右側に整数式が指定されている場合は、`<<<` (算術左シフト) 演算子または `>>>` (算術右シフト) 演算子を使用して、左側の式と同じ型の新しい式を作成できます。

シフト演算の2番目のパラメーター (シフト量) は、0以上である必要があります。負のシフト量の動作は未定義です。
また、いずれかのシフト操作のシフト量は、32ビットにも適合する必要があります。それ以外の場合は、ランタイムエラーが発生します。
シフトする数値が整数である場合、シフト数は `mod 64`に解釈されます。つまり、シフト1と65のシフトは同じ効果を持ちます。

整数値と大きな整数値の両方に対して、シフトは算術演算です。
負の値を左または右にシフトすると、負の数値になります。
つまり、1つのステップを左または右にシフトすることは、それぞれ2で乗算または除算するのとまったく同じです。

整数の除算と整数の剰余は、負の数値のC#場合と同じ動作に従います。
つまり、`a % b` は常に `a`と同じ符号を持ち、`b * (a / b) + a % b` は常に `a`と等しくなります。
例 :

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

大規模な整数除算と剰余は同じように動作します。

任意の数値式を指定した場合は、`-` 単項演算子を使用して新しい式を形成できます。
新しい式は、構成式と同じ型になります。

整数または整数式が指定されている場合、同じ型の新しい式は、`~~~` (ビットごとの補数) 単項演算子を使用して形成される可能性があります。

## <a name="boolean-expressions"></a>Boolean 式

2つの `Bool` リテラル値は `true` と `false`です。

同じプリミティブ型の2つの式を指定すると、`==` および `!=` 二項演算子を使用して `Bool` 式を作成できます。
2つの式が等しい場合、式は true になり、そうでない場合は false になります。

ユーザー定義型の値を比較することはできません。ラップ解除された値だけを比較できます。 たとえば、"ラップ解除" 演算子 ([ [Q # type model] ページ](xref:microsoft.quantum.language.type-model#user-defined-types)で説明) `!` を使用すると、次のようになります。

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

`Qubit` 値の等価比較は id の等価性を比較します。つまり、2つの式が同じ qubit を識別するかどうかを示します。
2つの qubits の状態は、この比較によって比較、アクセス、測定、または変更されません。

丸め効果により、`Double` 値の等価比較が誤解を受ける可能性があります。
たとえば、`49.0 * (1.0/49.0) != 1.0`します。

2つの数値式を指定した場合、2項演算子 `>`、`<`、`>=`、および `<=` を使用して、新しいブール式を作成できます。この式は、最初の式の値が、2番目の式の値よりも大きい、より小さい、または等しいか、または等しい場合に true になります。

2つのブール式を指定すると、2つの式の両方 (resp または両方) が true の場合に true になる新しいブール式を作成するために、`and` および `or` のバイナリ演算子を使用できます。

ブール式が指定されている場合、`not` 単項演算子を使用して新しいブール式を作成できます。これは、構成式が false の場合に true になります。

## <a name="string-expressions"></a>文字列式

Q # では、`fail` ステートメントと `Log` 標準関数で文字列を使用できます。

Q # の文字列は、リテラルまたは挿入文字列です。
文字列リテラルは、ほとんどの言語の単純な文字列リテラルに似ています。これは、二重引用符で囲まれた一連の Unicode 文字 (`"`) です。
文字列の内部では、バックスラッシュ文字 `\` を使用して二重引用符をエスケープし、改行を `\n`として挿入したり、`\r`としてキャリッジリターンを `\t`として挿入したりすることができます。
次に例を示します。

```qsharp
"\"Hello world!\", she said.\n"
```

文字列補間の Q # 構文は、 C# 7.0 構文のサブセットです。Q # では、逐語的 (複数行) の補間文字列はサポートされていません。
構文についてはC# 、「[*補間文字列*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings)」を参照してください。

挿入文字列内の式は、構文ではなくC# Q # 構文に従います。
有効な Q # 式は、挿入文字列に含めることができます。

## <a name="qubit-expressions"></a>Qubit 式

唯一の `Qubit` 式は、`Qubit` 配列の `Qubit` 値または配列要素にバインドされるシンボルです。
`Qubit` リテラルがありません。

## <a name="pauli-expressions"></a>P# li 式

4つの `Pauli` 値、`PauliI`、`PauliX`、`PauliY`、および `PauliZ`は、すべて有効な `Pauli` 式です。

それ以外の `Pauli` 式は、`Pauli` 配列の `Pauli` 値または配列要素にバインドされているシンボルのみです。

## <a name="result-expressions"></a>結果式

`One` と `Zero`の2つの `Result` 値は、有効な `Result` 式です。

それ以外の `Result` 式は、`Result` 配列の `Result` 値または配列要素にバインドされているシンボルのみです。
特に、`One` が整数 `1`と同じではなく、それらの間に直接変換がないことに注意してください。
`Zero` と `0`にも同じことが当てはまります。

## <a name="range-expressions"></a>範囲の式

`start`、`step`、および `stop`の3つの `Int` 式が指定されている場合、`start .. step .. stop` が渡されるまで、最初の要素が `start`、2番目の要素が `start+step`、3番目の要素が `start+step+step`などの範囲式です。`stop`
たとえば、`step` が正および `stop < start`の場合、範囲は空になることがあります。
`start` と `stop` の差が `step`の整数倍数である場合、範囲の最後の要素が `stop` されます。つまり、範囲は両端を含みます。

`start` と `stop`の2つの `Int` 式が指定されている場合、`start .. stop` は `start .. 1 .. stop`と等しい範囲式です。
`stop` が `start`より小さい場合でも、暗黙の `step` は + 1 であることに注意してください。このような場合、範囲は空になります。

範囲の例を次に示します。

- `1..3` の範囲は1、2、3です。
- `2..2..5` は2、4の範囲です。
- `2..2..6` は2、4、6の範囲です。
- `6..-2..2` は6、4、2の範囲です。
- `2..1` が空の範囲です。
- `2..6..7` の範囲は2です。
- `2..2..1` が空の範囲です。
- `1..-1..2` が空の範囲です。

## <a name="callable-expressions"></a>呼び出し可能式

呼び出し可能なリテラルは、コンパイルスコープで定義されている操作または関数の名前です。
たとえば、`X` は標準ライブラリ `X` 操作を参照する操作リテラルであり、`Message` は標準ライブラリ `Message` 関数を参照する関数リテラルです。

操作で `Adjoint` ファンクタがサポートされている場合、`Adjoint op` は演算式になります。
同様に、操作で `Controlled` ファンクタがサポートされている場合、`Controlled op` は演算式になります。
これらの式の型は、ファンクターで指定され[ます。](xref:microsoft.quantum.language.type-model#functors)

ファンクター (`Adjoint` および `Controlled`) は、ラップ解除演算子 `!` および `[]`での配列インデックス作成を除き、他のすべての演算子よりも密接にバインドされます。
このため、操作で使用されている機能がサポートされていれば、次のすべての処理が有効になります。

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

呼び出し可能なリテラルは、値として使用できます。たとえば、変数に代入する場合や、別の呼び出し可能に渡す場合です。
この場合、呼び出し可能な型パラメーターがある場合は、呼び出し可能な値の一部として指定する必要があります。
呼び出し可能な値には、指定されていない型パラメーターを含めることはできません。

たとえば、`Fun` がシグネチャ `'T1->Unit`の関数の場合は、次のようになります。

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>呼び出し可能呼び出し式

呼び出し可能なシグネチャの入力型の呼び出し可能な (操作または関数) 式と組式が指定されている場合、呼び出し式は、呼び出し可能な式にタプル式を追加することによって作成できます。
呼び出し式の型は、呼び出し可能なシグネチャの出力型です。

たとえば、`Op` がシグネチャ `((Int, Qubit) => Double)`を持つ操作の場合、`Op(3, qubit1)` は `Double`型の式です。
同様に、`Sin` がシグネチャ `(Double -> Double)`を持つ関数の場合、`Sin(0.1)` は `Double`型の式です。
最後に、`Builder` がシグネチャ `(Int -> (Int -> Int))`の関数である場合、`Builder(3)` は Into から Int への関数になります。

呼び出し可能な値の式の結果を呼び出すには、呼び出し可能な式を囲むかっこのペアを追加する必要があります。
したがって、前の段落から `Builder` を呼び出した結果を呼び出すために、正しい構文は次のようになります。

```qsharp
(Builder(3))(2)
```

型パラメーター呼び出し可能呼び出しを呼び出すときに、実際の型パラメーターを山かっこ内に指定して、呼び出し可能な式の後に `>` `<` ことができます。
これは通常、Q # コンパイラによって実際の型が推論されるため、不要です。
型パラメーターの引数が指定されていない場合は、部分的なアプリケーション (下記参照) に必要です。
また、異なるファンのサポートを持つ操作を呼び出し可能に渡す場合にも便利です。

たとえば、`Func` に署名 `('T1, 'T2, 'T1) -> 'T2`がある場合、`Op1` と `Op2` に署名 `(Qubit[] => Unit is Adj)`があり、`Op3` に署名 `(Qubit[] => Unit)`があり、1番目の引数として `Func` を呼び出して、3番目の引数として `Op1` します。`Op2``Op3`

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

`Op3` と `Op1` の型が異なるため、型指定が必要です。そのため、コンパイラはこれを仕様なしにあいまいとして扱います。

### <a name="partial-application"></a>部分アプリケーション

呼び出し可能な式が指定されている場合は、呼び出し可能な引数のサブセットを指定することによって、新しい呼び出し可能を作成できます。
これは、_部分的なアプリケーション_と呼ばれます。

Q # では、部分的に適用された呼び出し可能は、通常の呼び出し式を記述することによって表されますが、指定されていない引数にはアンダースコア (`_`) を使用します。
結果として得られる呼び出し元は、基本の呼び出し元と同じ結果型と、操作に対して同じ特殊化を持ちます。
部分アプリケーションの入力型は、指定された引数が削除された元の型にすぎません。

部分アプリケーションの作成時に、変更可能な変数が指定された引数として渡される場合は、変数の現在の値が使用されます。
後で変数の値を変更しても、部分的なアプリケーションには影響しません。

たとえば、`Op` の型が `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`の場合、次のようになります。

- `Op(5,(_,_))` に `(((Qubit,Qubit), Double) => Unit is Adj)`型があるため、`Op(5,_)`があります。
- `Op(_,(_,1.0))` に `((Int, (Qubit,Qubit)) => Unit is Adj)`型があります。
- `Op(_,((q1,q2),_))` に `((Int,Double) => Unit is Adj)`型があります。
   ここでは、シングルトンタプルの等価性が適用されていることに注意してください。

部分的に適用される呼び出し可能な型パラメーターがコンパイラによって推論できない場合は、呼び出しサイトで指定する必要があります。
部分アプリケーションは、指定されていない型パラメーターを持つことはできません。

たとえば、`Op` の型が `(('T1, Qubit, 'T1) => Unit : Adjoint)`の場合、次のようになります。

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### <a name="recursion"></a>再帰

Q # callables は、直接的または間接的に再帰的に許可されています。
つまり、操作または関数はそれ自体を呼び出すことができます。または、呼び出し可能な操作を直接または間接的に呼び出す別の呼び出し元を呼び出すことができます。

ただし、再帰の使用に関しては、次の2つの重要なコメントがあります。

- 操作で再帰を使用すると、特定の最適化が妨げられる可能性があります。
  これは、アルゴリズムの実行時間に大きな影響を与える可能性があります。
- 実際のクォンタムデバイスで実行すると、スタック領域が制限される可能性があるため、詳細な再帰によって実行時エラーが発生する可能性があります。
  特に、Q # コンパイラとランタイムは、末尾の再帰を識別して最適化しません。

## <a name="tuple-expressions"></a>タプル式

組リテラルは、適切な型の要素式のシーケンスであり、コンマで区切られ、`(` と `)`で囲まれています。
たとえば、`(1, One)` は `(Int, Result)` 式です。

リテラル以外の唯一のタプル式は、タプル値にバインドされたシンボル、組配列の配列要素、およびタプルを返す呼び出し可能な呼び出しです。

## <a name="user-defined-type-expressions"></a>ユーザー定義型の式

ユーザー定義型のリテラルは、型名の後に型の基本タプル型のタプルリテラルが含まれています。
たとえば、`IntPair` が `(Int, Int)`に基づくユーザー定義型である場合、`IntPair(2,3)` はその型の有効なリテラルになります。

リテラル以外に、ユーザー定義型の唯一の式は、その型の値、その型の配列の配列要素、およびその型を返す呼び出し可能な呼び出しの値にバインドされている記号です。

## <a name="unwrap-expressions"></a>ラップ解除 (式の)

Q # では、ラップ解除演算子は、末尾の感嘆符 `!`になります。
たとえば、`IntPair` が基になる型が `(Int, Int)`であるユーザー定義型で、`s` が値 `IntPair(2,3)`の変数である場合、`s!` が `(2,3)`されます。

他のユーザー定義型の観点から定義されたユーザー定義型の場合。 ラップ解除演算子は、繰り返すことができます。たとえば、`s!!` は `s`のダブルラップされていない値を示します。
したがって `WrappedPair` が基になる型が `IntPair`であるユーザー定義型で、`t` が値 `WrappedPair(IntPair(1,2))`の変数である場合、`t!!` が `(1,2)`されます。

`!` 演算子は、配列のインデックス作成とスライスのために `[]` 以外の他のすべての演算子より優先順位が高くなります。
`!` と `[]` bind 位置;つまり、`a[i]![3]` を `((a[i])!)[3]`として読み取る必要があります。 `a`の `i`' 番目の要素を取得してラップを解除し、ラップ解除された値の3番目の要素 (配列である必要があります) を取得します。

`!` 演算子の優先順位には、明らかでない可能性がある1つの影響があります。
関数または操作が、ラップされていない値を返す場合は、ラップ解除ではなく、引数のタプルが呼び出しにバインドされるように、関数または操作の呼び出しをかっこで囲む必要があります。
例 :

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>配列式

配列リテラルは、`[` および `]`で囲まれた、コンマで区切られた1つ以上の要素式のシーケンスです。
すべての要素は、同じ型と互換性がある必要があります。

共通の要素型が演算型または関数型である場合、すべての要素の入力と出力の型が同じである必要があります。
配列の要素型は、すべての要素でサポートされているすべての機能をサポートします。
たとえば、`Op1`、`Op2`、および `Op3` はすべて `Qubit[] => Unit`ですが、`Op1` は `Adjoint`をサポートし、`Op2` は両方をサポートします。`Controlled``Op3`

- `[Op1, Op2]` は `(Qubit[] => Unit)` 操作の配列です。
- `[Op1, Op3]` は `(Qubit[] => Unit is Adj)` 操作の配列です。
- `[Op2, Op3]` は `(Qubit[] => Unit is Ctl)` 操作の配列です。

空の配列リテラル `[]`は許可されていません。
代わりに `new ★[0]`を使用します。 `★` は適切な型のプレースホルダーとして使用されるため、では、必要な長さゼロの配列を作成できます。

同じ型の2つの配列を指定した場合、2つの配列を連結した新しい配列を形成するために、バイナリ `+` 演算子を使用できます。
たとえば、`[1,2,3] + [4,5,6]` は `[1,2,3,4,5,6]`です。

### <a name="array-creation"></a>配列の作成

型と `Int` 式が指定されている場合、`new` 演算子を使用して、指定されたサイズの新しい配列を割り当てることができます。
たとえば、`new Int[i+1]` は `i+1` 要素を持つ新しい `Int` 配列を割り当てます。

新しい配列の要素は、型に依存する既定値に初期化されます。
ほとんどの場合、これはゼロのバリエーションです。

エンティティへの参照である qubits と callables 指定できる場合、適切な既定値はありません。
したがって、これらの型では、既定値は無効な参照で、ランタイムエラーを発生させずに使用することはできません。
これは、や Java などの言語での null C#参照に似ています。
Qubits または callables 含む配列は、要素が安全に使用される前に、既定値以外の値で適切に初期化されている必要があります。 適切な初期化ルーチンについては、<xref:microsoft.quantum.arrays>を参照してください。

各型の既定値は次のとおりです。

種類 | 既定値
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _無効な qubit_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | 空の範囲、`1..1..0`
 `Callable` | _無効な呼び出し可能_
 `Array['T]` | `'T[0]`

タプル型は要素ごとに初期化されます。


### <a name="jagged-arrays"></a>ジャグ配列

ジャグ配列は、"配列の配列" と呼ばれることもあり、要素が配列である配列です。 ジャグ配列の要素のサイズは異なる場合があります。 次の例は、乗算テーブルを表すジャグ配列を宣言および初期化する方法を示しています。

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {

    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```


### <a name="array-slices"></a>配列スライス

配列式と `Range` 式が指定されている場合は、`[` と `]` の配列スライス演算子を使用して新しい式を作成できます。
新しい式は配列と同じ型になり、`Range`の要素によってインデックス付けされた配列項目が、`Range`で定義されている順序で格納されます。
たとえば、`a` が `Double`s の配列にバインドされている場合、`a[3..-1..0]` は、`a` の最初の4つの要素を含む `Double[]` 式です。ただし、`a`に表示される順序は逆になります。

`Range` が空の場合、結果として得られる配列スライスは長さ0になります。

配列式が単純識別子でない場合は、スライスするためにかっこで囲む必要があります。
たとえば、`a` と `b` が両方とも `Int`の配列である場合、連結のスライスは次のように表されます。

```qsharp
(a+b)[1..2..7]
```

Q # のすべての配列は0から始まります。
つまり、配列 `a` の最初の要素は常に `a[0]`ます。

0\.8 リリース以降では、範囲スライスのコンテキスト式がサポートされています。 特に、範囲の開始値と終了値は、範囲スライス式のコンテキストでは省略できます。 その場合、コンパイラは次の規則を適用して、範囲の目的の区切り記号を推論します。 

たとえば、範囲の開始値を省略した場合、推論される開始値 
- ステップが指定されていない場合、または指定されたステップが正の場合、は0です。 
- 指定した手順が負の場合に、スライスされた配列の長さから1を引いた値です。 

範囲の終了値を省略した場合、推論された終了値 
- スライスされた配列の長さ、ステップが指定されていない場合、または指定されたステップが正の場合は1を引いた値です。 
- 指定されたステップが負の場合、は0になります。 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

## <a name="array-element-expressions"></a>配列要素の式

配列式と `Int` 式が指定されている場合は、`[` と `]` 配列要素演算子を使用して新しい式を作成できます。
新しい式は、配列の要素型と同じ型になります。
たとえば、`a` が `Double`s の配列にバインドされている場合、`a[4]` は `Double` 式になります。

配列式が単純識別子でない場合は、要素を選択するために、その式をかっこで囲む必要があります。
たとえば、`a` と `b` が両方とも `Int`の配列である場合、連結の要素は次のように表されます。

```qsharp
(a+b)[13]
```

Q # のすべての配列は0から始まります。
つまり、配列 `a` の最初の要素は常に `a[0]`ます。


## <a name="copy-and-update-expressions"></a>コピーと更新の式

コピーと更新の式を使用して、既存の配列から新しい配列を作成できます。
コピーおよび更新式は `expression1 w/ expression2 <- expression3`の形式の式です。ここで、`expression1` は `T`型の `T[]` 型である必要があります。 2番目の `expression2` は、`expression1` の配列と比較して変更する要素のインデックスを定義し、`Int` 型または `Range`型のいずれかである必要があります。 `expression2` が `Int`型の場合、`expression3` は `T`型である必要があります。 `expression2` が `Range`型の場合、`expression3` は `T[]`型である必要があります。

コピーおよび更新式 `arr w/ idx <- value` は、`arr`内の対応する要素に設定されたすべての要素を含む新しい配列を構築します。ただし、`idx`の要素は `value`内の1つの要素に設定されます。 たとえば、`arr` に配列 `[0,1,2,3]`が含まれている場合、 
- `arr w/ 0 <- 10` は配列 `[10,1,2,3]`です。
- `arr w/ 2 <- 10` は配列 `[0,1,10,3]`です。
- `arr w/ 0..2..3 <- [10,12]` は配列 `[10,1,12,3]`です。

ユーザー定義型の名前付き項目についても、同様の式が存在します。 型の例を考えてみましょう。 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
`Complex(1.,-1.)`型の値が `c` に含まれている場合、`c w/ Re <- 0.` は `Complex(0.,-1.)`に評価される `Complex` 型の式です。

## <a name="conditional-expressions"></a>条件式

同じ型の2つの式とブール式が指定されている場合は、疑問符 `?` と縦棒 `|`を使用して条件式を形成できます。
たとえば、`a==b ? c | d`します。
この例では、`a==b` が true の場合に条件式の値が `c` され、false の場合は `d` ます。

2つの式は、入力と出力が同じでも異なる機能をサポートする操作に評価される場合があります。
この場合、条件式の型は、両方の式でサポートされているすべての機能をサポートする入力と出力を持つ操作です。
たとえば、`Op1`、`Op2`、および `Op3` はすべて `Qubit[]=>Unit`ですが、`Op1` は `Adjoint`をサポートし、`Op2` は両方をサポートします。`Controlled``Op3`

- `flag ? Op1 | Op2` は `(Qubit[] => Unit)` 操作です。
- `flag ? Op1 | Op3` は `(Qubit[] => Unit is Adj)` 操作です。
- `flag ? Op2 | Op3` は `(Qubit[] => Unit is Ctl)` 操作です。

2つの結果式のいずれかに関数呼び出しまたは演算呼び出しが含まれている場合、その呼び出しは、その結果が呼び出しの値になる場合にのみ行われます。
たとえば、`a==b ? C(qs) | D(qs)`の場合、`a==b` が true の場合、`C` 操作が呼び出され、false の場合は `D` のみが呼び出されます。
これは、他の言語のショートサーキットに似ています。


## <a name="operator-precedence"></a>演算子の優先順位

すべての二項演算子は、`^`を除き、右から結合されます。

角かっこ、`[` および `]`。配列のスライスとインデックス作成では、任意の演算子の前にバインドします。

`Adjoint` と `Controlled` は、配列のインデックス作成後、他のすべての演算子の前にバインドされます。

演算と関数呼び出しのかっこは、演算子の前、配列のインデックス作成および関数の後にもバインドされます。

演算子は優先順位の高い順になります。

演算子 | アリ | 説明 | オペランドの型
---------|----------|---------|---------------
 `!` の末尾 | 単項演算子 | ラップ解除 | 任意のユーザー定義型
 `-`、`~~~`、`not` | 単項演算子 | 負の数値、ビットごとの補数、論理否定 | `Int` の `-`、`BigInt`、`~~~`の `Int`、`BigInt` または `Double` `Bool` の `not`
 `^` | Binary | 整数の累乗 | 底の `Int` または `BigInt`。指数部は `Int`
 `/`、`*`、`%` | Binary | 除算、乗算、整数剰余 | `Int`、`BigInt` または `Double` の `/` と `*`、`Int` `BigInt``%`
 `+`, `-` | Binary | 加算または文字列と配列の連結、減算 | `Int`、`BigInt` または `Double`、さらに `String` または任意の配列型 `+`
 `<<<`, `>>>` | Binary | 左シフト、右シフト | `Int` または `BigInt`
 `<`、`<=`、`>`, `>=` | Binary | より小さい、より小さい、または等しい、より大きい、より大きい、または等しい比較 | `Int`、`BigInt` または `Double`
 `==`, `!=` | Binary | 等しい、等しくない比較 | 任意のプリミティブ型
 `&&&` | Binary | ビット演算子 AND | `Int` または `BigInt`
 `^^^` | Binary | ビットごとの XOR | `Int` または `BigInt`
 <code>\|\|\|</code> | Binary | ビットごとの OR | `Int` または `BigInt`
 `and` | Binary | 論理積 | `Bool`
 `or` | Binary | 論理和 | `Bool`
 `..` | Binary/三項 | 範囲演算子 | `Int`
 `?` `|` | 三項 | 条件付き | 左側のの `Bool`
`w/` `<-` | 三項 | コピーと更新 | 「[コピーと更新の式」を](#copy-and-update-expressions)参照してください。
