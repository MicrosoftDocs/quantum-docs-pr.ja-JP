---
title: Q# プログラムの概要
description: クォンタムプログラムの基本的な構造と、クォンタムの状態の変換を表す方法について説明します。
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907700"
---
# <a name="q-program-overview"></a>Q# プログラムの概要

Q # は、クォンタムコンピューティング用のスケーラブルでマルチパラダイムのドメイン固有のプログラミング言語です。 Q # は、クォンタムコンピューターで命令を実行する方法を説明するために使用できるクォンタムプログラミング言語です。 対象となる可能性のあるマシンは、シミュレーターから実際の量子ハードウェアまで多岐に適用されます。 Q # はスケーラブルです。これを使用すると、いくつかの qubits で実行されるテレポートなどの単純なデモンストレーションプログラムを作成できます。また、数百万の qubits を持つ大規模なコンピューターを必要とする複雑な分子のシミュレーションなど、大規模な高度なプログラムの作成もサポートされます。 大規模な物理マシンが今後も使用されている場合でも、Q # ではプログラマが複雑なクォンタムアルゴリズムをプログラミングできます。 さらに、Q # は、デバッグ、プロファイリング、リソースの推定、特定の特別な目的のシミュレーションなどのさまざまなタスクをスケーラブルな方法でサポートしています。 

技術的な観点からは、クォンタムプログラムは特定の一連のクラシック関数として認識されます。これを呼び出すと、その副作用としてクォンタム回線が生成されます。 このビューの重要な結果として、Q # で記述されたプログラムは、qubits 自体を直接モデル化するのではなく、従来のコントロールコンピューターがその qubits とどのようにやり取りするかを説明します。
仕様により、Q # はクォンタムの状態やその他の量子機構のプロパティを直接定義するのではなく、言語で定義されたさまざまなサブルーチンのアクションを通じて間接的に実行します。
たとえば、「[クォンタムコンピューティングの概念](xref:microsoft.quantum.concepts.intro)」ガイドで説明されているように、"$ \ket{+} = \ left (\ket{0} + \ket{1}/\ sqrt{2}$" という状態を検討してください。
この状態を Q # で準備するには、qubits が $ \ket{0}$ state で初期化され、$ \ket{+} = H\ket{0}$ というファクトを使用します。ここで、$H $ は Hadamard transform です。

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a>Q # 変換クォンタムの状態

重要なのは、上記のプログラムを作成するときに、Q # 内の状態を明示的に参照するのではなく、その状態がプログラムによってどのように*変換*されたかを説明することです。
したがって、グラフィックスシェーダープログラムが各頂点への変換の説明を累積するのと同様に、Q # のクォンタムプログラムはクォンタムの状態への変換を累積します。
これにより、各ターゲットコンピューター上でもクォンタムの状態を完全には認識できなくなります。これは、コンピューターによって*は*、解釈が異なる場合があります。 

Q # プログラムの観点から見ると、qubit はターゲットコンピューターの内部構造への完全に不透明な参照です。
Q # プログラムは、introspect の状態、ターゲットコンピューター上の表現、またはプログラムで使用可能な他の qubit と同じ qubit であるかどうかを確認することはできません。
代わりに、プログラムは、`Measure` などの操作を呼び出して、qubit から情報を取得し、`X` や `H` などの操作を呼び出して、qubit の状態を操作できます。
これらの操作には、言語内に組み込みの定義がないため、特定の Q # プログラムを実行するために使用されるターゲットコンピューターによってのみ具体的に作成されます。
Q # プログラムは、ターゲットコンピューターによって定義されたこれらの操作を結合して、クォンタム計算を表す新しい高レベルの操作を作成します。
このようにして、Q # を使用すると、ターゲットコンピューターまたはシミュレーターの構造に関しても一般的に、基になるクォンタムやハイブリッド量子化アルゴリズムを簡単に表現できます。

## <a name="q-operations-and-functions"></a>Q # 操作と関数

具体的に Q # プログラムは、1つ以上の*操作*、1つ以上の*関数*、およびユーザー定義型で構成されています。 操作は、クォンタムコンピューターの状態の変換を記述するために使用され、Q # プログラムの最も基本的なビルドブロックです。 Q # で定義された各操作は、ターゲットコンピューターによって実装されている*組み込みの組み込み操作を*含む、他の任意の数の操作を呼び出すことができます。
コンパイルされると、各操作はターゲットコンピューターに提供できる .NET クラス型として表されます。

操作とは対照的に、関数は純粋な古典動作を説明するために使用されます。また、古典出力値の計算以外にも影響はありません。 Q # は、厳密に型指定された言語であり、組み込みのプリミティブ型のセットと、ユーザー定義型のサポートを備えています。 

このガイドの残りの部分では、さまざまな言語の概念と構成要素を使用して、操作、関数、および型の基本的な構成要素を使用して複雑なクォンタムプログラムを定義する方法について説明します。 

## <a name="structure-of-q-source-files"></a>Q # ソースファイルの構造

少なくとも、Q # ソースファイルは*名前空間宣言*で構成されます。これは、ソースファイル内の定義を格納する .net 名前空間を指定します。
他の Q # ソースファイルおよびライブラリの定義は、`open` ステートメントを使用して含めることができます。
たとえば、基本的なゲートを定義する操作のほとんどは、<xref:microsoft.quantum.intrinsic> 名前空間で定義されています。
コードでこれを使用できるようにするには、各ファイルの先頭にその名前空間を `open` します。

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

名前空間内では、各 Q # ソースファイルで、*操作*、*関数*、および*ユーザー定義型*の任意の組み合わせを定義できます。
このセクションの残りの部分では、それぞれについて説明し、効果的なクォンタムプログラムを作成するために実際に使用する方法の例を示します。
