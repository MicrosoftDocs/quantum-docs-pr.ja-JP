---
title: 量子コンピューティングの歴史と背景
description: 量子コンピューティングの歴史、そのしくみに関する背景、および Microsoft Quantum Development Kit について説明します。
author: QuantumWriter
ms.author: nawiebe
uid: microsoft.quantum.concepts.intro
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: fb1df9e3460c18d0cdc0ff430fa236192b3aa2fa
ms.sourcegitcommit: 9d1c045cf1a2c3e19030cb38dbc7496dbd24ab58
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/13/2020
ms.locfileid: "73442298"
---
# <a name="quantum-computing-history-and-background"></a>量子コンピューティングの歴史と背景

過去数年で多数の新しいコンピューター テクノロジが登場した中、量子コンピューティングは、開発者にとって最大限のパラダイムシフトとなるテクノロジであると考えられています。  量子コンピューターは、1980年に [Richard Feynman](https://en.wikipedia.org/wiki/Richard_Feynman) と [Yuri Manin](https://en.wikipedia.org/wiki/Yuri_Manin) によって提案されました。  量子コンピューティングを推進させたのは、脅威的な科学の進化に立ちはだかった、単純なシステムでさえもモデル化することができないという、物理学史上最も大きな課題の 1 つから来ています。 このように、量子力学は 1900 年から 1925 年の間に開発され、化学、物性物理学、そして最終的にはコンピューター チップから LED ライトに至るテクノロジの基礎となります。  しかし、これらの成功にもかかわらず、量子力学をもってしてもモデル化することができなかった最も単純なシステムもあります。  これは、たった数十個の粒子が相互作用するシステムのシミュレートであっても、従来のコンピューターでは数千年分以上の処理能力が必要になるためです。

量子力学をシミュレートすることが難しい理由を理解するには、さまざまな方法があります。  おそらく、量子論を解釈する最も簡単な方法が、物質は、量子レベルでは同時に異なる複数の配位にある (*状態*) と理解することです。  従来の確率論とは異なり、このような多くの量子状態の配位は、観察することで波のように干渉する可能性があります。  この干渉により、統計サンプリングを使用して量子状態の配位を取得することは困難です。  量子進化について理解するには、代わりに量子システムで*可能なすべての*配位を追跡する必要があります。  

ここで、$40$ 通りの配置が可能な原子システムを考えてみましょう。  この場合、原子は $2^{40}$ 通りのいずれかの配位になります (配置ごとに電子が存在するかどうかが異なるため)。 原子の量子状態を従来のコンピューターのメモリに格納するには、$130$ GB を超えるメモリが必要になります。  非常に大きな数ですが、一部のコンピューターでは対応可能です。  粒子の位置を $41$ 通りにすると、$2^{41}$ 通りと比べて 配置の数は 2 倍になります。この場合、量子状態を格納するには $260$ GB 以上のメモリが必要になります。 今後も状態を保存する場合、存在している最も強力なメモリの容量を超えてしまうため、配置の数を永久に増やし続けることはできません。  原子の数が数百を超えた時点で、システムを格納するために必要なメモリ数は全宇宙に存在する粒子の数を超えるため、従来のコンピューターでは量子力学をシミュレートすることは不可能です。 それでもなお、自然界のこのようなシステムは、従来の計算能力ではこの進化を設計およびシミュレートできないことを横目に、量子力学の法則に従って時間の経過と共に進化を続けています。

この観察によって、このような問題をどのようにチャンスに変えることができるのか、という量子力学の初期構想につながるシンプルかつ強力な疑問が問われることになったのです。  具体的には、もし量子力学のシミュレーションを行うことが困難な場合、基本演算に量子効果を採用したハードウェアを構築した場合に何が起こるかという問いです。  自然界で粒子を支配している法則と全く同じシステムを使用して、粒子が相互作用するシステムをシミュレートすることはできるのでしょうか。 本質的に自然界には存在しないが、量子力学の法則に従う、または恩恵を受けているタスクを調査することはできるのでしょうか。  このような質問が、量子コンピューティングの起源となりました。

量子コンピューティングの根幹では、プログラムの量子干渉を利用および学習し、情報を物質の量子状態に格納して、その情報に対して量子ゲート演算を使用して計算を実行します。  従来のコンピューターでは困難と考えられていた問題を解決するためのプログラミング干渉の初期の例は、1994に [Peter Shor](https://en.wikipedia.org/wiki/Peter_Shor) が行ったファクタリングと呼ばれる問題です。  ファクタリングを解決することで、RSA や楕円曲線暗号など、現在の e コマースのセキュリティの基盤となる公開キー暗号システムの多くを破ることができます。  その後、高速で効率的な量子コンピューターのアルゴリズムが、化学、物理的、マテリアルサイエンスにおける物理システムのシミュレーション、順序付けられていないデータベースの検索、線型方程式系の計算、および機械学習のような多くのハードな従来型のタスク向けに開発されています。

干渉を活用するよう量子プログラムを設計するのは困難な課題のようにも思えます。もちろんこれは間違いではありませんが、同時に、量子プログラミングとアルゴリズムの開発をより身近にする、Microsoft Quantum Development Kit を含む多くの手法とツールが登場しています。 ソリューションがあらゆる可能性のもつれの中失われたないようにしつつ、計算を行う上で便利なように量子の干渉を操作する基本的な手法は多数存在します。 量子プログラミングは、量子アルゴリズムの考え方を理解し、表現するためのツールが非常に異なる従来のプログラミングとは全く異なるものです。 ご想像の通り、量子開発者を支援するための一般的なツールがなければ、量子プログラミングの技術である量子アルゴリズムの開発は容易ではありません。

Microsoft Quantum Development Kit は、成長を続けるコミュニティに、タスク、問題、ソリューションの量子革命をもたらすツールを提供します。 Microsoft の高度なプログラミング言語である Q# は、量子プログラミングの課題に対処するよう設計されています。これはソフトウェア スタックに統合されており、量子アルゴリズムを量子コンピューターのプリミティブ操作にコンパイルできるようになります。  プログラミング言語を扱う前に、量子コンピューティングの基になっている基本的な原則を確認することをお勧めします。 量子力学の基礎を詳述する代わりに、量子コンピューティングの基本的な規則は自明の理として扱います。 また、線形代数 (ベクトル、マトリクスなど) に関する基本的な知識を前提としています。 量子コンピューティングの歴史と原則をより深く学ぶには、詳しい情報が記載されている[リファレンス セクション](xref:microsoft.quantum.more-information)を参照してください。
