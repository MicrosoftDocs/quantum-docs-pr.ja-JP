---
title: ソフトウェアスタック |Microsoft Docs
description: ソフトウェアスタック
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184731"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="af212-103">クォンタムコンピューティングのソフトウェアスタック</span><span class="sxs-lookup"><span data-stu-id="af212-103">Software stack for quantum computing</span></span>
<span data-ttu-id="af212-104">通常、コンピューターの場合は、アプリケーションを実行している1台のデバイスを考えますが、最新のコンピューティング環境ははるかに複雑で高度なものです。</span><span class="sxs-lookup"><span data-stu-id="af212-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="af212-105">通常、対話するアプリケーションは、ハードウェアレベルまでアプリケーションの実行を提供する複数のソフトウェアレイヤーに置かれます。</span><span class="sxs-lookup"><span data-stu-id="af212-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="af212-106">これらのソフトウェアレイヤーは、完全なコンピューティングシステムの根底にある複雑さからアプリケーションソリューションの開発を抽象化するために必要です。</span><span class="sxs-lookup"><span data-stu-id="af212-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="af212-107">開発者が、単純な smartphone アプリを作成するときに、バス、キャッシュアーキテクチャ、通信プロトコルなどを考慮する必要がある場合、タスクははるかに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="af212-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="af212-108">*ソフトウェアスタック*の概念は、これらの問題に対処するために、従来のコンピューティング環境で開発されました。</span><span class="sxs-lookup"><span data-stu-id="af212-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="af212-109">従来の概念から借りて、ソフトウェアスタックは、Q # を使用した量子コンピューティングの背後にある構想の重要な部分でもあります。</span><span class="sxs-lookup"><span data-stu-id="af212-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="af212-110">従来のスタック</span><span class="sxs-lookup"><span data-stu-id="af212-110">Conventional stack</span></span>
<span data-ttu-id="af212-111">ソフトウェアスタックの背後にある重要な概念は再帰的です。</span><span class="sxs-lookup"><span data-stu-id="af212-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="af212-112">これは、開発者から離れた場所にあるデバイスの下位レベルの詳細を抽象化する、いくつかの入れ子になったインターフェイスのレイヤーで構成されます。</span><span class="sxs-lookup"><span data-stu-id="af212-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="af212-113">たとえば、一般的に使用されるソフトウェアスタックには、SQL server (リレーショナルデータベース管理システム) 上で ASP.NET (プログラミング言語) を実行することが含まれます。これは、Windows server 上で実行される (web サーバー) インターネットインフォメーションサービス (オペレーティングシステム)。コンピューターのハードウェアをドライブにします。</span><span class="sxs-lookup"><span data-stu-id="af212-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="af212-114">ソフトウェアを階層として確認することにより、その下にあるすべてのソフトウェアの下位レベルの詳細を理解しなくても、ASP.NET でソフトウェアを作成できます。</span><span class="sxs-lookup"><span data-stu-id="af212-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="af212-115">クォンタムスタック</span><span class="sxs-lookup"><span data-stu-id="af212-115">Quantum stack</span></span>

<span data-ttu-id="af212-116">クォンタムコンピューティングのソフトウェアスタックは原理によって異なりますが、実際には従来のスタックよりも低いレベルで動作します。</span><span class="sxs-lookup"><span data-stu-id="af212-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="af212-117">クォンタムスタックの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="af212-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="af212-118">クォンタムコンピューターは、従来の (従来の) コンピューターに代わるものではありません。</span><span class="sxs-lookup"><span data-stu-id="af212-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="af212-119">実際、量子コンピューターは、計算の問題を解決するために、ほとんどの場合、従来のコンピューターと連携して動作します。</span><span class="sxs-lookup"><span data-stu-id="af212-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="af212-120">このことは、クォンタムデータの脆弱性が原因で発生します。</span><span class="sxs-lookup"><span data-stu-id="af212-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="af212-121">クォンタムデータが壊れていると、そのようなデータが見られた場合に、その情報が破損してしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="af212-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="af212-122">そのため、量子コンピューターは、その物理環境からのやり取りが誤って情報や計算に悪影響を与えないように、クォンタムエラーの修正を念頭に置いて設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="af212-123">このため、Q # の自然なターゲットは、クォンタム命令 (ゲートまたはゲート操作と呼ばれます) の一覧を受け取り、その命令をクォンタムに適用する、エラーによって修正されたクォンタムコンピューター (多くの場合、*フォールトトレラント*なクォンタムコンピューターと呼ばれます) です。その中に格納されているデータ。</span><span class="sxs-lookup"><span data-stu-id="af212-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="af212-124">クォンタムアルゴリズムまたはプログラムでの qubits とゲート操作の数が十分でない場合は、エラー修正が絶対に必要ではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="af212-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="af212-125">ただし、qubits とゲート操作の数が増えるにつれて、これはより確実に要件になります。そのため、ソフトウェアスタックと Q # をこのし、効率的にエラー修正を処理し、スケーラブルでフォールトトレラントなクォンタムコンピューティングを実現します。</span><span class="sxs-lookup"><span data-stu-id="af212-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="af212-126">エラーの修正</span><span class="sxs-lookup"><span data-stu-id="af212-126">Error correction</span></span>
<span data-ttu-id="af212-127">エラー修正では、クォンタム計算に示されているエラーを修正するために、クォンタムコンピューターと連携して、高速で信頼性の高いクラシックコンピューターを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="af212-128">実際には、フィールドによってプログラミング可能なゲート配列 (FPGAs) や高速な crヨーク genic などのコンポーネントは、クォンタムコンピューターに自然に蓄積されるよりも迅速にエラーを特定し、修正する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="af212-129">その結果、quantum コンピューターは、さまざまな温度で動作する複数の異なる計算デバイスで構成されるハイブリッドコンピューターです。</span><span class="sxs-lookup"><span data-stu-id="af212-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="af212-130">このため、クォンタムの実装を最終的に実現するために必要なハードウェアとソフトウェア (古典およびクォンタム) のレイヤーが多数存在するため、ソフトウェアスタックのレンズを通じて、quantum コンピューターのプログラミングについて考える方がはるかに便利です。クォンタムコンピューター上のアルゴリズム。</span><span class="sxs-lookup"><span data-stu-id="af212-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="af212-131">クォンタムの概念スタック</span><span class="sxs-lookup"><span data-stu-id="af212-131">Quantum conceptual stack</span></span>
<span data-ttu-id="af212-132">クォンタムコンピューティング環境でのファクタリング8704143553785700723の機能フローを示す概念スタックを次に示します。</span><span class="sxs-lookup"><span data-stu-id="af212-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![ソフトウェアスタック](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="af212-134">仕様とアルゴリズム</span><span class="sxs-lookup"><span data-stu-id="af212-134">Specification and algorithm</span></span>
<span data-ttu-id="af212-135">このようなクォンタム計算のプログラミングには、さまざまな段階があります。</span><span class="sxs-lookup"><span data-stu-id="af212-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="af212-136">最初に、最も困難なフェーズは、解決する問題を特定することです。</span><span class="sxs-lookup"><span data-stu-id="af212-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="af212-137">この場合の問題は、2つの素数の積に数値8704143553785700723を因数分解することです。</span><span class="sxs-lookup"><span data-stu-id="af212-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="af212-138">次の手順では、この計算問題を解決するためのアルゴリズムを設計します。</span><span class="sxs-lookup"><span data-stu-id="af212-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="af212-139">この場合、Shor の有名なクォンタムのファクタリングアルゴリズムを使用して、要因を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="af212-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="af212-140">このアルゴリズムは Q # で表され、クォンタム操作のシーケンスは、エラーを発生させることのできないクォンタムコンピューターで実行できる出力です。</span><span class="sxs-lookup"><span data-stu-id="af212-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="af212-141">物理ゲート</span><span class="sxs-lookup"><span data-stu-id="af212-141">Physical gates</span></span>
<span data-ttu-id="af212-142">この例では、次のステップが Q # によって生成された操作を実行し、物理ゲートに対して選択された、クォンタムエラー修正方法によって指定されたテンプレートを使用してそれを変換します。基本的なハードウェアを実行できます。</span><span class="sxs-lookup"><span data-stu-id="af212-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="af212-143">このプロセスでは、前のモデルで説明されているすべての論理 qubit を、単一の qubit 内の情報を格納および保護するために使用される物理 qubit のホストと置き換えます。このようなエラーを検出して修正するのに十分な長さの qubits。</span><span class="sxs-lookup"><span data-stu-id="af212-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="af212-144">Q # コードで記述された論理 qubits を多くの物理 qubits に置き換える必要があるのと同様に、出力に記述されている各クォンタムゲートは、物理的な qubits に作用する一連の物理ゲートに変換される必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="af212-145">このため、Q # の出力はクォンタムコンピューティングの最終目標ではめったにありません。また、無関係方式でハードウェアでコードを実行するには、さらに抽象化のレベルが必要になります。</span><span class="sxs-lookup"><span data-stu-id="af212-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="af212-146">コンピューターの制御</span><span class="sxs-lookup"><span data-stu-id="af212-146">Control computer</span></span>
<span data-ttu-id="af212-147">次に、物理ゲートシーケンスが通常のコンピューターに読み込まれます。このコンピューターは、この命令を、クォンタムコンピューターに直接インターフェイスするコントロールコンピューターに送信します。</span><span class="sxs-lookup"><span data-stu-id="af212-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="af212-148">ソフトウェアスタック内のこの層は、多くの場合、 [Qcodes](http://qcodes.github.io/Qcodes/)などの試験的な制御ソフトウェアによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="af212-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="af212-149">インターフェイスコンピューター</span><span class="sxs-lookup"><span data-stu-id="af212-149">Interface computer</span></span>
<span data-ttu-id="af212-150">このプロセスの最後の手順では、インターフェイスコンピューターで、必要に応じて、まずゲートを高速制御コンピューターにストリーミングします。</span><span class="sxs-lookup"><span data-stu-id="af212-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="af212-151">次に、必要なゲートを qubits に実装するために必要な (通常はパルスと呼ばれる) 電圧を適用します。</span><span class="sxs-lookup"><span data-stu-id="af212-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="af212-152">これは、クォンタムエラーの修正によって発生したエラーを修正するときに行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="af212-153">この手順は、quantum コンピューターにエラーが表示される速度によって定められた厳しい時間の要件内で実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af212-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="af212-154">多くの場合、このレベルのターゲット言語は[VHDL](https://en.wikipedia.org/wiki/VHDL)であり、スタックの一番上の端で使用され、クォンタムアルゴリズムの説明を解析するための別の方法を必要とします。</span><span class="sxs-lookup"><span data-stu-id="af212-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="af212-155">Q # クォンタムプログラミング言語</span><span class="sxs-lookup"><span data-stu-id="af212-155">The Q# quantum programming language</span></span>
<span data-ttu-id="af212-156">Q # の目的は、開発者が、さまざまなクォンタムコンピューティングプラットフォームを対象としたコードを作成し、ユーザーと quantum デバイスとの間に介在するソフトウェアの介在する層とのインターフェイスを作成できるようにするための簡単な言語を提供することです。</span><span class="sxs-lookup"><span data-stu-id="af212-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="af212-157">この言語を使用すると、ソフトウェアスタックの概念を取り入れ、基になるクォンタムコンピューターの詳細の多くを抽象化しながら、などC#の言語を通じて公開される他のレベルのスタックを許可して、必要な操作を実行できます。Q # コードから基本的な操作への翻訳。</span><span class="sxs-lookup"><span data-stu-id="af212-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="af212-158">これにより、開発者はアルゴリズムを設計し、問題を解決するのに最適な方法に専念できます。</span><span class="sxs-lookup"><span data-stu-id="af212-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
