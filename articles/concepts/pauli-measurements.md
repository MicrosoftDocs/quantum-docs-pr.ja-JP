---
title: P# li 測定 |Microsoft Docs
description: P# li 測定
author: QuantumWriter
uid: microsoft.quantum.concepts.pauli
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 7bea821be7e26e72f2860278486d35be676ca63d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183711"
---
# <a name="pauli-measurements"></a>P# li 測定

前のディスカッションでは、計算ベースの測定に重点を置いてきました。  実際、クォンタムコンピューティングでは、数値表記の観点から、計算ベースの測定値を表すのに便利な他の一般的な測定値があります。  これらの測定値のうち最も一般的なものは、*測定値*です。  このような場合、一般的には、Pforce Li 演算子の測定について説明します。一般的には、$X、Y、Z $、$Z/otimes Z、xo times X、xotimes Y $ などの演算子です。  P# li 演算子の観点から、メジャーについて説明することは、クォンタムエラー修正のサブフィールドで特に一般的です。 Q # では、同様の規則に従います。ここでは、この測定の別のビューについて説明します。

P# li 測定を考える方法の詳細について検討する前に、クォンタムコンピューター内の1つの qubit がクォンタムの状態にどのように測定されるかについて考えることをお勧めします。  $N $-qubit クォンタムの状態になっているとします。次に、1つの qubit をすぐに測定して、その状態がである可能性がある $ 2 ^ n $ の可能性の半分を除外します。  つまり、測定値は、2つの半分の空白のいずれかにクォンタムの状態を投影します。  このことを反映するために、測定に対して考えられる方法を汎用化できます。

これらのサブスペースを簡潔に識別するためには、それらを説明するための言語が必要です。  これを行う1つの方法として、2つの特殊な値を指定して2つのサブスペースを記述します。これは、規約によって $ pm $1 として取得されます。  最も簡単な例を次に示します。

$ $ Z = \begin{bmatrix} 1 & 0 \\\\ 0 &-1 \end{bmatrix}.
$$

$Z p固有ベクトル $ マトリックスには、明らかに2つの $ \ket{0}$ と $ \ket{1}$ が含まれています。固有値 $ \ pm $1 です。  したがって、qubit を測定して $ \ket{0}$ を取得した場合、演算子の $ + $1 eig固有ベクトル (正または負の値のみを持つの合計で構成されるすべてのベクトルのセット) に格納されます。 $ \ket{1}$ を測定すると、$-$1 ei になります。$Z $ の genspace。  このプロセスは、"p# li $Z を測定する" という言語では、計算ベースの測定を実行するのとまったく同じです。

もちろん、$ 2 \ times $2 行列は $Z $ のユニタリ変換であり、この条件も満たしています。  これは、マトリックス $A = U ^ 固有ベクトル Z U $ を考慮することもできます。これは、すべての $U を、$ pm $1 の測定の2つの結果を定義するマトリックスを提供するために使用されます。  Preferences Li 測定の表記法では、$X、Y、Z $ の測定値を同等の測定値として識別することによって、qubit から情報を取得することができます。  これらの測定値は、便宜上、次のように提供されます。

$ $ & begin{array{2} {| c | c |} \ text{p# li 測定} & U\\\\ Z &/done\\\\ X & H\\\\ Y & HS ^ \ ダガー\\\\ \ end{array} $ $

つまり、この言語を使用すると、"measure $Y $" は $HS ^ \ ダガー $ を適用し、計算単位で測定することと同じです。 $S $ は、によって指定されるいわゆるフェーズゲートです。

$ $ \begin{bmatrix}1 & 0\\\\ 0 & i \ end {bmatrix}。
$$

また、クォンタム状態ベクターに $HS ^ \ ダガー $ を適用し、$Z $ を測定することと同じです。  次に、適切な状態は、計算ベースに変換することによって検出されます。これは、$SH $ をクォンタム状態ベクターに適用するための量です。

## <a name="q-outcome-classical-information-obtained-from-quantum-state"></a>Q # クォンタム状態から取得された古典情報
Q # では、結果を言いました。つまり、州との対話から抽出された古典情報は $ $j $\{0, 1\}$ になります。結果が、測定された $ (-1) ^ j $ eigenspace に含まれている場合に発生します。

次に示すように、マルチ qubit の演算子の測定値は同様に定義されています。

$ $ Zotimes Z = \begin{bmatrix}1 & 0 & 0 & 0\\\\ 0 &-1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 & 1 \ 終了 {bmatrix}。
$$

したがって、2つの $Z $ 演算子の3つの製品は、$ + $1 と $-$1 eigenvalues で構成される2つのスペースで構成されるマトリックスを形成します。  シングル qubit の場合と同様に、両方とも、アクセス可能なベクター空間の半分が $ + $1 eigspace に属し、残りの半分が $-$1 の範囲に属していることを意味します。  一般に、$Z $ 演算子と id のすべての操作については、この後も同様に、その製品の定義から簡単に確認できます。  たとえば、次のように入力します。

$ $ Z\begin{bmatrix} = 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 &-1 \ 終了 {bmatrix}。
$$

前と同様に、このようなマトリックスのすべてのユニタリ変換では、$ pm $1 eigenvalues でラベル付けされた2つの半分の空白も記述します。  たとえば、$Z = HXH $ の場合は、id から (zotimes Z) hotimes h $ を $X します (& o)。  1 qubit の場合と同様に、2つの2つのすべての値は、$U ^-ダガー (zotimes \ id) U $ for $ 4 \ times $4 $U $ として書き込むことができます。  次の表に示す変換は、qubits $0 $ と $1 $: $ & {01}\_をスワップするスワップゲートを使用して列挙されています。 (& a) {10}/演算子 name{cnot}\_/演算子 name{CNOT}\_{01}$:

$ $ & begin{array{2} {| c | c |} \ text{p#} & U\\\\/hline zotimes/bold の実行 & otimes/\\ の実行を\\して、{times > & を実行しました。 {/otimes/bold の実行が完了しました。 \\\\otimes/bold 完了\\\\ とその逆の処理を実行します。 Z & を実行します。または、& lt; {swap}\\\\ を実行します。-otimes X & (hotimes-bold done) \ オペレーター名 {swap}\\\\/完了します。オペレーター名 {SWAP}\\\\ zotimes Z &。\_{10}\\\\ X\otimes Z &-演算子名 {cnot}\_{10}(H-otimes-bold done)\\\\ yotimes Z & \ します。オペレーター名 {CNOT}\_{10}(HS ^/dagger\ otimes \ bold 完了)\\\\ zotimes X & \ 演算子名 {cnot}\_{10}(\ bold one/otimes H)\\\\ xotimes X & \ オペレーター名 {cnot}\_@no__t31_ (hotimes H)\\\\ yotimes X &。\_{10}(HS ^/daggero times H)\\\\ zotimes Y & \ 演算子の\_(& a) {10}\\(& a) @no__t_ (& a) (& a)41_ xotimes Y & \ オペレーター名 {cnot}\_{10}(H/otimes HS ^ \ ダガー)\\\\ yotimes Y &-オペレーター名 {cnot}\_{10}(HS ^-dagger/otimes HS ^ \ ダガー)\\\\ \ end{array} $ $

ここでは、次の理由で、$ &\_{10}$ というゲートが表示されます。  $-Bold 完了 $ matrix を含まない各 P# li の測定値は、上記の理由によって Z $ を $Z するための最大値と同じです。  $Z/otimes Z $ の固有値は、各計算ベースのベクトルを構成する qubits のパリティに依存します。この一覧に表示される制御されていない演算は、このパリティを計算して最初のビットに格納するために提供されます。  その後、最初のビットを測定した後、結果として得られる半分の領域の id を復旧できます。これは、P# li 演算子を測定するのと同じです。

1つ追加の注意点として、$Z/otimes Z $ が測定 $Z の測定と同じであることを想定している可能性があります (& o)-id $、$ id/otimes Z $、この想定は false になります。  その理由は、Z $ $Z 測定すると、これらの演算子の $ + $1 または $-$1 eigenstate にクォンタムの状態が射影されます。  $Z-otimes \ id $ を測定してから $-id & otimes Z $ を計測すると、クォンタムの状態ベクターはまず、$Z の半分の時刻 \ id $ に射影され、その後、$ \ id/otimes Z $ という半分の領域になります。  計算ベースのベクトルが4つあるため、両方の測定を実行すると、状態が4分の1に減少し、1つの計算ベースのベクトルに縮小されます。


## <a name="correlations-between-qubits"></a>Qubits 間の相関関係
$X/otimes X $ や $Z/otimes Z $ など、Paulis の保存されていない製品を測定する別の方法として、これらの測定値を使用すると、2つの qubits 間の相関関係に格納されている情報を確認できます。  $X-otimes \ id $ を測定すると、最初の qubit にローカルに格納されている情報を確認できます。  クォンタムコンピューティングではどちらの種類の測定も同等の価値がありますが、前者はクォンタムコンピューティングの能力を測定します。 多くの場合、量子コンピューティングでは、学習したい情報が1つの qubit に格納されておらず、すべての qubit にローカルに格納されていないことがわかります。また、この情報は、$Z/otimes Z $ によって表示されます。マニフェスト.

$X/otimes (Z/otimes) などの任意の Pforce 演算子を測定することもできます。  P# li 演算子のすべてのその他の製品には、2つの固有値 $ pm $1 しかありません。固有値は、ベクター空間全体の半分のスペースを構成します。  そのため、これらは上記の要件と一致します。

Q # では、このような測定値により $ (-1) ^ j $ という符号の結果が生成された場合、$ $j が返されます。  これを Q # の組み込み機能として利用すると便利です。このような演算子を測定するには、制御されていないゲート型のチェーンと基本変換の長いチェーンが必要であるため、操作を $Z $ と $ id $ の diagonalizing として表現するために必要な $U $ gate を記述します。  これらの事前定義された測定値のいずれかを実行することを指定できるだけで、計算ベースの測定によって必要な情報が得られるように、その基準を変換する方法について心配する必要はありません。  Q # は、必要なすべての基準変換を自動的に処理します。 [P# li 測定については、「Q # ライブラリリファレンス」を](/qsharp/api/canon/microsoft.quantum.canon.measurepaulis)参照してください。

## <a name="the-no-cloning-theorem"></a>複製なしの定理
クォンタム情報は強力です。  これにより、最もよく知られている古典アルゴリズムよりも指数関数的に数値を指数関数的に処理できるようにすることが可能になります。また、正確にシミュレートするためにクラシックデプロイに必要な、関連する電子システムを効率的にシミュレートできます。  ただし、クォンタムコンピューティングの能力には制限があります。  このような制限は、*複製なしの定理*によって与えられます。

No 複製定理は、このという名前です。
クォンタムコンピューターによる汎用クォンタム状態の複製は禁止されています。
定理の証明は、非常に簡単です。
複製なしの定理の完全な証明は、ここで説明するための技術的なものではありませんが、問題のクォンタムコンピューターに追加の ancilla qubits がない場合の定理の証拠は、そのスコープ内にあります (ancilla qubits はゼロに使用されます)。計算中にスペースを使い、Q # で簡単に使用および管理できます。「<xref:microsoft.quantum.techniques.qubits>)」を参照してください。
このようなクォンタムコンピューターでは、複製操作は、ユニタリ行列である必要があります。 複製しようとしているクォンタムの状態が破損する可能性があるため、測定は禁止されています。 必要なユニタリ行列には、$ $ U \ket{\psi} \ket{0} = \ket{\psi} \ket{\psi}, $ $ (任意の状態 $ \ket{\psi} $) のプロパティが含まれている必要があります。
マトリックス乗算の直線性プロパティは、2つ目のクォンタム状態 $ \ket{\phi} $ であることを意味します。

\begin{align} & U-left [\ frac{1}{\ sqrt{2}} \ left (\ket{\phi} + \ket{\psi}-right) () \ket{0}= \ frac{1}{\ sqrt{2}} U\ket {\ phi} \ k{0}+/frac{1}{/sqrt{2}} U\ket {\ psi} \ k{0}\\\\ & \qquad\qquad = \ frac{1}{\ sqrt{2}} \ left (\ket{\phi}\ket{\phi} + \ket{\psi}\ket{\psi}\right)\\\\ & \qquad\qquad\ne/left (-frac{1}{/sqrt{2}} \ left (\ket{\phi} + \ket{\psi} \right)-left (\ frac{1}{\ sqrt{2}} \ left (\ket{\phi} + \ket{\psi})/right) を右に押します。
\end{align}

これにより、複製されていない定理の背後で基本的な直感が得られます。不明なクォンタム状態をコピーするデバイスは、少なくともそのコピーされた状態の中でエラーを誘発する必要があります。  Cloner が入力状態で直線的に動作することを前提として、ancilla と ancilla qubits の測定値を加算することによって違反が発生する可能性がありますが、このような対話によって、測定統計を通じてシステムに関する情報が漏洩し、このような場合は、正確な複製も同様です。  複製なしの定理の詳細については、「」[を](xref:microsoft.quantum.more-information)参照してください。

クォンタムの状態を複製できる場合は、クォンタムの状態についての理解を深めることができるので、定理の複製は、クォンタムの計算にとって重要です。  実際には、ハイゼンベルグの vaunted の不確定性の原則に違反する可能性があります。  または、最適な cloner を使用して、複雑なクォンタム分布から1つのサンプルを取得し、1つのサンプルだけからその分布について学習できる可能性のあるすべてのことを学ぶこともできます。  これは、コインと観察ヘッドを反転し、その結果について友人に伝えたときに、そのコインの分布が $p = 0.512643 \ ldots $! でベルヌーイでなければならないということです。  このようなステートメントは非 sensical になります。これは、1つの情報 (ヘッドの結果) は、十分な前の情報を使用せずに、分布をエンコードするために必要な多くの情報を提供できないためです。  同様に、以前の情報がないと、$p $ を知らなくても、このようなコインを完全に複製することはできません。

クォンタムコンピューティングでは、情報は無料です。  測定された各 qubit は1ビットの情報を提供し、複製なしの定理は、システムに関する情報とそれに対して発生した問題の基本的なトレードオフを回避するために、攻撃を受ける可能性があるバックドアがないことを示しています。

