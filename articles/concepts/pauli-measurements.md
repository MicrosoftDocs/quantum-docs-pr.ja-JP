---
title: P# li 測定
description: P# li 測定
author: QuantumWriter
uid: microsoft.quantum.concepts.pauli
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 0a3ee595022ec389ecadcab081ccd126cb3252ae
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/29/2020
ms.locfileid: "76819911"
---
# <a name="pauli-measurements"></a>P# li 測定

前のディスカッションでは、計算ベースの測定に重点を置いてきました。
実際には、数値表記の観点からは、コンピューティングベースの測定を表すのに便利な、クォンタムコンピューティングで発生する一般的な測定値があります。
Q # を操作するときに実行する最も一般的な種類の測定は、通常、測定値として使用されます。この*測定*では、計算ベースの測定値を汎用化して、他のベースの測定値と異なる qubits 間のパリティを含めます。
このような場合、一般的には、Pforce Li 演算子の測定について説明します。一般的には、$X、Y、Z $、$Z/otimes Z、xo times X、xotimes Y $ などの演算子です。

> [!TIP]
> Q # では、通常、マルチ qubit の演算子は `Pauli[]`型の配列によって表されます。
> たとえば、$X & otimes Z/otimes Y $ を表すには、配列 `[PauliX, PauliZ, PauliY]`を使用できます。

P# li 演算子の観点から、メジャーについて説明することは、クォンタムエラー修正のサブフィールドで特に一般的です。
Q # では、同様の規則に従います。ここでは、この測定の別のビューについて説明します。

P# li 測定を考える方法の詳細について検討する前に、クォンタムコンピューター内の1つの qubit がクォンタムの状態にどのように測定されるかについて考えることをお勧めします。
$N $-qubit クォンタムの状態になっているとします。次に、1つの qubit をすぐに測定して、その状態がである可能性がある $ 2 ^ n $ の可能性の半分を除外します。
つまり、測定値は、2つの半分の空白のいずれかにクォンタムの状態を投影します。
この直感を反映するために、測定について考える方法を一般化できます。

これらのサブスペースを簡潔に識別するためには、それらを説明するための言語が必要です。
2つのサブスペースを記述する方法の1つとして、2つの一意の値を持つマトリックスを通じて指定する方法があります。これは、規約によって $ pm $1 として取得されます。
この方法でサブスペースを記述する簡単な例については、$Z $:

$ $ \begin{align} Z & = \begin{bmatrix} 1 & 0 \\\\ 0 &-1 \end{bmatrix}.
\end{align} $ $

$Z p固有ベクトル $ マトリックスの対角線要素を読み取ることで、$ \ket{0}$ と $ \ket{1}$ という2つのがある $Z ことを確認できます。対応する固有値 $ $1 があります。
このため、qubit を測定して `Zero` (状態 $ \ket{0}$ に対応) を取得した場合、qubit の状態は $Z $ 演算子の $ + $1 eigenstate であることがわかります。
同様に、`One`を取得した場合は、qubit の状態が $Z $ の $-$1 eigenstate であることがわかります。
このプロセスは、"P# li $Z $" の測定値として、P# li 測定の言語で参照されます。これは、計算ベースの測定を実行することとまったく同じです。

$ 2 \ times $2 マトリックスは、$Z $ のユニタリ変換でもあり、この条件を満たしています。
つまり、マトリックス $A = U ^-ダガー Z U $ を使用することもできます。ここで、$ は、$ pm $1 固有ベクトルの測定の2つの結果を定義するマトリックスを提供するために、$U $ はその他の任意の長さの行列になります。
Preferences Li 測定の表記は、$X、Y、Z $ の測定値を等価の測定値として識別することによって、このような値を参照します。
これらの測定値は、便宜上、次のように提供されます。


|P# li 測定  |ユニタリ変換  |
|-------------------|------------------------|
| $Z $               | $ \ bold 完了 $             |
| $X $               | $H $                    |
| $Y $               | $HS ^ {\ dagger} $         |

つまり、この言語を使用すると、"measure $Y $" は $HS ^ \ ダガー $ を適用し、計算の単位で測定することと同じです。 [`S`](xref:microsoft.quantum.intrinsic.s)は "フェーズゲート" と呼ばれる組み込みのクォンタム操作であり、これは、長さの行列でシミュレートできます。

$ $ \begin{align} S = \begin{bmatrix} 1 & 0 \\\\ 0 & i \end{bmatrix}.
\end{align} $ $

また、クォンタム状態ベクターに $HS ^-ダガー $ を適用し、次の演算が `Measure([PauliY], [q]])`と同じになるように $Z $ を測定することと同じです。

```Q#
operation MeasureY(qubit : Qubit) : Result {
    mutable result = Zero;
    within {
        H(q);
        Adjoint S(q);
    } apply {
        set result = M(q);
    }
    return result;
}
```

次に、適切な状態は、計算ベースに変換することによって検出されます。これは、$SH $ をクォンタム状態ベクターに適用する量です。上記のスニペットでは、計算ベースに戻る変換は、`within … apply` ブロックを使用して自動的に処理されます。

Q # では、結果と---して、州---との対話から抽出された古典的な情報が `Result` の値によって与えられます。これは、結果が測定された $ (-1) ^ j $ eigenspace 内にあるかどうかを示す、\\{\texttt{Zero}, \texttt{One}\\} $ に $j ます。


## <a name="multiple-qubit-measurements"></a>複数の qubit 測定値

次に示すように、マルチ qubit の演算子の測定値は同様に定義されています。

$ $ Zotimes Z = \begin{bmatrix}1 & 0 & 0 & 0\\\\ 0 &-1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 & 1 \ 終了 {bmatrix}。
$$

したがって、2つの $Z $ 演算子の3つの製品は、$ + $1 と $-$1 eigenvalues で構成される2つのスペースで構成されるマトリックスを形成します。
シングル qubit の場合と同様に、両方とも、アクセス可能なベクター空間の半分が $ + $1 eigspace に属し、残りの半分が $-$1 の範囲に属していることを意味します。
一般に、$Z $ 演算子と id のすべての操作については、この後も同様に、その製品の定義から簡単に確認できます。
たとえば、次のように入力します。

$ $ \begin{align} Z/\begin{bmatrix} done = 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 &-1 & 0 \\\\ 0 & 0 & 0 &-1 \end{bmatrix}.
\end{align} $ $

前と同様に、このようなマトリックスのすべてのユニタリ変換では、$ pm $1 eigenvalues でラベル付けされた2つの半分の空白も記述します。
たとえば、$Z = HXH $ の場合は、id から (zotimes Z) hotimes h $ を $X します (& o)。
1 qubit の場合と同様に、2つの2つのすべての値は、$U ^-ダガー (zotimes \ id) U $ for $ 4 \ times $4 $U $ として書き込むことができます。 次の表に示す変換を列挙します。

> [!NOTE]
> 次の表で、$ \begin{matrix} を使用して、$ $ \begin{align}/name{swap} & = \ left (1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \end{matrix}\right) \end{align} $ $ を使用して組み込み操作をシミュレートしています。 [\\](xref:microsoft.quantum.intrinsic)。

|P# li 測定     |ユニタリ変換  |
|----------------------|------------------------|
| $Z/操作完了 $ | $ > その他の作業は完了しました。 $ |
| $Z/操作完了 $ | $ (& a) bold {/otimes \ bold 完了 $ |
| $X/操作完了 $ | $H/操作完了 $ |
| $Y/操作完了 $ | $HS ^ & dagger{times \ bold 完了 $ |
| $/bold Z $ | $ \ 演算子名 {swap} $ |
| $/bold (& a) @ times X $ | $ (Hotimes-bold 完了) \ オペレーター名 {swap} $ |
| $/bold * Y $ | $ (HS ^/dagger\ otimes-bold 完了) \ オペレーター名 {swap} $ |
| $Z/otimes Z $ | $ \ オペレーター名 {cnot}\_{10}$ |
| $X/otimes Z $ | $ \ オペレーター名 {cnot}\_{10}(hotimes/bold done) $ |
| $Y/otimes Z $ | $ \ オペレーター名 {cnot}\_{10}(HS ^ & daggero times \ bold) $ |
| $Z/otimes X $ | $ \ オペレーター名 {cnot}\_{10}(\ bold oneotimes H) $ |
| $X/otimes X $ | $ \ オペレーター名 {cnot}\_{10}(hotimes H) $ |
| $Y/otimes X $ | $ \ オペレーター名 {cnot}\_{10}(HS ^ & daggerotimes H) $ |
| $Z/otimes Y $ | $ \ オペレーター名 {cnot}\_{10}(\ (& a) {times HS ^ \ ダガー) $ |
| $X/otimes Y $ | $ \ オペレーター名 {cnot}\_{10}(hotimes HS ^ \ ダガー) $ |
| $Y/otimes Y $ | $ \ オペレーター名 {cnot}\_{10}(HS ^ & daggerotimes HS ^ \ ダガー) $ |

ここでは、 [`CNOT`](xref:microsoft.quantum.intrinsic.cnot)操作は次の理由で表示されます。
$-Bold 完了 $ matrix を含まない各 P# li の測定値は、上記の理由によって Z $ を $Z するための最大値と同じです。
$Z/otimes Z $ の固有値は、各計算ベースのベクトルを構成する qubits のパリティに依存しています。また、制御されていない操作は、このパリティを計算して最初のビットに格納するために機能します。
次に、最初のビットを測定した後、結果として得られる半分の領域の id を回復できます。これは、P# li 演算子の測定に相当します。

追加の注意点として、$Z/otimes Z $ が連続して $Z 測定されていることを想定していることもあります。これは、\mathbb{1}$ と $ \mathbb{1}/otimes Z $ の順に測定した場合、この想定は false になります。
その理由は、Z $ $Z 測定すると、これらの演算子の $ + $1 または $-$1 eigenstate にクォンタムの状態が射影されます。
\Mathbb{1}$ を測定してから $ \mathbb{1} & otimes Z $ を $Z 計測すると、最初にクォンタムの状態ベクターを $Z の半分の空白に射影してから、$ \mathbb{1}/otimes Z $ の半分の領域に \mathbb します。
計算ベースのベクトルが4つあるため、両方の測定を実行すると、状態が4分の1に減少し、1つの計算ベースのベクトルに縮小されます。

## <a name="correlations-between-qubits"></a>Qubits 間の相関関係
$X/otimes X $ や $Z/otimes Z $ のような、Pforce のマトリックスの保管された製品を測定する別の方法として、これらの測定値を使用すると、2つの qubits 間の相関関係に格納されている情報を確認できます。
$X-otimes \ id $ を測定すると、最初の qubit にローカルに格納されている情報を確認できます。
クォンタムコンピューティングではどちらの種類の測定も同等の価値がありますが、前者はクォンタムコンピューティングの能力を測定します。
多くの場合、クォンタムコンピューティングでは、学習する情報が1つの qubit に格納されておらず、すべての qubit にローカルに格納されていないことがわかります。したがって、これは、結合測定 (たとえば、$Z/otimes Z $) によって行われます。情報はマニフェストになります。

たとえば、エラー修正では、保護しようとしている状態について何も学習していないときに発生したエラーを確認したい場合がよくあります。
[ビットフリップコードサンプル](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code)では、$Z-otimes z/otimes-id $ と $ id & otimes z/otimes z $ のような測定値を使用して、その方法の例を示しています。
<!-- TODO: change this to a link to the samples browser as soon as the bit-flip code sample is on-boarded. -->

$X/otimes (Z/otimes) などの任意の Pforce 演算子を測定することもできます。
P# li 演算子のすべてのその他の製品には、2つの固有値 $ pm $1 しかありません。固有値は、ベクター空間全体の半分のスペースを構成します。
そのため、これらは上記の要件と一致します。

Q # では、このような測定値により $ (-1) ^ j $ という符号の結果が生成された場合、$ $j が返されます。
Q # の組み込み機能として Pdiagonalizing の測定値を持つことは便利です。このような演算子を測定するには、制御されていないゲート型のチェーンと基本変換の長いチェーンが必要であり、その操作を $Z $ と $ id $ のすべての製品として表現するために必要な $U $ gate を記述します
これらの定義済みの測定値のいずれかを実行することを指定できるようにすることで、計算ベースの測定によって必要な情報が得られるように、基になる方法を気にする必要がなくなります。
Q # は、必要なすべての基準変換を自動的に処理します。
詳細については、「 [`Measure`](xref:microsoft.quantum.intrinsic.measure) 」および「 [`MeasurePaulis`](xref:microsoft.quantum.measurement.measurepaulis)操作」を参照してください。

## <a name="the-no-cloning-theorem"></a>複製なしの定理

クォンタム情報は強力です。
これにより、最もよく知られている古典アルゴリズムよりも指数関数的に数値を指数関数的に処理できるようにすることが可能になります。また、正確にシミュレートするためにクラシックデプロイに必要な、関連する電子システムを効率的にシミュレートできます。
ただし、クォンタムコンピューティングの能力には制限があります。
このような制限は、*複製なしの定理*によって与えられます。

No 複製定理は、このという名前です。
クォンタムコンピューターによる汎用クォンタム状態の複製は禁止されています。
定理の証明は、非常に簡単です。
ここでは、複製なしの定理の完全な証明は少し技術的なものではありませんが、追加の補助 qubits がこの範囲内に存在しない場合は、(計算中にスクラッチ領域に使用される補助 qubits は qubits、Q # で簡単に使用および管理されます)、「<xref:microsoft.quantum.techniques.qubits>」を参照してください。

このようなクォンタムコンピューターでは、複製操作は、1つのユニタリ行列によって記述される必要があります。
複製しようとしているクォンタムの状態が破損する可能性があるため、測定は禁止されています。
複製操作をシミュレートするには、' $ $ U \ket{\psi} \ket{0} = \ket{\psi} \ket{\psi} $ $ (任意の状態 $ \ket{\psi} $) のプロパティを持つために使用される、ユニタリ行列が必要です。
マトリックス乗算の直線性プロパティは、2つ目のクォンタム状態 $ \ket{\phi} $ であることを意味します。

$ $ \begin{align}/left [\ frac{1}{\ sqrt{2}} \ left (\ket{\phi} + \ket{\psi} \ right) \ right] \ket{0} & = \ frac{1}{\ sqrt{2}} U\ket {\ phi} \ k{0} +-frac{1}{\ sqrt{2}} U\ket {\ psi} \ k{0} \\\\ & = \ frac{1}{\ sqrt{2}} \ 左 (\ket{\phi} \ket{\phi} + \ket{\psi} \ket{\psi}/right) \\\\ & \n * 左 (-frac{1}{/sqrt{2}} \ 左 (\ket{\phi} + \ket{\psi} \ 右) \ otimes \left (\ frac{1}{\ sqrt{2}} \ left (\ket{\phi} + \ket{\psi}) \ right)。
\end{align} $ $

これにより、複製されていない定理の背後で基本的な直感が得られます。不明なクォンタム状態をコピーするデバイスは、少なくともそのコピーされた状態の中でエラーを誘発する必要があります。
Cloner が入力状態で直線的に動作することを前提として、補助 qubits の加算と測定によって違反が発生する可能性がありますが、このような対話によって、測定統計を通じてシステムに関する情報が漏洩し、正確に防ぐことができます。このような場合にも複製します。
複製なしの定理の詳細については、「」[を](xref:microsoft.quantum.more-information)参照してください。

クォンタムの状態を複製できる場合は、クォンタムの状態についての理解を深めることができるので、定理の複製は、クォンタムの計算にとって重要です。
実際には、ハイゼンベルグの vaunted の不確定性の原則に違反する可能性があります。
または、最適な cloner を使用して、複雑なクォンタム分布から1つのサンプルを取得し、1つのサンプルだけからその分布について学習できる可能性のあるすべてのことを学ぶこともできます。
これは、コインと観察ヘッドを反転し、その結果について友人に伝えたときに、そのコインの分布が $p = 0.512643 \ ldots $! でベルヌーイでなければならないということです。  このようなステートメントは非 sensical になります。これは、1つの情報 (ヘッドの結果) は、十分な前の情報を使用せずに、分布をエンコードするために必要な多くの情報を提供できないためです。
同様に、以前の情報がないと、$p $ を知らなくても、このようなコインを完全に複製することはできません。

クォンタムコンピューティングでは、情報は無料です。
測定された各 qubit は1ビットの情報を提供し、複製なしの定理は、システムに関する情報とそれに対して発生した問題の基本的なトレードオフを回避するために、攻撃を受ける可能性があるバックドアがないことを示しています。
