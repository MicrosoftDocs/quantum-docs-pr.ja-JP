---
title: 'Q # 標準ライブラリ-アルゴリズム |Microsoft Docs'
description: Q# 標準ライブラリ
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 91f65b05c83367c2d2ece93212369dc448d8c2a8
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/29/2020
ms.locfileid: "76821016"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="b3ad3-103">クォンタムアルゴリズム</span><span class="sxs-lookup"><span data-stu-id="b3ad3-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="b3ad3-104">振幅増幅</span><span class="sxs-lookup"><span data-stu-id="b3ad3-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="b3ad3-105">*振幅増幅*は、クォンタムコンピューティングの基本的なツールの1つです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="b3ad3-106">これは、Grover の検索、振幅推定、および多くのクォンタム機械学習アルゴリズムを基盤とする基本的なアイデアです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="b3ad3-107">さまざまなバリエーションがあります。 Q # では、無関係の振幅増幅に基づいて、部分的な反射を持つ一般的なバージョンを提供し、最も広い範囲のアプリケーションを可能にします。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="b3ad3-108">振幅増幅の背後にある中心となる考え方は、一連の反射を行うことによって、目的の結果が発生する確率を増幅することです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="b3ad3-109">これらの反射は、初期状態を目的の状態 (マークされた状態と呼ばれることもあります) の近くに向かって回転させます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="b3ad3-110">具体的には、初期状態がマーク付きの状態になる確率が $ \ sin ^ 2 (-シータ) $ である場合、振幅増幅を適用した後 $m $/sin ^ 2 ((2m + 1) \ シータ) $ になります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="b3ad3-111">これは、$ \ シータ = \ pi/[2 (2n + 1)] $ $n の値がある場合に $ を使用すると、振幅増幅の $n $ 反復の後、$100\\% $ に成功する確率を上げることができることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="b3ad3-112">$ \ シータ = \ sin ^{-1}(\ sqrt{/Pr (success)}) $ であるため、成功を取得するために必要なイテレーションの数は、ランダムサンプリングを使用して、無作為に指定された状態を検出するために必要な数よりも quadratically 低くなります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="b3ad3-113">振幅増幅の各反復処理では、2つのリフレクション演算子が指定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="b3ad3-114">具体的には、$Q $ が振幅増幅で反復処理され、$P 0 $ がプロジェクターの最初のサブ空間にあり、$P _1 $ がプロジェクターのマークされたサブ $Q 空間にある場合は、=-(\ bold one-2P_0) (\ bold 完了-2P_1) $ となります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="b3ad3-115">プロジェクターは Hermitian 演算子であり、固有値 $ + $1 および $0 $ があることを思い出してください。 $ () $ は、unity (この場合は $ pm $1) のルートである固有値を持つため、その結果として $ (\ bold 完了-2P_0) $ になります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="b3ad3-116">例として、初期状態 $H ^ {\ otimes n} \ket{0}$ とマークされた状態 $ \ket{m} $、$P (0 = H ^ {/otimes n} \ket{0}\bra{0}H ^ {/otimes n} $、および $P _1 = \ket{m}\bra{m} $ という形式の Grover の検索を使用する場合を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="b3ad3-117">ほとんどのアプリケーションでは、$P 0 $ はプロジェクターの初期状態になります。これは、一部の vector $ \ket{\psi} $; に対して $P 0 = k {\ psi} $ が設定されていることを意味します。ただし、無関係振幅 $P amplication では、通常、0 $ は多くのクォンタム状態に投影されます (つまり、$ + $1 eigenvalue of $P 0 $ の複数要素の接続性は $1 $ を超えています)。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="b3ad3-118">振幅増幅の背後にあるロジックは、$Q $ の eigen 分解から直接たどります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="b3ad3-119">具体的には、初期状態がゼロ以外のサポートを持つ $Q $ の固有ベクトルは、$P 0 $ と $P _1 $ の $ + $1 固有ベクトルの線形組み合わせとして表示できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="b3ad3-120">具体的には、振幅増幅の初期状態 ($P ($ + $1 eigenvector) であることを前提として、$ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \ left (e ^ {i\ シータ} \ k {\ psi_ +} + e ^ {-ik} \ {\ psi_-} \ right) として書き込むことができます。 $ $ where $ \ket{\ psi_ \ pm} $ は $Q $ と固有値 $e ^ {/pm 2i \ シータ} $ で、$ + $1 固有ベクトル (0 $ および $P _1 $) でのみサポートされています。 $P</span><span class="sxs-lookup"><span data-stu-id="b3ad3-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="b3ad3-121">固有値が $e ^ {\ pm i > $ の場合、演算子 $Q $ は、2つのプロジェクターによって指定された2次元のサブ空間で回転を実行し、回転角度が $ 2 \ シータ $ である初期状態を意味します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="b3ad3-122">このため、$ iteration $m $ iteration $Q $ の成功確率は $ \ sin ^ 2 ([2m + 1] \ シータ) $ です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="b3ad3-123">このようなもう1つの便利なプロパティとして、eigenvalue $/シータ $ は、初期状態がマークされる確率に直接関係しています ($P 0 $ がプロジェクターを初期状態にする場合)。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="b3ad3-124">$Q $ の eigenphases は $ 2 \ シータ = 2 \ sin ^{-1}(\ sqrt{\ Pr (success)}) $ であるため、$Q $ にフェーズ推定を適用すると、その結果として、次のような処理が行われます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="b3ad3-125">これは、それ以外の場合に必要な成功の確率を知るために、クォンタムプロシージャの quadratically を減らす必要があるため便利です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="b3ad3-126">Q # では、無関係の振幅増幅の特殊化として振幅増幅が導入されています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="b3ad3-127">無関係の振幅増幅は、初期状態でプロジェクターを使用する必要がないため、このモニカーを獲得します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="b3ad3-128">この意味では、プロトコルは初期状態に無関係ます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="b3ad3-129">無関係の振幅増幅の重要なアプリケーションは、初期状態が不明であるものの、シミュレーションプロトコルで ancilla レジスタを使用してありになる、ユニタリ Hamiltonian シミュレーションメソッド*の線形組み合わせ*です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="b3ad3-130">この ancilla register が固定値 ($0 $ など) として測定された場合、このシミュレーションメソッドは、必要なユニタリ変換を残りの qubits (システムレジスタと呼びます) に適用します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="b3ad3-131">それ以外のすべての測定結果は失敗につながります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="b3ad3-132">無関係の振幅増幅を使用すると、この測定値が成功する確率を\\$100% $ に上げることができます。これについては、前述のようにしてください。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="b3ad3-133">さらに、通常の振幅増幅は、システムレジスタが空の場合に相当します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="b3ad3-134">このため、Q # は無関係の振幅増幅を基本的な振幅増幅のサブルーチンとして使用します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="b3ad3-135">一般ルーチン (`AmpAmpObliviousByReflectionPhases`) には、`ancillaRegister` と `systemRegister`を呼び出す2つのレジスタがあります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="b3ad3-136">また、必要な反射に対して2つの oracles も受け入れます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="b3ad3-137">`ReflectionOracle` は `ancillaRegister` でのみ動作し、`ObliviousOracle` は両方のレジスタに共同で作用します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="b3ad3-138">`ancillaRegister` への入力は、最初のリフレクション演算子 $ \ 2P_1 $ の-1 eigenstate に初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="b3ad3-139">通常、oracle はコンピューティングベース $ \ket{0...0} $ で状態を準備します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="b3ad3-140">この実装では、`ancillaRegister` が1つの qubit (`flagQubit`) に含まれており、`stateOracle` とその他の必要な ancillas を制御しています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="b3ad3-141">`stateOracle` は、`flagQubit` が $ \ket{1}$ の場合に適用されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="b3ad3-142">また、`AmpAmpObliviousByOraclePhases`の呼び出しを通じて、反射ではなく、oracles `StateOracle` と `ObliviousOracle` を提供する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="b3ad3-143">前述のように、従来の振幅増幅は、これらのルーチンの特殊なケースにすぎません。 `ObliviousOracle` が id 演算子で、システム qubits (つまり `systemRegister` が空) ではありません。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="b3ad3-144">部分的な反射 (Grover 検索など) のフェーズを取得する場合は、関数 `AmpAmpPhasesStandard` を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="b3ad3-145">Grover のアルゴリズムの実装例については、`DatabaseSearch.qs` を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="b3ad3-146">この記事では、 [G.H. Low, 語](https://arxiv.org/abs/1707.05391)によって説明されているように、単一の qubit 回転フェーズをリフレクション演算子フェーズに関連付けています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="b3ad3-147">使用されている固定ポイントフェーズは、[語、低、および](https://arxiv.org/abs/1409.3305)語の各フェーズと共に、[最低でも](https://arxiv.org/abs/1603.03996)でも詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="b3ad3-148">背景については、[標準の振幅増幅](https://arxiv.org/abs/quant-ph/0005055)から開始し、無関係の[振幅増幅](https://arxiv.org/abs/1312.1414)の概要に進み、最後に[低と語](https://arxiv.org/abs/1610.06546)で示されている一般化を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="b3ad3-149">この領域全体 (Hamiltonian シミュレーションに関連する) のわかりやすい概要が[Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)によって提供されています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="b3ad3-150">クォンタムフーリエ変換</span><span class="sxs-lookup"><span data-stu-id="b3ad3-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="b3ad3-151">フーリエ変換は、古典的な分析の基本ツールであり、クォンタムの計算において非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="b3ad3-152">さらに、 *quantum のフーリエ変換*(qft) の効率が、クォンタムアルゴリズムを設計するときに選択する最初のツールの1つとして、従来のコンピューターで可能なことをはるかに上回ります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="b3ad3-153">QFT のおおよその汎化として、目的のアルゴリズムの精度に対して厳密には必要のない回転を排除することにより、さらなる最適化を可能にする <xref:microsoft.quantum.canon.approximateqft> 操作を提供します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="b3ad3-154">おおよその QFT には、dyadic $Z $ ローテーション操作 <xref:microsoft.quantum.intrinsic.rfrac> および <xref:microsoft.quantum.intrinsic.h> 操作が必要です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="b3ad3-155">入力と出力はビッグエンディアンエンコーディングでエンコードされると想定されます (最下位ビット/qubit は[k 表記](xref:microsoft.quantum.concepts.dirac)と同じです)。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-155">The input and output are assumed to be encoded in big endian encoding (lowest bit/qubit is on the left, same as [ket notation](xref:microsoft.quantum.concepts.dirac)).</span></span>
<span data-ttu-id="b3ad3-156">近似パラメーター $a $ は、$ ローテーション $Z の排除レベルを決定します。つまり、[0. n] $ に $a ます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-156">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="b3ad3-157">この例では、$ $Z $ ローテーション $ 2 \ pi/2 ^ k $ として $k > $ が QFT 回線から削除されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-157">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="b3ad3-158">$K \ log_2 (n) + \ log_2 (1//イプシロン) + $3 であることがわかっています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-158">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="b3ad3-159">$\\| をバインドできます。\ オペレーター名 {qft}-& # {\\|</イプシロン $。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-159">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="b3ad3-160">ここで、$\\| \ cdot\\| $ は演算子の基準です。ここでは、この例では、$ (\ operator name{qft}-\ operator name{qft}-\ operator name{ [% の演算子](xref:microsoft.quantum.concepts.matrix-advanced)) の平方根として使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-160">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="b3ad3-161">算術</span><span class="sxs-lookup"><span data-stu-id="b3ad3-161">Arithmetic</span></span> ##

<span data-ttu-id="b3ad3-162">算術演算が従来のコンピューティングで中心的な役割を果たしているのと同じように、クォンタムコンピューティングにも不可欠があります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-162">Just as arithmetic plays a central role in classical computing, it is also indispensible in quantum computing.</span></span>  <span data-ttu-id="b3ad3-163">Shor のファクタリングアルゴリズム、クォンタムシミュレーションメソッド、および多くの oracular アルゴリズムなどのアルゴリズムは、一貫した算術演算に依存しています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-163">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="b3ad3-164">クォンタムを作成するためのほとんどの方法は、クォンタムを作成することです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-164">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="b3ad3-165">最も単純な追加では、$b $ という従来の入力を受け取り、整数 $ \ket{a} $ を保持するクォンタム状態に値を追加します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-165">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="b3ad3-166">数学的には、追加の追加 (従来の入力 $b $) に対して $-演算子を使用することを意味します。このプロパティは、</span><span class="sxs-lookup"><span data-stu-id="b3ad3-166">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="b3ad3-167">$ $ \ 演算子名 {add} (b) \ket{a} = \ket{a + b}。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-167">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="b3ad3-168">$ $ この基本的な追加回線は、追加の incrementer よりも大きくなります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-168">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="b3ad3-169">$ $ \Operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b} を使用して2つのクォンタム入力を持つ挿入を行うことができます。 $ $ $n $ によって制御されるアプリケーションを使用しています。この形式では、\ket{b} & = \ lambda\_{a\_0} \ left (\ 演算子の場合は、\begin{align} (1) \ right)、ラムダ\_{a\_1}、left (\ オペレーター名 {adders (2) \ 右) \ ラムダ\_{a\_2} \ 左 (\ 演算子 name{adders (4)) \ cドット & ラムダ\_{a\_{n-1}} \ 左 (\オペレーター名 {Add} ({{n-1}}) \ right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a} $n、$ ビット整数 $a $ および $b $ および加算剰余 $ 2 ^ n $。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-169">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="b3ad3-170">$-ラムダ\_x (A) $ という表記では、$ という表記では、操作の制御されたバージョンに $A 対して、コントロールとして qubit $x $ が指定されていることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-170">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="b3ad3-171">同様に、クラシックデプロイに制御された乗算 (Shor のファクタリングアルゴリズムに不可欠なモジュール形式の形式) は、次のように制御される同様の一連の追加を使用して実行できます。 \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \ lambda\_{x\_0} \ left (\ 演算子 name{add} (2 ^ 0 a) \ right) \ ラムダ\_{a\_1} \ 左 (\ 演算子名) {add} (2 ^ 1a) \ right) \ ラムダ\_{a\_2} \ 左 (\ オペレーター名 {add} (2 ^ 2 a) \ 右) \\_{x\_{n-1}} \ left (\ 演算子 name{add} ({2 ^ {n-1}} a) \ right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + ax}。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-171">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="b3ad3-172">\end{align} には、上に示した $ \operatorname{Mult} $ の定義から気付く可能性がある、量子コンピューターに対する乗算のはらみがあります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-172">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="b3ad3-173">加算とは異なり、この回線のクォンタムバージョンは入力の製品を入力レジスタではなく補助レジスタに格納します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-173">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="b3ad3-174">この例では、レジスタは $ $b 値を使用して初期化されますが、通常は値0の保持が開始されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-174">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="b3ad3-175">このことが必要なのは、一般に、一般的な $a $ と $x $ の乗算が逆ではないためです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-175">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="b3ad3-176">すべてのクォンタム操作、測定値の保存は元に戻せるため、乗算を反転させるために十分な情報を保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-176">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="b3ad3-177">このため、結果は別の配列に格納されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-177">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="b3ad3-178">このように、元に戻せない操作の出力を別のレジスタに保存することは、Charlie Bennett 後の "Bennett トリック" と呼ばれ、元に戻すことができ、クォンタムコンピューティングの両方で基本的なツールとなります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-178">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="b3ad3-179">多くのクォンタム回線の追加が提案されており、それぞれが qubits (space) の数と必要なゲート操作の数という点で異なるトレードオフを調べています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-179">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="b3ad3-180">Draper の追加と Beauregard の追加と呼ばれる、2つの高い領域を効率的にすることを確認します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-180">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="b3ad3-181">Draper の後に</span><span class="sxs-lookup"><span data-stu-id="b3ad3-181">Draper Adder</span></span> ###

<span data-ttu-id="b3ad3-182">Draper 追加は、追加を実行するためにクォンタムプロパティを直接呼び出すため、最も洗練されたクォンタムの1つです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-182">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="b3ad3-183">Draper の配置の背後にある洞察は、フーリエ変換を使用してフェーズシフトをビットシフトに変換できることです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-183">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="b3ad3-184">次に、フーリエ変換を適用し、適切なフェーズシフトを適用して、フーリエ変換を元に戻します。これにより、付属を実装できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-184">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="b3ad3-185">提案されている他の多くの追加ファイルとは異なり、Draper 追加は、quantum フーリエ変換を通じて導入されたクォンタム効果を明示的に使用します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-185">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="b3ad3-186">自然な従来の対応するものはありません。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-186">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="b3ad3-187">Draper の割り当ての具体的な手順を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-187">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="b3ad3-188">2つの $n $-bit qubit レジスタに整数が格納されていると仮定します。 $ と $b $ $a すべての $a $ $ $ \operatorname{QFT}\ket{a} = \ frac{1}{-sqrt{2 ^ n}} \ sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="b3ad3-188">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="b3ad3-189">$ $ \Ket{\phi を定義する場合は、$ $\_k (a)} = \ frac{1}{/sqrt{2}} \ left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} 右)、$ $ その後、いくつかの代数の後に、$ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)}/otimes/cドット/otimes \ket{\phi\_n (a)} と表示されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-189">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="b3ad3-190">$ $ は、入力の合計を $ $ \ket{a + b}{-1}=\_\ket{\phi (a + b)}/otimes/cドット/otimes \ket{\phi\_n (a + b)} として書き込むことができることを観察した後に、クリアテキストになります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-190">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="b3ad3-191">$ $ $B $ と $a $ の整数を加算するには、$b $ としてのビットを使用して、分解の各 qubits に対して制御フェーズのローテーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-191">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="b3ad3-192">この拡張は、任意の整数 $j $ と実数 $x $、$e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $ に対してさらに簡略化できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-192">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="b3ad3-193">これは、円で $ 360 ^ {\circ} $ 度 ($ 2 \ pi $ ラジアン) を回転させると、開始位置が正確になるためです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-193">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="b3ad3-194">このため、$x $ for $e ^ {i2\pi x} $ の唯一の重要な部分は $x $ の小数部分です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-194">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="b3ad3-195">具体的には、$x = y +0\_0x\_2 \ ldots x\_n $、$e ^ {i2\pi x} = e ^ {i2\pi (0 という形式のバイナリ展開があるとします。 x\_0x\_2 \ ldots x\_{n-1})} $。したがって、$ $ \ket{\phi\_k (a + b)} = \ frac{1}{\ sqrt{2}} \ left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0\_k\ ldots b\_1]} \ket{1} 右)。 $ $ これは、各を増分して追加を実行すると、$ \ket{a} $ のフーリエ変換を拡大すると、回転数が $ 減少 $k に縮小されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-195">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="b3ad3-196">これにより、増加に必要なクォンタムゲートの数が大幅に削減されます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-196">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="b3ad3-197">ここでは、フーリエ変換、フェーズの追加、および逆フーリエ変換のステップを示しています。これは、$ Draper の追加を構成します。この手順では、$-の{-1} 演算子として、$-(\ phi\\\!。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-197">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="b3ad3-198">この単純化を使用してプロセス全体を実装するクォンタム回線は、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-198">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![サーキットダイアグラムとして表示される Draper の表示](~/media/draper.png)

<span data-ttu-id="b3ad3-200">回線の制御された $e ^ {i2 \ pi/k} $ ゲートはそれぞれ、制御されたフェーズゲートを参照します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-200">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="b3ad3-201">このようなゲートには、それらが動作する qubits のペアに対するプロパティがあります。このプロパティは、$ \ket{00}\ket{00}$ ではなく、$ \ket{11}-map@ \ k{11}$ です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-201">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="b3ad3-202">この回線では、入力と出力を格納するために必要なものとは別に、追加の qubits を使用しないで追加を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-202">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="b3ad3-203">Beauregard の後に</span><span class="sxs-lookup"><span data-stu-id="b3ad3-203">Beauregard Adder</span></span> ###

<span data-ttu-id="b3ad3-204">Beauregard 追加は、任意の値の正の整数 $N $ に対して $ $N 加算の剰余を実行するために、Draper 追加を使用する、クォンタムモジュール化追加モジュールです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-204">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="b3ad3-205">Beauregard の追加など、量子モジュール化されたモジュールの有意性は、シャードまたはのアルゴリズム内のモジュール式の指数演算での使用から大きな範囲になります。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-205">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="b3ad3-206">Quantum モジュール型の配置では、クォンタム入力 $ \ket{b} $ と古典 $a 入力に対して次のアクションを実行します $。 $a $ と $b $ $N は、$ [0, \ lドット, N-1] $ の範囲内にあることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-206">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="b3ad3-207">$ $ \ket{b}\rightarrow \ket{b + a \ text{mod} N} = \begin{cases} \ket{b + a}、& b + a < N\\\\ \ket{b + a-N}、& (b + a) \ ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="b3ad3-207">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="b3ad3-208">Beauregard 追加は、Draper 追加を使用します。または、より具体的には $ \ phi\\\!、& $a $ と $b $ をフェーズに追加します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-208">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="b3ad3-209">次に、同じ操作を使用して、$ $N < $a を減算して N $ < N $ を $a かどうかを識別します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-209">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="b3ad3-210">回線は、この情報を補助 qubit に格納し、$a + b < N $ の場合はレジスタ $N $ back に追加します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-210">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="b3ad3-211">その後、この補助ビットを非コンピューティングにします (この手順は、ancilla を呼び出した後に割り当てを解除できるようにするために必要です)。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-211">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="b3ad3-212">Beauregard のための回線は、次のように指定されています。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-212">The circuit for the Beauregard adder is given below.</span></span>

![サーキットダイアグラムとして表示される Beauregard の表示](~/media/beau.png)

<span data-ttu-id="b3ad3-214">この例では、ゲート $ \ phi\\\!\ 演算子名 {add} $ は、$ + phi\\\!/演算子名 {add} $ と同じ形式になります。ただし、このコンテキストでは、入力はクォンタムではなく古典です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-214">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="b3ad3-215">これにより、$/Phi\\\!の制御されたフェーズをフェーズゲートに置き換えることができます。これは、1つのゲートビットの数と、追加に必要なゲートの数の両方を減らすために、より少数の操作にまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-215">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="b3ad3-216">詳細については、Beth と[d.](https://arxiv.org/abs/quant-ph/0201067) [Roetteler](http://doi.org/10.1007/s00200-008-0072-2 )を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-216">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="b3ad3-217">量子位相推定</span><span class="sxs-lookup"><span data-stu-id="b3ad3-217">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="b3ad3-218">クォンタムフーリエ変換の特に重要なアプリケーションの1つは、*フェーズ推定*と呼ばれる問題である、ユニタリ演算子の固有値を学習することです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-218">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="b3ad3-219">' $ \Ket{\phi} $ ' は、不明な eigenstate $/phi $, \ket{\phi} {\ phi} = \phi\ket{\phi}. を使用して $U $ の eigenstate であるため、$U $ と state $ $ のようにします。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-219">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="b3ad3-220">、oracle として $U $ にアクセスできるだけの場合は、制御され $Z た操作のターゲットに適用されている $ ローテーションをコントロールに反映させることで、フェーズ $-phi $ を学習できます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-220">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="b3ad3-221">$V $ が $U $ の制御されたアプリケーションであると仮定します。たとえば、\begin{align} V (\ket{0} \ otimes \ket{\phi}) & = \ket{0}/otimes \ket{\phi} \\\\ \t extrm{and} V (\ket{1}/otimes \ket{\phi}) & = e ^ {i \phi} \ket{1}/otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="b3ad3-221">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="b3ad3-222">\end{align}、直線性、\begin{align} V (\ket{+}、otimes \ket{\phi}) & = \frac{(\ket{0} \ otimes \ket{\phi}) + e ^ {i \phi} (\ket{1}/otimes \ket{\phi})} {/sqrt{2}}。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-222">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="b3ad3-223">\end{align} \begin{align} V (\ket{+}/otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\ sqrt{2}}/otimes \ket{\phi} \\\\ & = (R_1 (& phi) \ket{+}) \ otimes \ket{\phi}, \end{align} ($R _1 $ が <xref:microsoft.quantum.intrinsic.r1> 操作によって適用されるユニタリ) を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-223">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="b3ad3-224">別の方法として、$V $ を適用した場合の効果は、$V $ に oracle としてしかアクセスできない場合でも、$R _1 $ を不明な角度で適用することとまったく同じです。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-224">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="b3ad3-225">そのため、この説明の残りの部分では、$R _1 (\ phi) $ の観点からフェーズの推定について説明します。これは、いわゆる*フェーズ kickback*を使用して実装します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-225">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="b3ad3-226">このプロセスの後、コントロールとターゲットのレジスタは untangled のままであるため、$ \ket{\phi} $ を $U ^ $2 の制御されたアプリケーションのターゲットとして再利用して、2番目のコントロール qubit $R _1 (2 + phi) \ket{+} $ にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-226">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="b3ad3-227">この方法では、\begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j-phi) \ket{+} の形式のレジスタを取得できます \\。 \\ {j = 0} ^ {n} \ 左 (\ket & + \ exp です。 (i 2 ^ {j} \ phi) \ket{1} \\\\ & \ sum_ {k = 0} ^ {2 ^ n-1} \ exp (i-phi k) \ket{k} \end{align}。ここで $n $ は、必要な精度のビット数です。また、${}/propto {}$ を使用して、正規化係数 $ が抑制されていることを示しています。1/\ sqrt{2 ^ n} $。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-227">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="b3ad3-228">$-Phi = 2-pi p/2 ^ k $ が整数 $p $ であると仮定した場合、$ \ket{\psi} = p_1 p_0 \ket{p_n} $ として認識されます。ここで、$p _j $ は $j ^ {\t extrm{th} $ bit of $2/phi $ です。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-228">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="b3ad3-229">クォンタムのフーリエ変換の adjoint を適用するため、クォンタムの状態としてエンコードされたフェーズのバイナリ表現を取得します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-229">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="b3ad3-230">Q # では、これは <xref:microsoft.quantum.characterization.quantumphaseestimation> 操作によって実装されます。これは $U ^ m $ のアプリケーションを実装する <xref:microsoft.quantum.oracles.discreteoracle> を、正の整数 $m $ の関数として取得します。</span><span class="sxs-lookup"><span data-stu-id="b3ad3-230">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
