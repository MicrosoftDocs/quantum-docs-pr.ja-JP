---
title: Q でのクォンタムアルゴリズム#
description: 振幅増幅、フーリエ変換、Draper、Beauregard adders、フェーズの推定など、基本的なクォンタムコンピューティングアルゴリズムについて説明します。
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: aaa9ddf47e5ea35e7e57b9828db082889d0e6adf
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907241"
---
# <a name="quantum-algorithms"></a>クォンタムアルゴリズム #

## <a name="amplitude-amplification"></a>振幅増幅 ##

*振幅増幅*は、クォンタムコンピューティングの基本的なツールの1つです。 これは、Grover の検索、振幅推定、および多くのクォンタム機械学習アルゴリズムを基盤とする基本的なアイデアです。  さまざまなバリエーションがあります。 Q # では、無関係の振幅増幅に基づいて、部分的な反射を持つ一般的なバージョンを提供し、最も広い範囲のアプリケーションを可能にします。

振幅増幅の背後にある中心となる考え方は、一連の反射を行うことによって、目的の結果が発生する確率を増幅することです。  これらの反射は、初期状態を目的の状態 (マークされた状態と呼ばれることもあります) の近くに向かって回転させます。  具体的には、初期状態がマーク付きの状態になる確率が $ \ sin ^ 2 (-シータ) $ である場合、振幅増幅を適用した後 $m $/sin ^ 2 ((2m + 1) \ シータ) $ になります。  これは、$ \ シータ = \ pi/[2 (2n + 1)] $ $n の値がある場合に $ を使用すると、振幅増幅の $n $ 反復の後、$100\\% $ に成功する確率を上げることができることを意味します。  $ \ シータ = \ sin ^{-1}(\ sqrt{/Pr (success)}) $ であるため、成功を取得するために必要なイテレーションの数は、ランダムサンプリングを使用して、無作為に指定された状態を検出するために必要な数よりも quadratically 低くなります。

振幅増幅の各反復処理では、2つのリフレクション演算子が指定されている必要があります。 具体的には、$Q $ が振幅増幅で反復処理され、$P 0 $ がプロジェクターの最初のサブ空間にあり、$P _1 $ がプロジェクターのマークされたサブ $Q 空間にある場合は、=-(\ bold one-2P_0) (\ bold 完了-2P_1) $ となります。  プロジェクターは Hermitian 演算子であり、固有値 $ + $1 および $0 $ があることを思い出してください。 $ () $ は、unity (この場合は $ pm $1) のルートである固有値を持つため、その結果として $ (\ bold 完了-2P_0) $ になります。 例として、初期状態 $H ^ {\ otimes n} \ket{0}$ とマークされた状態 $ \ket{m} $、$P (0 = H ^ {/otimes n} \ket{0}\bra{0}H ^ {/otimes n} $、および $P _1 = \ket{m}\bra{m} $ という形式の Grover の検索を使用する場合を考えてみます。  ほとんどのアプリケーションでは、$P 0 $ はプロジェクターの初期状態になります。これは、一部の vector $ \ket{\psi} $; に対して $P 0 = k {\ psi} $ が設定されていることを意味します。ただし、無関係振幅 $P amplication では、通常、0 $ は多くのクォンタム状態に投影されます (つまり、$ + $1 eigenvalue of $P 0 $ の複数要素の接続性は $1 $ を超えています)。

振幅増幅の背後にあるロジックは、$Q $ の eigen 分解から直接たどります。  具体的には、初期状態がゼロ以外のサポートを持つ $Q $ の固有ベクトルは、$P 0 $ と $P _1 $ の $ + $1 固有ベクトルの線形組み合わせとして表示できます。  具体的には、振幅増幅の初期状態 ($P ($ + $1 eigenvector) であることを前提として、$ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \ left (e ^ {i\ シータ} \ k {\ psi_ +} + e ^ {-ik} \ {\ psi_-} \ right) として書き込むことができます。 $ $ where $ \ket{\ psi_ \ pm} $ は $Q $ と固有値 $e ^ {/pm 2i \ シータ} $ で、$ + $1 固有ベクトル (0 $ および $P _1 $) でのみサポートされています。 $P  固有値が $e ^ {\ pm i > $ の場合、演算子 $Q $ は、2つのプロジェクターによって指定された2次元のサブ空間で回転を実行し、回転角度が $ 2 \ シータ $ である初期状態を意味します。  このため、$ iteration $m $ iteration $Q $ の成功確率は $ \ sin ^ 2 ([2m + 1] \ シータ) $ です。

このようなもう1つの便利なプロパティとして、eigenvalue $/シータ $ は、初期状態がマークされる確率に直接関係しています ($P 0 $ がプロジェクターを初期状態にする場合)。  $Q $ の eigenphases は $ 2 \ シータ = 2 \ sin ^{-1}(\ sqrt{\ Pr (success)}) $ であるため、$Q $ にフェーズ推定を適用すると、その結果として、次のような処理が行われます。  これは、それ以外の場合に必要な成功の確率を知るために、クォンタムプロシージャの quadratically を減らす必要があるため便利です。

Q # では、無関係の振幅増幅の特殊化として振幅増幅が導入されています。  無関係の振幅増幅は、初期状態でプロジェクターを使用する必要がないため、このモニカーを獲得します。  この意味では、プロトコルは初期状態に無関係ます。  無関係の振幅増幅の重要なアプリケーションは、初期状態が不明であるものの、シミュレーションプロトコルで ancilla レジスタを使用してありになる、ユニタリ Hamiltonian シミュレーションメソッド*の線形組み合わせ*です。  この ancilla register が固定値 ($0 $ など) として測定された場合、このシミュレーションメソッドは、必要なユニタリ変換を残りの qubits (システムレジスタと呼びます) に適用します。  それ以外のすべての測定結果は失敗につながります。  無関係の振幅増幅を使用すると、この測定値が成功する確率を\\$100% $ に上げることができます。これについては、前述のようにしてください。  さらに、通常の振幅増幅は、システムレジスタが空の場合に相当します。  このため、Q # は無関係の振幅増幅を基本的な振幅増幅のサブルーチンとして使用します。

一般ルーチン (`AmpAmpObliviousByReflectionPhases`) には、`ancillaRegister` と `systemRegister`を呼び出す2つのレジスタがあります。 また、必要な反射に対して2つの oracles も受け入れます。 `ReflectionOracle` は `ancillaRegister` でのみ動作し、`ObliviousOracle` は両方のレジスタに共同で作用します。 `ancillaRegister` への入力は、最初のリフレクション演算子 $ \ 2P_1 $ の-1 eigenstate に初期化する必要があります。

通常、oracle はコンピューティングベース $ \ket{0...0} $ で状態を準備します。 この実装では、`ancillaRegister` が1つの qubit (`flagQubit`) に含まれており、`stateOracle` とその他の必要な ancillas を制御しています。 `stateOracle` は、`flagQubit` が $ \ket{1}$ の場合に適用されます。

また、`AmpAmpObliviousByOraclePhases`の呼び出しを通じて、反射ではなく、oracles `StateOracle` と `ObliviousOracle` を提供する場合もあります。

前述のように、従来の振幅増幅は、これらのルーチンの特殊なケースにすぎません。 `ObliviousOracle` が id 演算子で、システム qubits (つまり `systemRegister` が空) ではありません。 部分的な反射 (Grover 検索など) のフェーズを取得する場合は、関数 `AmpAmpPhasesStandard` を使用できます。 Grover のアルゴリズムの実装例については、`DatabaseSearch.qs` を参照してください。

G.H. の [記事で説明されているように、単一の qubit 回転フェーズをリフレクション演算子のフェーズに関連付けます。低、I. L。語](https://arxiv.org/abs/1707.05391)。 使用されている固定ポイントフェーズは、[語、低、および](https://arxiv.org/abs/1409.3305)語の各フェーズと共に、[最低でも](https://arxiv.org/abs/1603.03996)でも詳しく説明しています。

背景については、[標準の振幅増幅](https://arxiv.org/abs/quant-ph/0005055)から開始し、無関係の[振幅増幅](https://arxiv.org/abs/1312.1414)の概要に進み、最後に[低と語](https://arxiv.org/abs/1610.06546)で示されている一般化を行うことができます。 この領域全体 (Hamiltonian シミュレーションに関連する) のわかりやすい概要が[Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)によって提供されています。

## <a name="quantum-fourier-transform"></a>クォンタムフーリエ変換 ##

フーリエ変換は、古典的な分析の基本ツールであり、クォンタムの計算において非常に重要です。
さらに、 *quantum のフーリエ変換*(qft) の効率が、クォンタムアルゴリズムを設計するときに選択する最初のツールの1つとして、従来のコンピューターで可能なことをはるかに上回ります。

QFT のおおよその汎化として、目的のアルゴリズムの精度に対して厳密には必要のない回転を排除することにより、さらなる最適化を可能にする <xref:microsoft.quantum.canon.approximateqft> 操作を提供します。
おおよその QFT には、dyadic $Z $ ローテーション操作 <xref:microsoft.quantum.intrinsic.rfrac> および <xref:microsoft.quantum.intrinsic.h> 操作が必要です。
入力と出力はビッグエンディアン---エンコーディングでエンコードされていると想定されています。つまり、インデックス `0` を持つ qubit は、バイナリ整数表現の左端 (最上位) でエンコードされます。
これは、 [k 表記](xref:microsoft.quantum.concepts.dirac)と整合して{1}います。これは、state $ \ket{100}$ の3つの qubits のレジスタとして、$q _1 $ と $q _2 $ の両方が state $ \ket{0}$ にある $q に対応します。
近似パラメーター $a $ は、$ ローテーション $Z の排除レベルを決定します。つまり、[0.. n] $ に $a ます。
この例では、$ $Z $ ローテーション $ 2 \ pi/2 ^ k $ として $k > $ が QFT 回線から削除されます。
$K \ log_2 (n) + \ log_2 (1//イプシロン) + $3 であることがわかっています。 $\\| をバインドできます。\ オペレーター名 {qft}-& # {\\|</イプシロン $。
ここで、$\\| \ cdot\\| $ は演算子の基準です。ここでは、この例では、$ (\ operator name{qft}-\ operator name{qft}-\ operator name{ [% の演算子](xref:microsoft.quantum.concepts.matrix-advanced)) の平方根として使用されます。

## <a name="arithmetic"></a>算術 ##

算術演算が従来のコンピューティングで中心的な役割を果たしているのと同じように、クォンタムコンピューティングにも不可欠です。  Shor のファクタリングアルゴリズム、クォンタムシミュレーションメソッド、および多くの oracular アルゴリズムなどのアルゴリズムは、一貫した算術演算に依存しています。  クォンタムを作成するためのほとんどの方法は、クォンタムを作成することです。  最も単純な追加では、$b $ という従来の入力を受け取り、整数 $ \ket{a} $ を保持するクォンタム状態に値を追加します。  数学的には、追加の追加 (従来の入力 $b $) に対して $-演算子を使用することを意味します。このプロパティは、

$ $ \ 演算子名 {add} (b) \ket{a} = \ket{a + b}。
$ $ この基本的な追加回線は、追加の incrementer よりも大きくなります。
$ $ \Operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b} を使用して2つのクォンタム入力を持つ挿入を行うことができます。 $ $ $n $ によって制御されるアプリケーションを使用しています。この形式では、\ket{b} & = \ lambda\_{a\_0} \ left (\ 演算子の場合は、\begin{align} (1) \ right)、ラムダ\_{a\_1}、left (\ オペレーター名 {adders (2) \ 右) \ ラムダ\_{a\_2} \ 左 (\ 演算子 name{adders (4)) \ cドット & ラムダ\_{a\_{n-1}} \ 左 (\オペレーター名 {Add} ({{n-1}}) \ right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a} $n、$ ビット整数 $a $ および $b $ および加算剰余 $ 2 ^ n $。  $-ラムダ\_x (A) $ という表記では、$ という表記では、操作の制御されたバージョンに $A 対して、コントロールとして qubit $x $ が指定されていることを思い出してください。

同様に、クラシックデプロイに制御された乗算 (Shor のファクタリングアルゴリズムに不可欠なモジュール形式の形式) は、次のように制御される同様の一連の追加を使用して実行できます。 \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \ lambda\_{x\_0} \ left (\ 演算子 name{add} (2 ^ 0 a) \ right) \ ラムダ\_{a\_1} \ 左 (\ 演算子名) {add} (2 ^ 1a) \ right) \ ラムダ\_{a\_2} \ 左 (\ オペレーター名 {add} (2 ^ 2 a) \ 右) \\_{x\_{n-1}} \ left (\ 演算子 name{add} ({2 ^ {n-1}} a) \ right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + ax}。
\end{align} には、上に示した $ \operatorname{Mult} $ の定義から気付く可能性がある、量子コンピューターに対する乗算のはらみがあります。  加算とは異なり、この回線のクォンタムバージョンは入力の製品を入力レジスタではなく補助レジスタに格納します。  この例では、レジスタは $ $b 値を使用して初期化されますが、通常は値0の保持が開始されます。  このことが必要なのは、一般に、一般的な $a $ と $x $ の乗算が逆ではないためです。  すべてのクォンタム操作、測定値の保存は元に戻せるため、乗算を反転させるために十分な情報を保持する必要があります。  このため、結果は別の配列に格納されます。  このように、元に戻せない操作の出力を別のレジスタに保存することは、Charlie Bennett 後の "Bennett トリック" と呼ばれ、元に戻すことができ、クォンタムコンピューティングの両方で基本的なツールとなります。

多くのクォンタム回線の追加が提案されており、それぞれが qubits (space) の数と必要なゲート操作の数という点で異なるトレードオフを調べています。  Draper の追加と Beauregard の追加と呼ばれる、2つの高い領域を効率的にすることを確認します。

### <a name="draper-adder"></a>Draper の後に ###

Draper 追加は、追加を実行するためにクォンタムプロパティを直接呼び出すため、最も洗練されたクォンタムの1つです。  Draper の配置の背後にある洞察は、フーリエ変換を使用してフェーズシフトをビットシフトに変換できることです。  次に、フーリエ変換を適用し、適切なフェーズシフトを適用して、フーリエ変換を元に戻します。これにより、付属を実装できます。  提案されている他の多くの追加ファイルとは異なり、Draper 追加は、quantum フーリエ変換を通じて導入されたクォンタム効果を明示的に使用します。  自然な従来の対応するものはありません。  Draper の割り当ての具体的な手順を以下に示します。

2つの $n $-bit qubit レジスタに整数が格納されていると仮定します。 $ と $b $ $a すべての $a $ $ $ \operatorname{QFT}\ket{a} = \ frac{1}{-sqrt{2 ^ n}} \ sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj)/2 ^ n} \ket{j}.
$ $ \Ket{\phi を定義する場合は、$ $\_k (a)} = \ frac{1}{/sqrt{2}} \ left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} 右)、$ $ その後、いくつかの代数の後に、$ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)}/otimes/cドット/otimes \ket{\phi\_n (a)} と表示されます。
$ $ は、入力の合計を $ $ \ket{a + b}{-1}=\_\ket{\phi (a + b)}/otimes/cドット/otimes \ket{\phi\_n (a + b)} として書き込むことができることを観察した後に、クリアテキストになります。
$ $ $B $ と $a $ の整数を加算するには、$b $ としてのビットを使用して、分解の各 qubits に対して制御フェーズのローテーションを実行します。

この拡張は、任意の整数 $j $ と実数 $x $、$e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $ に対してさらに簡略化できます。  これは、円で $ 360 ^ {\circ} $ 度 ($ 2 \ pi $ ラジアン) を回転させると、開始位置が正確になるためです。  このため、$x $ for $e ^ {i2\pi x} $ の唯一の重要な部分は $x $ の小数部分です。  具体的には、$x = y +0\_0x\_2 \ ldots x\_n $、$e ^ {i2\pi x} = e ^ {i2\pi (0 という形式のバイナリ展開があるとします。 x\_0x\_2 \ ldots x\_{n-1})} $。したがって、$ $ \ket{\phi\_k (a + b)} = \ frac{1}{\ sqrt{2}} \ left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0\_k\ ldots b\_1]} \ket{1} 右)。 $ $ これは、各を増分して追加を実行すると、$ \ket{a} $ のフーリエ変換を拡大すると、回転数が $ 減少 $k に縮小されます。  これにより、増加に必要なクォンタムゲートの数が大幅に削減されます。  ここでは、フーリエ変換、フェーズの追加、および逆フーリエ変換のステップを示しています。これは、$ Draper の追加を構成します。この手順では、$-の{-1} 演算子として、$-(\ phi\\\!。 この単純化を使用してプロセス全体を実装するクォンタム回線は、次のようになります。

![サーキットダイアグラムとして表示される Draper の表示](~/media/draper.png)

回線の制御された $e ^ {i2 \ pi/k} $ ゲートはそれぞれ、制御されたフェーズゲートを参照します。  このようなゲートには、それらが動作する qubits のペアに対するプロパティがあります。このプロパティは、$ \ket{00}\ket{00}$ ではなく、$ \ket{11}-map@ \ k{11}$ です。  この回線では、入力と出力を格納するために必要なものとは別に、追加の qubits を使用しないで追加を実行できます。

### <a name="beauregard-adder"></a>Beauregard の後に ###

Beauregard 追加は、任意の値の正の整数 $N $ に対して $ $N 加算の剰余を実行するために、Draper 追加を使用する、クォンタムモジュール化追加モジュールです。  Beauregard の追加など、量子モジュール化されたモジュールの有意性は、シャードまたはのアルゴリズム内のモジュール式の指数演算での使用から大きな範囲になります。  Quantum モジュール型の配置では、クォンタム入力 $ \ket{b} $ と古典 $a 入力に対して次のアクションを実行します $。 $a $ と $b $ $N は、$ [0, \ lドット, N-1] $ の範囲内にあることを意味します。

$ $ \ket{b}\rightarrow \ket{b + a \ text{mod} N} = \begin{cases} \ket{b + a}、& b + a < N\\\\ \ket{b + a-N}、& (b + a) \ ge N \end{cases}.
$$

Beauregard 追加は、Draper 追加を使用します。または、より具体的には $ \ phi\\\!、& $a $ と $b $ をフェーズに追加します。  次に、同じ操作を使用して、$ $N < $a を減算して N $ < N $ を $a かどうかを識別します。  回線は、この情報を補助 qubit に格納し、$a + b < N $ の場合はレジスタ $N $ back に追加します。  その後、この補助ビットを非コンピューティングにします (この手順は、ancilla を呼び出した後に割り当てを解除できるようにするために必要です)。  Beauregard のための回線は、次のように指定されています。

![サーキットダイアグラムとして表示される Beauregard の表示](~/media/beau.png)

この例では、ゲート $ \ phi\\\!\ 演算子名 {add} $ は、$ + phi\\\!/演算子名 {add} $ と同じ形式になります。ただし、このコンテキストでは、入力はクォンタムではなく古典です。  これにより、$/Phi\\\!の制御されたフェーズをフェーズゲートに置き換えることができます。これは、1つのゲートビットの数と、追加に必要なゲートの数の両方を減らすために、より少数の操作にまとめることができます。

詳細については、[M. Roetteler (Th) を参照してください。Beth](http://doi.org/10.1007/s00200-008-0072-2 ) と[d. Coppersmith](https://arxiv.org/abs/quant-ph/0201067)。

### <a name="quantum-phase-estimation"></a>量子位相推定 ###

クォンタムフーリエ変換の特に重要なアプリケーションの1つは、*フェーズ推定*と呼ばれる問題である、ユニタリ演算子の固有値を学習することです。
' $ \Ket{\phi} $ ' は、不明な eigenstate $/phi $, \ket{\phi} {\ phi} = \phi\ket{\phi}. を使用して $U $ の eigenstate であるため、$U $ と state $ $ のようにします。
、oracle として $U $ にアクセスできるだけの場合は、制御され $Z た操作のターゲットに適用されている $ ローテーションをコントロールに反映させることで、フェーズ $-phi $ を学習できます。

$V $ が $U $ の制御されたアプリケーションであると仮定します。たとえば、\begin{align} V (\ket{0} \ otimes \ket{\phi}) & = \ket{0}/otimes \ket{\phi} \\\\ \t extrm{and} V (\ket{1}/otimes \ket{\phi}) & = e ^ {i \phi} \ket{1}/otimes \ket{\phi}.
\end{align}、直線性、\begin{align} V (\ket{+}、otimes \ket{\phi}) & = \frac{(\ket{0} \ otimes \ket{\phi}) + e ^ {i \phi} (\ket{1}/otimes \ket{\phi})} {/sqrt{2}}。
\end{align} \begin{align} V (\ket{+}/otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\ sqrt{2}}/otimes \ket{\phi} \\\\ & = (R_1 (& phi) \ket{+}) \ otimes \ket{\phi}, \end{align} ($R _1 $ が <xref:microsoft.quantum.intrinsic.r1> 操作によって適用されるユニタリ) を見つけることができます。
別の方法として、$V $ を適用した場合の効果は、$V $ に oracle としてしかアクセスできない場合でも、$R _1 $ を不明な角度で適用することとまったく同じです。
そのため、この説明の残りの部分では、$R _1 (\ phi) $ の観点からフェーズの推定について説明します。これは、いわゆる*フェーズ kickback*を使用して実装します。

このプロセスの後、コントロールとターゲットのレジスタは untangled のままであるため、$ \ket{\phi} $ を $U ^ $2 の制御されたアプリケーションのターゲットとして再利用して、2番目のコントロール qubit $R _1 (2 + phi) \ket{+} $ にすることができます。
このようにして次のようにして、\begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j-phi) \ket{+} の形式のレジスタを取得できます \\。 \\ {j = 0} ^ {n} \ 左 (\ket & + \ exp (i 2 ^-{j¥} \ phi) \ket{1} \\\\ & \ propto \ sum_ {k = 0} ^ {2 ^ n-1} \ exp (i-phi k) \ket{k} \end{align}。ここで $n $ は、必要な精度のビット数です。また、${}/propto {}$ を使用して、正規化係数 $ が抑制されていることを示しています。1/\ sqrt{2 ^ n} $。

$-Phi = 2-pi p/2 ^ k $ が整数 $p $ であると仮定した場合、$ \ket{\psi} = p_1 p_0 \ket{p_n} $ として認識されます。ここで、$p _j $ は $j ^ {\t extrm{th} $ bit of $2/phi $ です。
クォンタムのフーリエ変換の adjoint を適用するため、クォンタムの状態としてエンコードされたフェーズのバイナリ表現を取得します。

Q # では、これは <xref:microsoft.quantum.characterization.quantumphaseestimation> 操作によって実装されます。これは $U ^ m $ のアプリケーションを実装する <xref:microsoft.quantum.oracles.discreteoracle> を、正の整数 $m $ の関数として取得します。
