---
title: 'Q # API 設計の原則'
description: 'Q # API 設計の原則'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: 03c32331f8988181ec6fedcfc207d752b4a880b2
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/10/2020
ms.locfileid: "79024204"
---
# <a name="q-api-design-principles"></a>Q # API 設計の原則

## <a name="introduction"></a>はじめに

言語およびプラットフォームとして、ユーザーは、クォンタムアプリケーションの記述、実行、理解、調査を行うことができます。
ユーザーを支援するために、Q # ライブラリを設計する際には、一連の API 設計原則に従って設計を進め、quantum 開発コミュニティで使用可能なライブラリを作成できるようにします。
この記事では、これらの原則について説明し、Q # Api を設計するときに適用する方法を示す例を示します。

> [!TIP]
> これは、ライブラリの開発と詳細なライブラリの投稿をガイドするための、非常に詳細なドキュメントです。
> Q # で独自のライブラリを作成している場合や、 [q # ライブラリリポジトリ](https://github.com/microsoft/QuantumLibraries)に大きな機能を提供している場合は、最も役に立つでしょう。
>
> 一方、Quantum 開発キットに投稿する方法については、後で説明することをお[勧めします。](xref:microsoft.quantum.contributing)
> Q # コードを書式設定する方法についての一般的な情報を探している場合は、[スタイルガイド](xref:microsoft.quantum.contributing.style)を確認することをお勧めします。

## <a name="general-principles"></a>一般的な原則

**主要原則:** クォンタムアプリケーションに重点を置いた Api を公開します。

- アルゴリズムとアプリケーションの高レベルの構造を反映する操作と関数の名前**を選択 ✅** ます。
- ⛔️は、主に低レベルの実装の詳細に焦点を当てた Api を公開し**ません**。

**主要原則:** 各 API の設計をサンプルのユースケースで開始し、Api を直感的に使用できるようにします。

- ✅、パブリック API の各コンポーネントに対応するユースケースがあることを確認します。開始から使用できるすべてのを設計する必要はあり**ません**。
    別の方法として、公開されている Api は役に立たないようにしてください。ただし、API の各部分には、役に立つ*具体的*な例が含まれていることを確認してください。

  *例:*
  - @"microsoft.quantum.canon.applytoeachca" を `ApplyToEachCA(H, _)` として使用して、複数のクォンタムアルゴリズムの一般的なタスクである uniform 法則状態でレジスタを準備することができます。 同じ操作を、準備、数値、および oracle ベースのアルゴリズムの他の多くのタスクにも使用できます。

- 新しい API 設計を brainstorm およびワークショップに ✅ て、**直感的で、** 提案されたユースケースを満たすことを再確認します。

  *例:*
  - 現在の Q\# コードを調べて、新しい API 設計によって既存の実装がどのように簡略化され、明確になるかを確認します。
  - 主要ユーザーの代表者として提示された API 設計を確認します。

**主要原則:** 読み取り可能なコードをサポートし、奨励するように Api を設計します。

- ✅、ドメインの専門家や専門家以外の人がコードを**読み取ることが**できるようにします。
- ✅**は**、上位レベルのアルゴリズム内で各操作と関数の効果に重点を置きます。ドキュメントを使用して、必要に応じて実装の詳細について掘り下げます。
- ✅、必要に応じて、一般的な[Q\# スタイルガイド](xref:microsoft.quantum.contributing.style)に従って**ください**。

**主要原則:** 安定した Api を設計し、上位互換性を提供します。

- 互換性に影響する変更が必要な**場合は、✅ に**よって古い api が適切に廃止されます。

- ✅**は**、既存のユーザーコードが非推奨になったときに正しく動作するようにする "shim" 操作と関数を提供します。

  *例:*
  - `EstimateExpectation` と呼ばれる操作の名前を `EstimateAverage`に変更する場合は、既存のコードが引き続き正常に動作するように、元の操作を新しい名前で呼び出す `EstimateExpectation` という新しい操作を導入します。

- ✅ は、@"microsoft.quantum.core.deprecated" 属性を**使用して**、廃止をユーザーに通知します。

- ✅ 操作または関数の名前を変更する場合は、新しい名前を `@Deprecated`への文字列入力とし**て指定し**ます。

- プレビューリリースの場合は少なくとも6か月以上、サポートされているリリースでは少なくとも2年間は、既存の関数または操作を削除し**ない**ように⛔️します。

## <a name="functions-and-operations"></a>関数と操作

**重要な原則:** すべての関数と操作が API 内で明確に定義された1つの目的を持っていることを確認します。

- ⛔️は、関連のない複数のタスクを実行する関数や操作を公開し**ません**。

**重要な原則:** 可能な限り再利用できるように、関数と操作を設計し、将来のニーズを予測します。

- ✅**は**、同じ API と以前の既存のライブラリの両方で、他の関数や操作に合わせて関数と操作を設計する必要があります。

  *例:*
  - @"microsoft.quantum.canon.delay" 操作では、入力に関して最小限の仮定が行われるため、Q # 標準ライブラリ全体またはユーザーによる定義に従って、いずれかの操作のアプリケーションを遅延させることができます。
    <!-- TODO: define bad example. -->

- ✅**は**、純粋に確定的なクラシックロジックを操作ではなく関数として公開します。

  *例:*
  - 浮動小数点入力をランダムに記述できるサブルーチンでは、操作 `Square : Double => Double`ではなく、`Squared : Double -> Double` としてユーザーに公開する必要があります。 これにより、サブルーチンをより多くの場所 (たとえば、他の関数の内部) で呼び出すことができ、パフォーマンスと最適化に影響を与える有用な最適化情報がコンパイラに提供されます。
  - `ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` と `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` は、決定性に関して行われる保証とは異なります。どちらも、さまざまな状況で役立ちます。
  - クォンタム操作のアプリケーションを変換する API ルーチンは、決定論的な方法で実行されることが多いため、`CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`などの関数として使用できます。

- ✅**は**、必要に応じて型パラメーターを使用して、各関数および操作に対して適切な入力型を一般化する必要があります。

  *例:*
  - `ApplyToEach` には、最も一般的なアプリケーションの種類である `((Qubit => Unit), Qubit[]) => Unit`ではなく、型 `<'T>(('T => Unit), 'T[]) => Unit` があります。

> [!TIP]
> 将来のニーズを予測することが重要ですが、ユーザーの具体的な問題を解決することも重要です。
> この重要な原則に基づいて行動することは、Api の開発を避けるために、常に慎重に検討してバランスを行う必要があります。

**重要な原則:** 予測可能な関数と操作の入力と出力の種類を選択し、呼び出し可能な目的を伝えます。

- ✅ タプル型を使用して、入力と出力を論理的にグループ化します。**これ**は、まとめて考慮した場合にのみ重要です。 このような場合は、ユーザー定義型を使用することを検討してください。

  *例:*
  - 別の関数のローカル最小を出力する関数は、検索範囲の範囲を入力として受け取る必要がある場合があります。これは、`LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` が適切なシグネチャである可能性があるためです。
  - パラメーターシフト手法を使用して機械学習分類子の派生物を推定する操作では、シフトとシフト解除の両方のパラメーターベクトルを入力として取得する必要がある場合があります。 この場合、`(unshifted : Double[], shifted : Double[])` に似た入力が適している可能性があります。

- ✅**は**、入力と出力の組の項目を、さまざまな関数や操作にわたって一貫して並べ替えます。

  *例:*
  - 2つの関数または関数、またはそれぞれが回転角度とターゲット qubit を入力として使用することを検討している場合は、各入力タプルの順序が同じであることを確認します。 つまり、`ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` を優先し、`ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` と `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`に `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` します。

**重要な原則:** 部分アプリケーションなどの Q\# 言語機能に適した関数と操作を設計します。

- ✅**は**、最も一般的に適用される入力 (つまり、部分的なアプリケーションがカリー化と同様に動作するように) を最初に実行するように入力タプル内の項目を並べ替えます。

  *例:*
  - 入力として浮動小数点数と qubit を受け取る演算 `ApplyRotation` は、通常、型 `Qubit => Unit`の入力を期待する操作で使用するために、最初に浮動小数点入力と共に部分的に適用されることがあります。 したがって、`operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` のシグネチャ
      部分的なアプリケーションで最も一貫して動作します。
  - 通常、このガイダンスでは、入力タプル内のすべてのすべての古典データを、入力タプルのすべての qubits の前に配置しますが、実際の API の呼び出し方法については、適切な判断を行います。

## <a name="user-defined-types"></a>ユーザー定義型

**重要な原則:** ユーザー定義型を使用すると、api の表現性と利便性を高めることができます。

- 新しいユーザー定義型を導入して、長い型や複雑な型を簡単に使用**できるように**✅ ます。

  *例:*
  - 通常、3つの qubit 配列入力を持つ演算型が入力として取得される場合、または出力として返される場合は、などの UDT を指定し `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`
      は、便利なショートハンドを提供するのに役立ちます。

- 特定の基本型を使用する必要があることを示すために、新しいユーザー定義型**を導入 ✅** ます。

  *例:*
  - 特に、古典的なデータをクォンタムレジスタにエンコードする操作として解釈する必要がある操作は、ユーザー定義型 `newtype InputEncoder = (Apply : (Qubit[] => Unit))`のラベルに適している場合があります。

- 今後の拡張が可能な名前付きの項目を使用して、新しいユーザー定義型**を導入 ✅** ます (たとえば、後で追加の名前付き項目を含む可能性のある結果構造)。

  *例:*
  - 操作 `TrainModel` によって多数の構成オプションが公開され、これらのオプションが `TrainingOptions` 新しい UDT として公開され、新しい関数が提供され `DefaultTrainingOptions : Unit -> TrainingOptions` ユーザーは、TrainingOptions UDT 値内の特定の名前付き項目をオーバーライドできますが、ライブラリ開発者は必要に応じて新しい UDT 項目を追加できます。

- ✅、新しいユーザー定義型の名前付き項目を宣言して、ユーザーに正しい組分解を知ら**せるように**する必要があります。

  *例:*
  - 極分解で複素数を表す場合は、`newtype ComplexPolar = (Double, Double)`に `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` を優先します。

**重要な原則:** ユーザー定義型を使用すると、認知の負荷が軽減され、ユーザーが追加の概念や用語を習得する必要がありません。

- ⛔️ラップ解除演算子 (`!`) を頻繁に使用する必要があるユーザー定義型を導入したり、通常は複数レベルのラップ解除が必要になること**があります**。 次のような軽減策が考えられます。

  - 1つの項目を持つユーザー定義型を公開する場合は、その項目の名前を定義することを検討してください。 たとえば、`newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`を優先する `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` を検討します。

  - 他の関数および操作が "ラップされた" UDT インスタンスを直接受け入れることを保証する。

- ⛔️には、追加の表現力を提供せずに組み込み型を複製する新しいユーザー定義型は導入し**ません**。

  *例:*
  - UDT `newtype QubitRegister = Qubit[]` は、`Qubit[]`に対して追加の表現力を提供しないため、はっきり特典なしで使用するのは困難です。
  - UDT `newtype LittleEndian = Qubit[]` は、基になるレジスタがどのように使用および解釈されるかを文書化し、その基本型に対して追加の表現力を提供します。

- 厳密に要求されていない限り、⛔️アクセサー関数は導入し**ません**。  この場合は、名前付きの項目を強くお勧めします。

  *例:*
  - UDT `newtype Complex = (Double, Double)`を導入する場合は、`newtype Complex = (Real : Double, Imag : Double)` するように定義を変更して、関数 `GetReal : Complex -> Double` および `GetImag : Complex -> Double`を導入することをお勧めします。

## <a name="namespaces-and-organization"></a>名前空間と組織

**重要な原則:** それぞれの名前空間で、関数、操作、およびユーザー定義型の目的を明確に伝えることができる、予測可能な名前空間の名前を選択します。

- ✅**名前**空間を `Publisher.Product.DomainArea`として指定します。

  *例:*
  - Quantum 開発キットの quantum シミュレーション機能の一部として Microsoft が発行した関数、操作、および Udt は、`Microsoft.Quantum.Simulation` 名前空間に配置されます。
  - `Microsoft.Quantum.Math` は、Microsoft によって発行された名前空間を表します。これは、数学のドメイン領域に関する Quantum 開発キットの一部として公開されています。

- 特定の機能で使用されている操作、関数、およびユーザー定義型を名前空間に配置して、その機能が異なる問題ドメインで使用されている**場合でも**、その機能を説明する名前空間に ✅ します。

  *例:*
  - Quantum 開発キットの一部として Microsoft が発行した状態準備 Api は、`Microsoft.Quantum.Preparation`に配置されます。
  - Quantum 開発キットの一部として Microsoft が発行したクォンタムシミュレーション Api は、`Microsoft.Quantum.Simulation`に配置されます。

- ✅**は**、特定のドメイン内でのみ使用される操作、関数、およびユーザー定義型を、ユーティリティのドメインを示す名前空間に配置します。 必要に応じて、副名前空間を使用して、各ドメイン固有の名前空間内のフォーカスされたタスクを指定します。

  *例:*
  - Microsoft が発行したクォンタム機械学習ライブラリは、主に @"microsoft.quantum.machinelearning" 名前空間に配置されますが、データセットの例は @"microsoft.quantum.machinelearning.datasets" 名前空間によって提供されます。
  - Quantum 開発キットの一部として Microsoft によって発行された量子化学 Api は、`Microsoft.Quantum.Chemistry`に配置する必要があります。 ヨルダン化学分解の実装に固有の機能が `Microsoft.Quantum.Chemistry.JordanWigner`に配置されている場合があります。そのため、量子化学ドメイン領域の主要インターフェイスは、実装には関係ありません。

**主要原則:** 名前空間とアクセス修飾子を一緒に使用して、ユーザーに公開されている API サーフェイスに関する意図的なものにし、Api の実装とテストに関連する内部の詳細を非表示にします。

- ✅、API を実装するために必要なすべての関数と操作を、実装されている API と同じ名前空間**に配置しますが、"** private" または "internal" キーワードでマークして、ライブラリのパブリック API サーフェイスの一部ではないことを示すことができます。 アンダースコア (`_`) で始まる名前を使用して、プライベートおよび内部の操作と関数をパブリック呼び出しができるかを視覚的に区別します。

  *例:*
  - 操作名 `_Features` は、指定された名前空間とアセンブリに対してプライベートであり、`internal` キーワードを伴う関数を示します。

- 特定の名前空間の API を実装するために多数のプライベート関数または操作のセットが必要になることはまれの ✅、実装され、`.Private`で終了する名前空間に一致する新しい名前空間にそれら**を配置します。**

- ✅ **、** すべての単体テストを、テスト対象の名前空間に一致する名前空間に配置し、`.Tests`で終了します。

## <a name="naming-conventions-and-vocabulary"></a>名前付け規則とボキャブラリ

**主要原則:** さまざまな対象ユーザー (クォンタム初心者と専門家の両方を含む) で、明確で、アクセス可能で、読みやすい名前と用語を選択します。

- 差別的なまたは exclusionary 識別子の名前を使用したり、API ドキュメントのコメントに用語を使用したりすることは⛔️**ません**。

- API ドキュメントコメントを使用して、関連するコンテキスト、例、および参照を提供します。特に、より困難な概念につい**ては、** 「」を参照してください。 ✅

- ⛔️不要な識別子名を使用し**ない**でください。または、大量のクォンタムアルゴリズムの知識が必要です。

  *例:*
  - "振幅増幅の反復" を "Grover iteration" に優先します。

- ✅**は**、実装ではなく、呼び出し可能なの意図された効果を明確に伝える操作と関数の名前を選択します。 実装は、にすることができます。

  *例:*
  - 後者がどのように実装されているかを通知するため、"Hadamard test" に "推定重複" を優先します。

- すべての Q\# Api で、一貫した方法で単語**を使用 ✅** ます。

  - **助動詞**

    - **アサート**: ターゲットコンピューターとその qubits の状態に関する想定が、物理リソースを使用していない可能性があるかどうかを確認します。 この動詞を使用する操作は、ライブラリや実行可能プログラムの機能に影響を与えずに、常に安全な状態にしておく必要があります。 ファクトとは異なり、アサーションは一般に、qubit レジスタの状態や実行環境などの外部の状態に依存します。 外部の状態に対する依存関係は副作用の一種であるため、アサーションは関数ではなく操作として公開する必要があります。

    - **推定**: 1 つまたは複数の連続した測定値を使用して、測定結果から古典の数量を見積もります。

      *例:*
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - **準備**: 特定の初期状態 (通常は $ \ket{00\cdots 0} $) で開始することが想定される1つ以上の qubits に対して、クォンタム操作または一連の操作を適用します。これにより、これらの qubits の状態が目的の終了状態に進化します。 一般に、指定された開始状態以外の状態で動作すると、未定義のユニタリ変換が発生する**可能性があり**ますが、操作とその adjoint "キャンセル" を保持し、操作なしを適用する**必要**があります。

      *例:*
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - **メジャー**: 1 つ以上の qubits にクォンタム操作または一連の操作を適用し、古典的なデータをバックアウトします。

      *例:*
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - **適用**: クォンタム操作または操作のシーケンスを1つ以上の qubits に適用し、それらの qubits の状態が一貫した形で変化するようにします。 この動詞は、Q\# の用語で最も一般的な動詞であり、より具体的な動詞がより直接的に関連する場合は使用**しないでください**。

  - **名詞**:

    - **ファクト**: ターゲットコンピューターの状態、環境、またはコンピューターの qubits の状態ではなく、入力のみに依存するブール条件。 アサーションとは対照的に、ファクトは、そのファクトに対して指定された*値*にのみ影響します。 次に例を示します。

      *例:*
      - @"microsoft.quantum.diagnostics.equalityfacti": 2 つの整数入力に関する等価のファクトを表します。入力として指定された整数が互いに等しいか、または他のプログラムの状態に依存していないかのいずれかです。

    - **オプション:** 関数または演算に対して "省略可能な引数" として機能する複数の名前付き項目を含む UDT。 次に例を示します。

      *例:*
      - @"microsoft.quantum.machinelearning.trainingoptions" UDT には、学習率、ミニバッチサイズ、および ML トレーニング用のその他の構成可能なパラメーターの名前付き項目が含まれています。

  - **形容詞**:

    - ⛔️ **New**: この形容詞は使用し**ないでください**。多くのプログラミング言語 (: C++、 C#Java、TypeScript、PowerShell など) で動詞として使用する場合と混同しないようにしてください。

  - **前置詞:** 場合によっては、前置詞を使用して、関数名と操作名の名詞と動詞の役割をさらに明確に区別したり、明確にしたりすることができます。 ただし、そのためには控えめにする必要があります。

    - **次のようになります。** 関数の入力と出力が同じ情報を表しているが、出力ではその情報を元の表現ではなく*X* **として**表すことを表します。 これは、型変換関数では特に一般的です。

      *例:*
      - `IntAsDouble(2)` は、入力 (`2`) と出力 (`2.0`) の両方が同じ情報を表していますが、異なる Q\# データ型を使用していることを示しています。

    - **開始:** 一貫性を確保するために、この前置詞を使用**して、** 型変換関数や、が適切であるその他のケースを示すことはでき**ません**。

    - ⛔️ **:** この前置詞は、多くのプログラミング言語で動詞として使用する場合と混同しないように、使用しないことを**お勧め**します。
