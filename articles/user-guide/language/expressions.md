---
title: の式 Q#
description: 定数、変数、演算子、操作、および関数をの式として指定、参照、および結合する方法について説明 Q# します。
author: gillenhaalb
ms.author: a-gibec
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.expressions
no-loc:
- Q#
- $$v
ms.openlocfilehash: 9bf28e3854eae1892692d7ca840e1860de2e2934
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835844"
---
# <a name="expressions-in-no-locq"></a>の式 Q#

## <a name="numeric-expressions"></a>数値式

数値式は `Int` 、、 `BigInt` 、または型の式です `Double` 。
つまり、整数または浮動小数点数のいずれかです。

`Int` のリテラル Q# は、一連の数字として書き込まれます。
16進整数とバイナリ整数がサポートされ、それぞれとプレフィックスを使用して記述され `0x` `0b` ます。

`BigInt` のリテラルに Q# は、末尾 `l` またはサフィックスがあり `L` ます。
16進数の大きな整数がサポートされており、プレフィックス "0x" を使用して記述されています。
したがって、リテラルの有効な使用法は次のとおりです `BigInt` 。

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double` のリテラル Q# は、10進数を使用して記述された浮動小数点数です。
小数点、 `.` 、または "e" または "e" で示された指数部を使用して記述することもできます (その後は、負の符号と小数点以下の桁数のみが有効になります)。
有効なリテラルは、、 `Double` `0.0` `1.2e5` 、 `1e-5` です。

任意の要素型の配列式が指定されている場合は、 `Int` 組み込み関数を使用して式を作成できます。その際、 [`Length`](xref:microsoft.quantum.core.length) かっこで囲まれた配列式を使用します。
たとえば、 `a` が配列にバインドされている場合、 `Length(a)` は整数式になります。
`b`が整数の配列の配列である場合 `Int[][]` 、は `Length(b)` のサブ配列の数です `b` `Length(b[1])` 。はの2番目のサブ配列の整数の数です `b` 。

同じ型の2つの数値式が指定されている場合、二項演算子 `+` 、 `-` 、、およびを使用して、 `*` `/` 新しい数値式を作成できます。
新しい式の型は、構成式の型と同じです。

2つの整数式を指定する場合は、二項演算子 `^` (power) を使用して新しい整数式を作成します。
同様に、 `^` 2 つの double 式を使用して、新しい double 式を作成することもできます。
最後に、を使用して、左に大きな整数を指定し、右側の整数を使用し `^` て新しい大きな整数式を作成することができます。
この場合、2番目のパラメーターは32ビットにする必要があります。そうでない場合は、ランタイムエラーが発生します。

2つの整数または整数の式を指定した場合は、 `%` (剰余)、 `&&&` (ビットごとの and)、 `|||` (ビットごとの or)、または `^^^` (ビットごとの XOR) 演算子を使用して、新しい整数または整数式を形成します。

左に整数式または整数式を指定し、右側に整数式を指定する場合は、 `<<<` (算術左シフト) 演算子または `>>>` (算術右シフト) 演算子を使用して、左側の式と同じ型の新しい式を作成します。

シフト演算の2番目のパラメーター (シフト量) は、0以上である必要があります。負のシフト量の動作は未定義です。
また、いずれかのシフト操作のシフト量は、32ビットにも適合する必要があります。そうでない場合は、ランタイムエラーが発生します。
シフトされた数値が整数である場合は、シフトの量が解釈されます `mod 64` 。つまり、シフト1と65のシフトは同じ効果を持ちます。

整数値と大きな整数値の両方に対して、シフトは算術演算です。
負の値を左または右にシフトすると、負の数値になります。
つまり、1つのステップを左または右にシフトすることは、それぞれ2で乗算または除算することと同じです。

整数の除算と整数の剰余は、C# と同じ負の数値の動作に従います。 つまり、は `a % b` 常にと同じ符号を持ち、は常にと `a` `b * (a / b) + a % b` `a` なります。 次に例を示します。

|`A` | `B` | `A / B` | `A % B`|
|:---------:|:----------:|:---------:|:---------:|
| 5 | 2 | 2 | 1 |
| 5 | -2 | -2 | 1 |
| -5 | 2 | -2 | -1 |
| -5 | -2 | 2 | -1 |

大規模な整数除算および剰余演算は同じように動作します。

任意の数値式を指定すると、単項演算子を使用して新しい式を作成でき `-` ます。
新しい式は、構成式と同じ型です。

整数または大きな整数式を指定する場合は、 `~~~` (ビットごとの補数) 単項演算子を使用して、同じ型の新しい式を作成できます。

## <a name="boolean-expressions"></a>Boolean 式

2つの `Bool` リテラル値は、 `true` と `false` です。

同じプリミティブ型の2つの式がある場合、 `==` および `!=` 二項演算子を使用して式を作成でき `Bool` ます。
式は、2つの式が等しい場合は true、それ以外の場合は false です。

ユーザー定義型の値を比較することはできません。ラップ解除された値だけを比較できます。 たとえば、"ラップ解除" 演算子 `!` ([の Q# 型](xref:microsoft.quantum.guide.types#access-anonymous-items-with-the-unwrap-operator)の詳細については、「」をご覧ください) を使用します。

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

値の等価比較 `Qubit` は、id の等価性を表します。つまり、2つの式が同じ qubit を識別するかどうかを示します。
2つの qubits の状態は、この比較によって比較、アクセス、測定、または変更されません。

`Double`丸め効果が原因で、値の等価比較が誤解される可能性があります。
たとえば、「 `49.0 * (1.0/49.0) != 1.0` 」のように入力します。

2つの数値式を指定すると、二項演算子 `>` 、 `<` 、、およびを使用して、 `>=` `<=` 新しいブール式を作成できます。この式は、最初の式の値が、2番目の式の値よりも大きい、より小さい、より大きい、または等しい場合に true になります。

2つのブール式を指定した場合は、二項演算子を使用して、 `and` 2 つの式の両方が true の場合に true となる新しいブール式を作成します。 同様に、演算子を使用すると、 `or` 2 つの式のいずれかが true の場合に true となる式が作成されます。

任意のブール式を指定した `not` 場合、単項演算子を使用して新しいブール式を作成できます。これは、構成式が false の場合に true になります。

## <a name="string-expressions"></a>文字列式

Q#`fail`ステートメント ([制御フロー](xref:microsoft.quantum.guide.controlflow#fail-statement)で説明されています) および標準関数で文字列を使用できるようにし [`Message`](xref:microsoft.quantum.intrinsic.message) ます。 後者の特定の動作は、使用されるシミュレーターによって異なりますが、通常はプログラム中に呼び出されたときに、メッセージをホストコンソールに書き込み Q# ます。

内の文字列 Q# は、リテラルまたは挿入文字列です。

文字列リテラルは、ほとんどの言語の単純な文字列リテラルに似ています。これは、二重引用符で囲まれた Unicode 文字のシーケンス `" "` です。
文字列の内部では、円記号を使用して `\` 二重引用符 () をエスケープしたり、改行 `\"` ( `\n` )、キャリッジリターン ( `\r` )、またはタブ () を挿入したりし `\t` ます。
次に例を示します。

```qsharp
"\"Hello world!\", she said.\n"
```
### <a name="interpolated-strings"></a>挿入文字列

Q#文字列補間の構文は、C# 構文のサブセットです。 次に示すのは、関連する重要なポイント Q# です。

* 文字列リテラルを挿入文字列として識別するため、先頭に `$` の記号を追加してください。 との間には、 `$` `"` 文字列リテラルを開始する空白文字を使用できません。

* 次に、関数を使用して、 [`Message`](xref:microsoft.quantum.intrinsic.message) 他の式と共に測定の結果をコンソールに書き込む基本的な例を示し Q# ます。

```qsharp
    let num = 8;       // some Q# expression
    let res = M(q);
    Message($"Number: {num}, Result: {res}");
```

* 有効な Q# 式は、挿入文字列に含めることができます。

* 挿入文字列内の式は Q# 、C# 構文ではなく構文に従います。 最も顕著な違いは、が Q# 逐語的 (複数行) の補間文字列をサポートしていないことです。

C# の構文の詳細については、「 [*補間文字列*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings)」を参照してください。

## <a name="range-expressions"></a>範囲の式

、、およびという3つの式が指定されている場合、式は、が `Int` `start` `step` `stop` `start .. step .. stop` 渡されるまで、最初の要素が `start` 、2番目の要素が、 `start+step` 3 番目の要素がである範囲式です `start+step+step` `stop` 。
たとえば、が正の値やである場合、範囲は空になることがあり `step` `stop < start` ます。

範囲は両端を含みます。 つまり、との差 `start` `stop` がの整数の倍数である場合、 `step` 範囲の最後の要素はになり `stop` ます。

との2つの式が指定されて `Int` `start` `stop` いる場合、式はと `start .. stop` 等しい範囲式になり `start .. 1 .. stop` ます。
がより小さい場合でも、暗黙のは + 1 であることに注意して `step` `stop` `start` ください。この場合、範囲は空になります。

範囲の例を次に示します。

- `1..3` の範囲は1、2、3です。
- `2..2..5` は2、4の範囲です。
- `2..2..6` は2、4、6の範囲です。
- `6..-2..2` は6、4、2の範囲です。
- `2..1` は空の範囲です。
- `2..6..7` は2の範囲です。
- `2..2..1` は空の範囲です。
- `1..-1..2` は空の範囲です。

## <a name="qubit-expressions"></a>Qubit 式

唯一の `Qubit` 式は、 `Qubit` 配列の値または配列要素にバインドされている記号です `Qubit` 。
リテラルがありません `Qubit` 。

## <a name="pauli-expressions"></a>P# li 式

、、、およびの4つの `Pauli` 値 `PauliI` は、 `PauliX` `PauliY` `PauliZ` すべて有効な `Pauli` 式です。

それ以外の式は、 `Pauli` `Pauli` 配列の値または配列要素にバインドされるシンボルです `Pauli` 。

## <a name="result-expressions"></a>結果式

2つの `Result` 値 ( `One` と `Zero` ) は、有効な `Result` 式です。

それ以外の式は、 `Result` `Result` 配列の値または配列要素にバインドされるシンボルです `Result` 。
特に、 `One` は整数と同じではなく、 `1` これらの間に直接変換がないことに注意してください。
とにも同じことが当てはまり `Zero` `0` ます。

## <a name="tuple-expressions"></a>タプル式

組リテラルは、適切な型の要素式のシーケンスで、かっこで囲まれたコンマで区切られます。
たとえば、 `(1, One)` は `(Int, Result)` 式です。

リテラル以外の唯一のタプル式は、タプル値にバインドされたシンボル、組配列の配列要素、およびタプルを返す呼び出し可能な呼び出しです。

## <a name="user-defined-type-expressions"></a>ユーザー定義型の式

ユーザー定義型のリテラルは、型名の後に型の基本タプル型のタプルリテラルが含まれています。
たとえば、 `IntPair` がに基づくユーザー定義型である場合、 `(Int, Int)` `IntPair(2, 3)` はその型の有効なリテラルです。

リテラル以外に、ユーザー定義型の唯一の式は、その型の値、その型の配列の配列要素、およびその型を返す呼び出し可能な呼び出しの値にバインドされている記号です。

## <a name="unwrap-expressions"></a>ラップ解除 (式の)

で Q# は、ラップ解除演算子は末尾の感嘆符 `!` です。
たとえば、 `IntPair` が基になる型のユーザー定義型で、 `(Int, Int)` `s` が値を持つ変数である場合、 `IntPair(2, 3)` はに `s!` `(2, 3)` なります。

他のユーザー定義型の観点から定義されたユーザー定義型の場合は、ラップ解除演算子を繰り返すことができます。 たとえば、は、 `s!!` の二重ラップ解除された値を示し `s` ます。
したがって、 `WrappedPair` が基になる型のユーザー定義型で、 `IntPair` `t` が値を持つ変数である場合、 `WrappedPair(IntPair(1,2))` はに `t!!` `(1,2)` なります。

演算子は、 `!` 配列のインデックス作成およびスライス以外の他のすべての演算子よりも優先順位が高く `[]` なります。
`!` とを `[]` バインド位置。つまり、 `a[i]![3]` は `((a[i])!)[3]` `i` の th 要素を受け取り、 `a` ラップを解除してから、ラップ解除された値の3番目の要素 (配列である必要があります) を取得します。

演算子の優先順位は、 `!` 明らかでない可能性がある1つの影響を与えます。
関数または操作が、ラップされていない値を返す場合は、ラップ解除ではなく、引数のタプルが呼び出しにバインドされるように、関数または操作の呼び出しをかっこで囲む必要があります。
次に例を示します。

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>配列式

配列リテラルは、角かっこで囲まれた、コンマで区切られた1つ以上の要素式のシーケンスです `[]` 。
すべての要素は、同じ型と互換性がある必要があります。

同じ型の2つの配列を指定した場合、 `+` 2 つの配列を連結した新しい配列を作成するには、二項演算子を使用します。
たとえば、`[1,2,3] + [4,5,6]` = `[1,2,3,4,5,6]` です。

### <a name="array-creation"></a>配列の作成

型と式を指定した場合は、演算子を使用して、 `Int` `new` 指定されたサイズの新しい配列を割り当てます。
たとえば、では、 `new Int[i + 1]` `Int` 要素を含む新しい配列が割り当てら `i + 1` れます。

などの空の配列リテラル `[]` は使用できません。
代わりに、を使用して長さ0の配列を作成でき `new T[0]` ます。ここで、 `T` は適切な型のプレースホルダーです。

新しい配列の要素は、型に依存する既定値に初期化されます。
ほとんどの場合、これはゼロのバリエーションです。

エンティティへの参照である qubits と callables 指定できる場合、適切な既定値はありません。
したがって、これらの型の場合、既定値は無効な参照です。これは、C# や Java などの言語での null 参照と同様に、ランタイムエラーを発生させずに使用することはできません。
要素を安全に使用するには、qubits または callables 含む配列を既定値以外の値で初期化する必要があります。 適切な初期化ルーチンについては、「」を参照してください <xref:microsoft.quantum.arrays> 。

各型の既定値は次のとおりです。

Type | Default
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _無効な qubit_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | 空の範囲。 `1..1..0`
 `Callable` | _無効な呼び出し可能_
 `Array['T]` | `'T[0]`

タプル型は要素ごとに初期化します。


### <a name="array-elements"></a>配列要素

配列式と式が指定され `Int` ている場合は、配列要素演算子を使用して新しい式を作成し `[]` ます。
新しい式は、配列の要素型と同じ型です。
たとえば、 `a` が型の配列にバインドされている場合、 `Double` `a[4]` は `Double` 式です。

配列式が単純識別子でない場合は、要素を選択するためにかっこで囲む必要があります。
たとえば、 `a` と `b` が両方とも型の配列である場合、 `Int` 連結の要素は次のように表されます。

```qsharp
(a + b)[13]
```

内のすべての配列 Q# は、0から始まります。
つまり、配列の最初の要素 `a` は常に `a[0]` です。


### <a name="array-slices"></a>配列スライス

配列式と式を指定した `Range` 場合は、配列スライス演算子を使用して新しい式を作成し `[ ]` ます。
新しい式は配列と同じ型であり、で定義されている順序で、の要素によってインデックスが作成された配列項目を格納し `Range` `Range` ます。
たとえば、 `a` が型の配列にバインドされている場合、 `Double` `a[3..-1..0]` は、 `Double[]` の最初の4つの要素を含む式ですが、 `a` では逆の順序で表示され `a` ます。

が空の場合、結果とし `Range` て得られる配列スライスは長さが0になります。

配列要素を参照する場合と同様に、配列式が単純識別子でない場合は、それをかっこで囲み、スライスする必要があります。
たとえば、 `a` と `b` が両方とも型の配列である場合、 `Int` 連結のスライスは次のように表されます。

```qsharp
(a+b)[1..2..7]
```

#### <a name="inferred-startend-values"></a>推定される開始/終了値

[0.8 リリース](xref:microsoft.quantum.relnotes)以降では、範囲スライスのコンテキスト式がサポートされています。 特に、range スライシング式のコンテキストで範囲の開始値と終了値を省略できます。 その場合、コンパイラは次の規則を適用して、範囲の目的の区切り記号を推論します。

* 範囲の *開始* 値を省略した場合、推論された開始値
  * ステップが指定されていない場合、または指定されたステップが正の場合、は0になります。  
  * 指定された手順が負の場合に、スライスされた配列の長さから1を引いた値です。

* 範囲の *終了* 値を省略した場合、推論された終了値
  * スライスされた配列の長さ、ステップが指定されていない場合、または指定されたステップが正の場合は1を引いた値です。
  * 指定されたステップが負の場合、は0になります。

いくつかの例を次に示します。

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

### <a name="copy-and-update-expressions"></a>コピーと更新の式

すべての Q# 型は値型であるため (少し特別な役割を果たす qubits を使用)、値がシンボルにバインドされているとき、またはシンボルが再バインドされるときに "コピー" が作成されます。 つまり、の動作 Q# は、代入演算子を使用してコピーが作成された場合と同じです。 

もちろん、実際には、関連する部分のみが必要に応じて再作成されます。 これは、配列項目を更新できないため、配列のコピー方法に影響します。 既存の配列を変更するには、 *コピーと更新* のメカニズムを利用する必要があります。

*コピーと更新*の式を使用して、既存の配列から新しい配列を作成することができます。この場合、との演算子を使用し `w/` `<-` ます。
コピーと更新の式は、という形式の式です。 `expression1 w/ expression2 <- expression3`

* `expression1` 何らかの型の型である必要があり `T[]` `T` ます。
* `expression2` で指定された、変更する配列内のインデックスを定義 `expression1` します。 `expression2` 型または型のいずれかである必要があり `Int` `Range` ます。
* `expression3` で `expression1` 指定されたインデックスに基づいて、の要素を更新するために使用される値です `expression2` 。 `expression2`が型の場合 `Int` 、は `expression3` 型である必要があり `T` ます。 `expression2`が型の場合 `Range` 、は `expression3` 型である必要があり `T[]` ます。

たとえば、コピーと更新の式では、で指定された要素を `arr w/ idx <- value` 除き、すべての要素が内の対応する要素に設定された新しい配列を構築し `arr` ます。ただし、で指定した要素は、 `idx` の値に設定され `value` ます。 

指定されたに `arr` 配列が含まれてい `[0,1,2,3]` ます。 

- `arr w/ 0 <- 10` は配列 `[10,1,2,3]` です。
- `arr w/ 2 <- 10` は配列 `[0,1,10,3]` です。
- `arr w/ 0..2..3 <- [10,12]` は配列 `[10,1,12,3]` です。

#### <a name="copy-and-update-expressions-for-named-items"></a>名前付き項目のコピーと更新の式

ユーザー定義型の名前付き項目についても、同様の式が存在します。 

たとえば、型について考えてみます。 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
`c`に型の値が含まれている場合 `Complex(1., -1.)` 、 `c w/ Re <- 0.` はに評価される型の式です `Complex` `Complex(0., -1.)` 。

### <a name="jagged-arrays"></a>ジャグ配列

ジャグ配列は、"配列の配列" と呼ばれることもあり、要素が配列である配列です。
ジャグ配列の要素のサイズは異なる場合があります。
次の例は、乗算テーブルを表すジャグ配列を宣言および初期化する方法を示しています。

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {
    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```

### <a name="arrays-of-callables"></a>呼び出し許容の配列 

また、呼び出し可能な配列を作成することもできます。

* 共通の要素型が演算型または関数型である場合、すべての要素の入力と出力の型が同じである必要があります。
* 配列の要素型は、すべての要素でサポートされ [ているすべての機能をサポート](xref:microsoft.quantum.guide.operationsfunctions) しています。
たとえば、 `Op1` 、 `Op2` 、およびは `Op3` すべて操作です `Qubit[] => Unit` が、 `Op1` サポート、 `Adjoint` サポート `Op2` `Controlled` 、およびサポートの `Op3` 両方がサポートされます。
  * `[Op1, Op2]` は操作の配列です `(Qubit[] => Unit)` 。
  * `[Op1, Op3]` は操作の配列です `(Qubit[] => Unit is Adj)` 。
  * `[Op2, Op3]` は操作の配列です `(Qubit[] => Unit is Ctl)` 。

ただし、操作 `(Qubit[] => Unit is Adj)` と  `(Qubit[] => Unit is Ctl)` の共通基本型がであるのに対し、 `(Qubit[] => Unit)` これらの操作の *配列* は共通の基本型を共有しません。

たとえば、では、 `[[Op1], [Op2]]` 互換性のない2つの配列型との配列を作成しようとするため、現在、ではエラーが発生し `(Qubit[] => Unit is Adj)[]` `(Qubit[] => Unit is Ctl)[]` ます。

呼び出し可能の詳細については、このページの「呼び出し可能な[式](#callable-expressions)」または「 [」の Q# 操作と関数](xref:microsoft.quantum.guide.operationsfunctions)を参照してください。

## <a name="conditional-expressions"></a>条件式

同じ型の2つの式とブール式を指定した場合は、疑問符、、および縦棒を使用して条件式を形成し `?` `|` ます。 指定した `a==b ? c | d` 場合、条件式の値は、が true で、false である場合はになり `c` `a==b` `d` ます。

### <a name="conditional-expressions-with-callables"></a>呼び出しが許容される条件式

条件式は、入力と出力が同じで、異なる機能をサポートする操作に評価される場合があります。 この場合、条件式の型は、両方の式でサポートされているすべての機能をサポートする入力と出力を持つ操作です。
たとえば、、 `Op1` `Op2` 、およびはすべてですが、はをサポートし、サポートし、 `Op3` `Qubit[]=>Unit` 両方を `Op1` `Adjoint` `Op2` `Controlled` `Op3` サポートします。

- `flag ? Op1 | Op2` は `(Qubit[] => Unit)` 操作です。
- `flag ? Op1 | Op3` は `(Qubit[] => Unit is Adj)` 操作です。
- `flag ? Op2 | Op3` は `(Qubit[] => Unit is Ctl)` 操作です。

2つの結果式のいずれかに関数呼び出しまたは演算呼び出しが含まれている場合、その呼び出しは、その結果が呼び出しの値である場合にのみ行われます。 たとえば、 `a==b ? C(qs) | D(qs)` が true の場合、 `a==b` `C` 操作が呼び出されます。 false の場合は、操作だけが `D` 呼び出されます。 この方法は、他の言語の *ショートサーキット* に似ています。

## <a name="callable-expressions"></a>呼び出し可能式

呼び出し可能なリテラルは、コンパイルスコープで定義されている操作または関数の名前です。 たとえば、 `X` は、標準ライブラリの操作を参照する操作リテラルであり、 `X` `Message` は標準ライブラリ関数を参照する関数リテラルです `Message` 。

操作が `Adjoint` ファンクタをサポートする場合、 `Adjoint op` は演算式です。
同様に、操作がファンクタをサポートする場合、 `Controlled` `Controlled op` は演算式です。
これらの式の型の詳細については、「 [操作の特殊化の呼び出し](xref:microsoft.quantum.guide.operationsfunctions#calling-operation-specializations)」を参照してください。

( `Adjoint` および `Controlled` ) は、ラップ解除演算子と配列のインデックス作成を除き、他のすべての演算子よりも密接にバインドさ `!` `[ ]` れます。
このため、操作で使用されている機能がサポートされていれば、次のすべてが有効になります。

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

### <a name="type-parameterized-callable-expressions"></a>型パラメーター化可能な呼び出し可能式

呼び出し可能なリテラルを値として使用することができます。たとえば、変数に代入したり、別の呼び出し可能なリテラルに渡したりすることができます。 この場合、呼び出し可能に [型パラメーター](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables)がある場合は、呼び出し可能な値の一部としてパラメーターを指定する必要があります。

呼び出し可能な値には、指定されていない型パラメーターを含めることはできません。 たとえば、 `Fun` がシグネチャを持つ関数の場合は、次のようになり `'T1->Unit` ます。

```qsharp
let f = Fun<Int>;            // f is (Int->Unit).
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun<Double>);   // A (Double->Unit) is passed to SomeOtherFun.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>呼び出し可能呼び出し式

呼び出し可能な式 (操作または関数) と、呼び出し可能なシグネチャの入力型の組式が指定されている場合は、呼び出し式にタプル式を追加することにより、 *呼び出し式* を形成できます。
呼び出し式の型は、呼び出し可能なシグネチャの出力型です。

たとえば、 `Op` がシグネチャを持つ操作である場合 `((Int, Qubit) => Double)` 、 `Op(3, qubit1)` は型の式です `Double` 。
同様に、 `Sin` がシグネチャを持つ関数の場合 `(Double -> Double)` 、 `Sin(0.1)` は型の式です `Double` 。
最後に、 `Builder` がシグネチャを持つ関数の場合、 `(Int -> (Int -> Int))` `Builder(3)` はからへの関数になり `Int` `Int` ます。

呼び出し可能な値の式の結果を呼び出すには、呼び出し可能な式を囲むかっこのペアを追加する必要があります。
したがって、前の段落からを呼び出した結果を呼び出すに `Builder` は、正しい構文は次のようになります。

```qsharp
(Builder(3))(2)
```

[型パラメーター付き](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables)呼び出し可能呼び出しを呼び出す場合、呼び出し可能な式の後に、山かっこ内に実際の型パラメーターを指定でき `< >` ます。
通常、このアクションは、 Q# コンパイラが実際の型を推論するときには不要です。
ただし、型パラメーターの引数が指定されていない *場合は、* [部分的なアプリケーション](xref:microsoft.quantum.guide.operationsfunctions#partial-application) で必要になります。
また、異なるファンのサポートを持つ操作を呼び出し可能に渡す場合にも便利です。

たとえば、がシグネチャを持ち、シグネチャを持ち、シグネチャを持つ場合、2番目の引数としてを呼び出し、3番目の引数としてを `Func` `('T1, 'T2, 'T1) -> 'T2` `Op1` `Op2` `(Qubit[] => Unit is Adj)` `Op3` `(Qubit[] => Unit)` 呼び出し `Func` `Op1` `Op2` `Op3` ます。

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

との型が異なるため、型指定が必要です。そのため、 `Op3` `Op1` コンパイラはこれを仕様なしにあいまいとして扱います。


## <a name="operator-precedence"></a>演算子の優先順位

* すべての二項演算子は、を除き、右から結合され `^` ます。

* `[ ]`配列のスライスおよびインデックス作成のための角かっこは、任意の演算子の前にバインドします。

* `Adjoint` `Controlled` 配列のインデックス作成後、他のすべての演算子の前にバインドします。

* 演算と関数呼び出しのかっこは、演算子の前、配列のインデックス作成および関数の後にもバインドされます。

Q# 演算子は優先順位の高い順になります。

演算子 | アリ | 説明 | オペランドの型
---------|----------|---------|---------------
 末尾 `!` | 単項 | ラップ解除 | 任意のユーザー定義型
 `-`, `~~~`, `not` | 単項 | 負の数値、ビットごとの補数、論理否定 | `Int`、、 `BigInt` またはの場合 `Double` `-` `Int` は `BigInt` `~~~` `Bool` 、の場合は。 `not`
 `^` | Binary | 整数の累乗 | `Int` 底の場合は `BigInt` 、 `Int` 指数部の場合は
 `/`, `*`, `%` | Binary | 除算、乗算、整数剰余 | `Int`、、、、 `BigInt` `Double` `/` `*` `Int` または `BigInt` の場合は。 `%`
 `+`, `-` | Binary | 加算または文字列と配列の連結、減算 | `Int`、、 `BigInt` また `Double` は、また `String` はのいずれかの配列型 `+`
 `<<<`, `>>>` | Binary | 左シフト、右シフト | `Int` または `BigInt`
 `<`, `<=`, `>`, `>=` | Binary | より小さい、より小さい、または等しい、より大きい、より大きい、または等しい比較 | `Int`、`BigInt` または `Double`
 `==`, `!=` | Binary | 等しい、等しくない比較 | 任意のプリミティブ型
 `&&&` | Binary | ビット演算子 AND | `Int` または `BigInt`
 `^^^` | Binary | ビットごとの XOR | `Int` または `BigInt`
 <code>\|\|\|</code> | Binary | ビットごとの OR | `Int` または `BigInt`
 `and` | Binary | 論理積 | `Bool`
 `or` | Binary | 論理和 | `Bool`
 `..` | Binary/三項 | 範囲演算子 | `Int`
 `?` `|` | 三項 | 条件付き | `Bool` 左側にある
`w/` `<-` | 三項 | コピーと更新 | 「[コピーと更新の式」を](#copy-and-update-expressions)参照してください。

## <a name="next-steps"></a>次のステップ

で式を操作できるようになったので、操作と関数 Q# を[ Q# ](xref:microsoft.quantum.guide.operationsfunctions)定義して呼び出す方法については、「」を参照してください。
