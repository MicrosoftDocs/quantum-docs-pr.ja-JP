---
title: Q# 方
description: 基本的な概念 Q#
author: gillenhaalb
ms.author: a-gibec
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- Q#
- $$v
ms.openlocfilehash: 86f6538cf383f4e7c14255b38cfb1c141c8f991b
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835521"
---
# <a name="no-locq-basics"></a>Q# 方

この記事では、の基本的な構成要素について簡単に説明し Q# ます。

Q#Quantum 開発キットの基本コンポーネントとして何が当てはまる[ Q# か](xref:microsoft.quantum.overview.q-sharp)の概要については、「」を参照してください。 

## <a name="what-is-a-quantum-program"></a>クォンタムプログラムとは

技術的な観点から見ると、quantum プログラムは、特定の一連の従来のサブルーチンであり、これを呼び出すと、クォンタムシステムで特定の操作を実行します。
このビューの重要な結果として、 Q# プログラムは qubits 自体を直接モデル化するのではなく、クラシックデプロイによって制御されるコンピューターがこれらの qubits と対話する方法を説明します。
仕様により、では、クォンタム Q# の状態やその他の量子機構のプロパティは直接定義されていません。
たとえば、「 {0} {1} {2} [クォンタムコンピューティングの概念](xref:microsoft.quantum.concepts.intro) 」ガイドで説明されているように、$ \ket{+} = \ left (\ket + \ket/right)//sqrt $ という状態を検討してください。
でこの状態を準備するには Q# 、まず、qubits が $ \ket $ 状態で初期化されていること {0} と、$ \ket{+} = H\ket $ という事実を使用し {0} ます。ここで、$H $ は、 [ `H` 操作](xref:microsoft.quantum.intrinsic.h)によって実装される[Hadamard transform](xref:microsoft.quantum.glossary#hadamard)です。 次の Q# ように、qubit を初期化して変換する基本的なコードを次に示します。

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
の初期化、または *割り当て*の詳細については、「 [Qubits の操作](xref:microsoft.quantum.guide.qubits)」を参照してください。

## <a name="quantum-states-in-no-locq"></a>クォンタム状態 Q#

重要な点として、前のプログラムでは、内の状態を明示的に参照するのではなく、 Q# プログラムの状態がどのように *変換* されるかを説明します。
この方法では、各ターゲットコンピューター上でもクォンタムの状態を完全には認識できません。これは、コンピューターによって *は* 、解釈が異なる場合があります。 

プログラムは、 Q# qubit の状態に introspect ことはできません。
代わりに、プログラムはなどの操作を呼び出して、 [`Measure`](xref:microsoft.quantum.intrinsic.measure) qubit から情報を取得し、やなどの操作を呼び出して、 [`X`](xref:microsoft.quantum.intrinsic.x) [`H`](xref:microsoft.quantum.intrinsic.h) qubit の状態を操作できます。
これらの操作は *、実際には、* 特定のプログラムを実行するために使用されるターゲットコンピューターによってのみ具体的に行われ Q# ます。
たとえば、 [フルステートシミュレーター](xref:microsoft.quantum.machines.full-state-simulator)でプログラムを実行すると、シミュレーターはシミュレートされたクォンタムシステムに対応する数学的操作を実行します。
しかし、将来的に見てみると、ターゲットコンピューターが実際の quantum のコンピューターである場合、でこのような操作を呼び出すと、 Q# *実際*のクォンタムシステムに対応する*実際*の操作を実行するようにクォンタムコンピューターに指示します。たとえば、正確に時間がかかるレーザーパルスなどです。

プログラムは、 Q# ターゲットコンピューターによって定義されたこれらの操作を結合して、クォンタムの計算を高速にする新しい高度な操作を作成します。
このようにすることで、は、 Q# ターゲットコンピューターまたはシミュレーターの構造に関して一般的なものであるクォンタムとハイブリッドクォンタム–クラシックアルゴリズムのロジックを簡単に表現できるようになります。

## <a name="no-locq-operations-and-functions"></a>Q# 操作と関数

具体的に, Q# プログラムは、 *操作*、 *関数*、およびすべてのユーザー定義型で構成されています。 

操作は、クォンタムシステムの変換を記述するために使用され、プログラムの最も基本的なビルドブロックです Q# 。 で定義された各操作は、その Q# 後、任意の数の他の操作を呼び出すことができます。

操作とは対照的に、関数は純粋に *決定的* な動作を記述するために使用され、古典的な値の計算以外には影響を与えません。 たとえば、プログラムの末尾にある qubits を測定し、測定結果を配列に追加するとします。
この場合、 `Measure` は、ターゲットコンピューターに対して (実際またはシミュレートされた) qubits の測定を実行するように指示する *操作* です。 同時に、 *関数* は、返された結果を配列に追加する従来のプロセスを処理します。

操作と関数は、 *呼び出し*が実行できると呼ばれています。 [の操作と関数 Q# ](xref:microsoft.quantum.guide.operationsfunctions)では、基になる構造と動作が導入され、詳細に説明されています。


## <a name="no-locq-syntax-overview"></a>Q# 構文の概要

言語の構文では、構文的に正しいプログラムを形成する記号のさまざまな組み合わせについて説明します。
で Q# は、構文要素は、型、式、およびステートメントの3つの異なるグループに分類されます。

### <a name="types"></a>種類
Q# は、厳密に型指定された言語であり、型を慎重に使用することで、コンパイル時にプログラムに関して強力な保証を提供するのに役立ち Q# ます。
標準およびクォンタム固有の組み込みのプリミティブ型 (、、、など) に加えて、で `Int` `Bool` `Qubit` `Result` Q# はユーザー定義型がサポートされています。

すべてのプリミティブ型、配列と組の型の詳細、ファイル内で新しい型を定義する手順につい Q# ては、「 [ Q# 」](xref:microsoft.quantum.guide.types)の「型」を参照してください。

### <a name="expressions"></a>式
プログラミング言語の式は、プログラミング言語によって解釈され、特定の値に評価される1つ以上の定数、変数、演算子、および関数の組み合わせです。
ほとんどの場合、言語のすべての型に対して、その型の式には、 *リテラル* またはその型の値にバインドされた記号を使用できます。
たとえば、 `5` は `Int` リテラル (つまり型の式) であり、 `Int` 記号 `count` が整数値にバインドされている場合、 `5` `count` は整数式でもあります。

また、式は、特定の演算子で結合された他の式で構成できます。
たとえば、と `Int` して評価される別の式 `5` は `2+3` です。

の式と互換性のある演算子の詳細について Q# は、「 [」の Q# 「型式](xref:microsoft.quantum.guide.expressions)」を参照してください。 

### <a name="statements"></a>ステートメント 
ステートメントは、実行する何らかのアクションを表す命令型プログラミング言語の構文単位です。ステートメントをそのステートメント内の式と比較すると、結果は返されず、副作用のためだけに実行されます。 ただし、式は常に結果を返し、副作用はほとんどありません。 つまり、 Q# ステートメントは実行され、式は評価されます。

のステートメントの簡単な例 Q# は、式に記号を割り当てることです。
```qsharp
let count = 5;
```

より興味深い例として、 `for` 反復処理をサポートし、 *ステートメントブロック*を含むステートメントがあります。
たとえば `qubits` 、記号が qubits のレジスタにバインドされているとします (技術的には、型の `Qubit[]` 場合は、型の配列の場合 `Qubit` )。 手段
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
レジスタ内の各 qubit を反復処理し、それぞれに対して操作を実行するステートメントです `H` 。 がステートメントでもあることに注意 `H(qubit);` してください。

型の任意の呼び出し式 `Unit` ( `Unit` 型は情報を返さない) をステートメントとして使用できます。
この型の式は、を返す qubits で操作を呼び出すときに便利です。これは、 `Unit` ステートメントの目的は、暗黙的なクォンタムの状態を変更するためです。
式の評価ステートメントでは、セミコロンを終了する必要があります。

ステートメントを使用すると、プログラムのほぼすべての側面を構築でき Q# ます。また、1つのページに関連するすべての情報を含めることはできません。
構文の構造と書式設定の詳細については、「 [ Q# ファイルの構造](xref:microsoft.quantum.guide.filestructure)」を参照してください。シンボルのバインドの割り当てとスコープについては、「 [」の Q# 「変数](xref:microsoft.quantum.guide.variables)」と「」などの制御フローループ `for` [ Q# ](xref:microsoft.quantum.guide.controlflow)を参照してください。

## <a name="next-steps"></a>次のステップ

[の型 Q# ](xref:microsoft.quantum.guide.types)について学習を開始します。

基礎と動機の背景については Q# 、「 [必要な理由」 Q# ](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)を参照してください。
