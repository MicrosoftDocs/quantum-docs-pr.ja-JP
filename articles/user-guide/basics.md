---
title: 'Q # の基本'
description: Q の基本的な概念#
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: 45e6f2f33dafc2aec177091d3cfa94aca14fbf0a
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415363"
---
# <a name="q-basics"></a>Q # の基本

この記事では、Q # の基本的な構成要素について簡単に説明します。

どのような Q # があるかの概要と、Quantum 開発キットの基本コンポーネントとしての位置づけについては、「 [q # とは](xref:microsoft.quantum.overview.q-sharp)」を参照してください。 

## <a name="what-is-a-quantum-program"></a>クォンタムプログラムとは

技術的な観点から見ると、quantum プログラムは、特定の一連の従来のサブルーチンであり、これを呼び出すと、クォンタムシステムで特定の操作を実行します。
このビューの重要な結果として、Q # プログラムは qubits 自体を直接モデル化するのではなく、クラシックデプロイで制御されたコンピューターがこれらの qubits と対話する方法について説明します。
仕様により、Q # では、クォンタムの状態やその他の量子機構のプロパティは直接定義されていません。
たとえば、「 {0} {1} {2} [クォンタムコンピューティングの概念](xref:microsoft.quantum.concepts.intro)」ガイドで説明されているように、$ \ket{+} = \ left (\ket + \ket/right)//sqrt $ という状態を検討してください。
この状態を Q # で準備するには、まず、qubits が $ \ket $ 状態で初期化されていることと、$ {0} \ket{+} = H\ket $ という事実を使用し {0} ます。 $H ここで、$ は、 [ `H` 操作](xref:microsoft.quantum.intrinsic.h)によって実装される[Hadamard transform](xref:microsoft.quantum.glossary#hadamard)です。 次のように、qubit を初期化して変換するための基本的な Q # コードを次に示します。

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
の初期化、または*割り当て*の詳細については、「 [Qubits の操作](xref:microsoft.quantum.guide.qubits)」を参照してください。

## <a name="quantum-states-in-q"></a>Q でのクォンタムの状態#

重要な点として、前のプログラムでは、Q # 内の状態を明示的に参照するのではなく、プログラムの状態がどのように*変換*されるかを説明します。
この方法では、各ターゲットコンピューター上でもクォンタムの状態を完全には認識できません。これは、コンピューターによって*は*、解釈が異なる場合があります。 

Q # プログラムは、qubit の状態に introspect ことはできません。
代わりに、プログラムはなどの操作を呼び出して、 [`Measure`](xref:microsoft.quantum.intrinsic.measure) qubit から情報を取得し、やなどの操作を呼び出して、 [`X`](xref:microsoft.quantum.intrinsic.x) [`H`](xref:microsoft.quantum.intrinsic.h) qubit の状態を操作できます。
これらの操作*で*実際に実行されるのは、特定の q&a プログラムを実行するために使用されるターゲットコンピューターのみです。
たとえば、[フルステートシミュレーター](xref:microsoft.quantum.machines.full-state-simulator)でプログラムを実行すると、シミュレーターはシミュレートされたクォンタムシステムに対応する数学的操作を実行します。
しかし、将来的に見てみると、ターゲットコンピューターが実際の quantum のコンピューターである場合、Q # でこのような操作を呼び出すと、*実際*のクォンタムシステムに対応する*実際*の操作 (たとえば、正確に時間がかかるレーザーパルス) を実行するようにクォンタムコンピューターに指示されます。

Q # プログラムは、ターゲットコンピューターによって定義されたこれらの操作を結合して、クォンタム計算を表す新しい高レベルの操作を作成します。
このように Q # を使用すると、対象のマシンまたはシミュレーターの構造に関しても一般的に、基になるクォンタムやハイブリッドクォンタム–クラシックアルゴリズムを簡単に表現できます。

## <a name="q-operations-and-functions"></a>Q # 操作と関数

具体的に Q # プログラムは、*操作*、*関数*、および任意のユーザー定義型で構成されています。 

操作は、クォンタムシステムの変換を記述するために使用され、Q # プログラムの最も基本的なビルドブロックです。 Q # で定義された各操作は、他の任意の数の操作を呼び出すことができます。

操作とは対照的に、関数は純粋に*決定的*な動作を記述するために使用され、古典的な値の計算以外には影響を与えません。 たとえば、プログラムの末尾にある qubits を測定し、測定結果を配列に追加するとします。
この場合、 `Measure` は、ターゲットコンピューターに対して (実際またはシミュレートされた) qubits の測定を実行するように指示する*操作*です。 同時に、*関数*は、返された結果を配列に追加する従来のプロセスを処理します。

操作と関数は、*呼び出し*が実行できると呼ばれています。 これらの基礎となる構造と動作については、「 [Q # の操作と関数](xref:microsoft.quantum.guide.operationsfunctions)」で説明されています。


## <a name="q-syntax-overview"></a>Q # 構文の概要

言語の構文では、構文的に正しいプログラムを形成する記号のさまざまな組み合わせについて説明します。
Q # では、構文要素は、型、式、およびステートメントの3つの異なるグループに分類されます。

### <a name="types"></a>型
Q # は、厳密に型指定された言語であり、型を慎重に使用することで、コンパイラがコンパイル時に Q # プログラムに対する強力な保証を提供するのに役立ちます。
標準およびクォンタム固有の組み込みのプリミティブ型 (、、、など) に加え `Int` て `Bool` `Qubit` `Result` 、Q # ではユーザー定義型がサポートされています。

すべてのプリミティブ型、配列と組の型の詳細、および Q # ファイル内で新しい型を定義する手順については、「 [q # の型](xref:microsoft.quantum.guide.types)」を参照してください。

### <a name="expressions"></a>式
プログラミング言語の式は、プログラミング言語によって解釈され、特定の値に評価される1つ以上の定数、変数、演算子、および関数の組み合わせです。
ほとんどの場合、言語のすべての型に対して、その型の式には、*リテラル*またはその型の値にバインドされた記号を使用できます。
たとえば、 `5` は `Int` リテラル (つまり型の式) であり、 `Int` 記号 `count` が整数値にバインドされている場合、 `5` `count` は整数式でもあります。

また、式は、特定の演算子で結合された他の式で構成できます。
たとえば、と `Int` して評価される別の式 `5` は `2+3` です。

Q # の式と互換性のある演算子の詳細については、「 [q # の型式](xref:microsoft.quantum.guide.expressions)」を参照してください。 

### <a name="statements"></a>ステートメント 
ステートメントは、実行する何らかのアクションを表す命令型プログラミング言語の構文単位です。ステートメントをそのステートメント内の式と比較すると、結果は返されず、副作用のためだけに実行されます。 ただし、式は常に結果を返し、副作用がまったくないことがよくあります。 つまり、Q # ステートメントが実行され、式が評価されます。

Q # のステートメントの簡単な例では、式に記号を割り当てています。
```qsharp
let count = 5;
```

より興味深い例として、 `for` 反復処理をサポートし、*ステートメントブロック*を含むステートメントがあります。
たとえば `qubits` 、記号が qubits のレジスタにバインドされているとします (技術的には、型の `Qubit[]` 場合は、型の配列の場合 `Qubit` )。 Then
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
レジスタ内の各 qubit を反復処理し、それぞれに対して操作を実行するステートメントです `H` 。 がステートメントでもあることに注意 `H(qubit);` してください。

型の任意の呼び出し式 `Unit` ( `Unit` 型は情報を返さない) をステートメントとして使用できます。
この型の式は、を返す qubits で操作を呼び出すときに便利です。これは、 `Unit` ステートメントの目的は、暗黙的なクォンタムの状態を変更するためです。
式の評価ステートメントでは、セミコロンを終了する必要があります。

ステートメントを使用すると、Q # プログラムのほぼすべての側面を構築できます。また、1つのページに関連するすべての情報を含めることはできません。
構文の構造と書式設定の詳細については、「 [Q # ファイル構造体](xref:microsoft.quantum.guide.filestructure)」を参照してください。シンボルバインディングの割り当てとスコープについては、「 [Q # の変数](xref:microsoft.quantum.guide.variables)」を参照してください。などの制御フローループについ `for` ては、「 [Q # の制御フロー](xref:microsoft.quantum.guide.controlflow)」を参照してください。

## <a name="next-steps"></a>次のステップ

[Q # の型](xref:microsoft.quantum.guide.types)について学習を開始します。

Q # の背後にある基礎と動機の背景については、「 [q # が必要な理由](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)」を参照してください。
