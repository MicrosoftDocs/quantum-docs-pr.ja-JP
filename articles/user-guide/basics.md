---
title: 'Q # の基本'
description: Q の基本的な概念#
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: fd0ea47f00b1456ec460808ef7d451c8427677cd
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431157"
---
# <a name="q-basics"></a>Q # の基本

このセクションでは、Q # の基本的な構成要素について簡単に説明します。

どのような Q # があるか、および Quantum 開発キットの基本コンポーネントとしてどのような場合に役立つかの概要については、「 [q # とは](xref:microsoft.quantum.overview.q-sharp)」をご覧ください。 

## <a name="what-is-a-quantum-program"></a>クォンタムプログラムとは

技術的な観点から見ると、クォンタムプログラムは、クォンタムシステムで特定の操作を実行するときに、特定の一連の従来のサブルーチンと考えることができます。
このビューの重要な結果として、Q # で記述されたプログラムは、qubits 自体を直接モデル化するのではなく、従来のコントロールコンピューターがその qubits とどのようにやり取りするかを説明します。
設計上、Q # では、クォンタムの状態やその他の量子機構のプロパティを直接定義していません。
たとえば、「 {0} {1} {2} [クォンタムコンピューティングの概念](xref:microsoft.quantum.concepts.intro)」ガイドで説明されているように、$ \ket{+} = \ left (\ket + \ket/right)//sqrt $ という状態を検討してください。
この状態を Q # で準備するには、qubits が $ \ket $ 状態で初期化され、 {0} $ \ket{+} = H\ket $ というファクトを使用し {0} ます。 $H ここで、$ は、[ `H` operation] (] (xref:) によって実装される Hadamard transform です。

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a>Q でのクォンタムの状態#

重要なのは、上記のプログラムを作成するときに、Q # 内の状態を明示的に参照するのではなく、その状態がプログラムによってどのように*変換*されたかを説明することです。
これにより、各ターゲットコンピューター上でもクォンタムの状態を完全には認識できなくなります。これは、コンピューターによって*は*、解釈が異なる場合があります。 

Q # プログラムは、qubit の状態に introspect することはできません。
代わりに、プログラムはなどの操作を呼び出して、 [`Measure`](xref:microsoft.quantum.intrinsic.measure) qubit から情報を取得したり、やなどの操作を呼び出して [`X`](xref:microsoft.quantum.intrinsic.x) [`H`](xref:microsoft.quantum.intrinsic.h) qubit の状態を操作したりできます。
これらの操作は *、実際には、* 特定の q&a プログラムを実行するために使用するターゲットコンピューターによってのみ具体的に行われます。
たとえば、[フルステートシミュレーター](xref:microsoft.quantum.machines.full-state-simulator)でプログラムを実行すると、シミュレーターはシミュレートされたクォンタムシステムに対応する数学的操作を実行します。
しかし、将来的に見てみると、ターゲットコンピューターが実際の quantum のコンピューターである場合、Q # でこのような操作を呼び出すと、*実際*のクォンタムシステムに対応する*実際*の操作を実行するように、クォンタムコンピューターが指示されます (正確に時間がかかるレーザーパルスなど)。

Q # プログラムは、ターゲットコンピューターによって定義されたこれらの操作を結合して、クォンタム計算を表す新しい高レベルの操作を作成します。
このように Q # を使用すると、対象のマシンまたはシミュレーターの構造に関しても一般的に、基になるクォンタムやハイブリッドクォンタム–クラシックアルゴリズムを簡単に表現できます。

## <a name="q-operations-and-functions"></a>Q # 操作と関数

具体的に Q # プログラムは、*操作*、*関数*、およびすべてのユーザー定義型で構成されています。 

操作は、クォンタムシステムの変換を記述するために使用され、Q # プログラムの最も基本的なビルドブロックです。 Q # で定義された各操作は、他の任意の数の操作を呼び出すことができます。

操作とは対照的に、関数は純粋に*決定的*な動作を記述するために使用され、古典的な値の計算以外には影響を与えません。 たとえば、プログラムの末尾にある qubits を測定し、測定結果を配列に追加するとします。
この例で `Measure` は、 *operation* (実際のまたはシミュレートされた) qubits の測定を実行するように対象コンピューターに指示し、返された結果を配列に追加する従来のプロセスは*関数*によって処理されます。

また、操作と関数は、*呼び出し*が実行できるものと呼ばれ、その基になる構造と動作は[Q # ページの操作と関数](xref:microsoft.quantum.guide.operationsfunctions)で導入されています。


## <a name="q-syntax-overview"></a>Q # 構文の概要

言語の構文では、構文的に正しいプログラムを形成する記号のさまざまな組み合わせについて説明します。
Q # では、3つの異なるグループ (型、式、ステートメント) で構文の要素を分類できます。

### <a name="types"></a>種類
Q # は、厳密に型指定された言語であり、型を慎重に使用することで、コンパイラがコンパイル時に Q # プログラムに対する強力な保証を提供するのに役立ちます。
標準およびクォンタム固有の組み込みのプリミティブ型 (、、、など) に加えて `Int` `Bool` `Qubit` `Result` 、Q # ではユーザー定義型がサポートされています。
Q # のさまざまなプリミティブ型については、「Q # の[型」ページで](xref:microsoft.quantum.guide.types)、配列と組の型の詳細と、q # ファイル内で新しい型を定義する方法について説明しています。

### <a name="expressions"></a>式
プログラミング言語の式は、プログラミング言語によって解釈され、特定の値に評価される1つ以上の定数、変数、演算子、および関数の組み合わせです。
ほとんどの場合、言語のすべての型に対して、その型の式には、*リテラル*またはその型の値にバインドされた記号を使用できます。
たとえば、 `5` は `Int` リテラル (つまり型の式) であり、 `Int` 記号 `count` が整数値にバインドされている場合、 `5` `count` は整数式でもあります。

また、式は、特定の演算子と組み合わせた他の式で構成されます。
そのため、と評価される式のもう1つの例 `Int` `5` は `2+3` です。

Q # の型の式と、それらを形成するために使用できる互換性のある演算子の詳細については、 [q # ページの型式](xref:microsoft.quantum.guide.expressions)に関するページをご覧ください。 

### <a name="statements"></a>ステートメント 
ステートメントは、実行する何らかのアクションを表す命令型プログラミング言語の構文単位です。ステートメントをそのステートメント内の式と比較すると、結果は返されず、副作用のためだけに実行されます。一方、式は常に結果を返し、副作用はまったくありません。
この区別は、多くの場合、式が評価されるのに対し、ステートメントが実行されます。

Q # のステートメントの非常に基本的な例は、式に記号を割り当てることです。
```qsharp
let count = 5;
```

さらに興味深い例として、 `for` 反復処理をサポートし、*ステートメントブロック*を含むステートメントがあります。
たとえば `qubits` 、記号が qubits のレジスタにバインドされているとします (技術的には型の `Qubit[]` 配列、つまり型の配列 `Qubit` )。 Then
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
は、レジスタ内の各 qubit を反復処理し、 `H` それぞれに対して操作を実行するステートメントです。 がステートメントでもあることに注意 `H(qubit);` してください。

実際には、型の任意の呼び出し式 `Unit` (情報を返さない型の呼び出し可能な呼び出し) は、ステートメントとして使用できます。
これは主に、 `Unit` ステートメントの目的が暗黙的なクォンタムの状態を変更するためにを返す qubits で操作を呼び出すときに使用されます。
式の評価ステートメントでは、セミコロンを終了する必要があります。

Q # プログラムのほぼすべての側面がステートメントを使用して構築されているため、1つのページに関連するすべての情報が含まれるとは限りません。
ただし、構文の構造と書式設定については、q # の[ファイル構造](xref:microsoft.quantum.guide.filestructure)のページ、 [q # の変数](xref:microsoft.quantum.guide.variables)でのシンボルのバインドの割り当てとスコープ `for` 、 [q # の制御フロー](xref:microsoft.quantum.guide.controlflow)などの制御フローループについて説明しています。


## <a name="whats-next"></a>次の内容
このガイドの残りの部分では、操作、関数、および型の基本的な構成要素を使用して、Q # を使用して複雑なクォンタムプログラムを作成する方法について説明します。

まず、 [Q # で型](xref:microsoft.quantum.guide.types)について学習を開始できます。

Q # の基礎と動機の詳細については、「 [q # が必要な理由](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)」を参照してください。
