---
title: クォンタムの特性と統計
description: フェーズの予測からの測定統計を使用して、クォンタムプログラミングの結果値を推定する方法について説明します。
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 72af3f5517b272d6d8159b158103b5af91d266b5
ms.sourcegitcommit: c48cdafccb3487bf93d67fa80cdc64768445b691
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/06/2021
ms.locfileid: "97940888"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="8a543-103">クォンタムの特性と統計</span><span class="sxs-lookup"><span data-stu-id="8a543-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="8a543-104">実用的なクォンタムアルゴリズムを開発するために、操作の効果を特徴付けることが重要です。</span><span class="sxs-lookup"><span data-stu-id="8a543-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="8a543-105">これは、クォンタムシステムのすべての測定値が1ビットの情報を生成するため、困難です。</span><span class="sxs-lookup"><span data-stu-id="8a543-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="8a543-106">このような概念を表すために必要な多くの情報をユーザーが収集できるように、1つのクォンタム状態だけを使用して、eigenvalue を学習するには、多くの測定の結果を合成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="8a543-107">クォンタムの状態は特に厄介です。これは、 [複製なしの定理](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) は、状態のコピーを作成できるようにするため、状態の1つのコピーから任意のクォンタム状態を学習する方法がないことを示すためです。</span><span class="sxs-lookup"><span data-stu-id="8a543-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="8a543-108">ユーザーからのクォンタム状態のこの難読化は、" Q# クォンタムプログラム" に対して状態を公開したり定義したりしないという事実に反映されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="8a543-109">このため、操作と状態を黒色のボックスとして扱うことによって、クォンタムの特性を解決します。このアプローチは、クォンタムの特性、検証、検証 (QCVV) の実験的プラクティスによく似ています。</span><span class="sxs-lookup"><span data-stu-id="8a543-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="8a543-110">特性は、前に説明した他の多くのライブラリとは異なります。</span><span class="sxs-lookup"><span data-stu-id="8a543-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="8a543-111">ここでの目的は、状態ベクターでのユニタリ変換を実行するのではなく、システムに関する古典的な情報を学習することです。</span><span class="sxs-lookup"><span data-stu-id="8a543-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="8a543-112">したがって、これらのライブラリは、クラシック情報とクォンタム情報の両方の処理をブレンドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="8a543-113">反復フェーズの推定</span><span class="sxs-lookup"><span data-stu-id="8a543-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="8a543-114">クォンタムの特性に関してクォンタムプログラミングを見ると、クォンタムフェーズの推定に代わる便利な方法となります。</span><span class="sxs-lookup"><span data-stu-id="8a543-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="8a543-115">つまり、$n $-qubit レジスタにクォンタムフェーズの推定と同様にフェーズのバイナリ表現を含めるように準備するのではなく、 *クラシック* エージェントが測定を使用してクォンタムシステムのプロパティを学習するプロセスとして、フェーズ推定を表示できます。</span><span class="sxs-lookup"><span data-stu-id="8a543-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="8a543-116">ここでは、フェーズ kickback を使用して、ブラックボックスの操作のアプリケーションを不明な角度で回転させますが、回転の直後の各手順で回転する ancilla qubit を測定します。</span><span class="sxs-lookup"><span data-stu-id="8a543-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="8a543-117">これには、クォンタムケースで説明されているフェーズ kickback を実行するために1つの追加の qubit だけが必要であるという利点があります。そのため、各ステップの測定結果から反復的な方法を学習します。</span><span class="sxs-lookup"><span data-stu-id="8a543-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="8a543-118">以下の各方法では、実験を設計するためのさまざまな戦略と、フェーズを学習するためのさまざまなデータ処理方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="8a543-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="8a543-119">各ユーザーには、厳密なエラーの範囲、前の情報の組み込み、エラーの許容、メモリ limitted の古典コンピューターでの実行など、それぞれ固有の利点があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="8a543-120">反復的なフェーズの推定については、ブラックボックスの操作として指定された $U $ のユニタリが考慮されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="8a543-121">[データ構造](xref:microsoft.quantum.libraries.data-structures)の oracles に関するセクションで説明したように、キャノンのモデルは、 Q# ユーザー定義型によって、 <xref:Microsoft.Quantum.Oracles.DiscreteOracle> タプル型によって定義された演算を実行し `((Int, Qubit[]) => Unit : Adjoint, Controlled)` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="8a543-122">の場合、具体的に、の場合は `U : DiscreteOracle` `U(m)` $U ^ m $ を実装し `m : Int` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="8a543-123">この定義では、反復フェーズの推定の各手順は、$ \ket{+} $ 状態の補助 qubit と初期状態 $ \ket{\phi} $ を準備しています。これは、$U [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) (m) $、つまり $U (m) \ket{\phi} = e ^ {im/phi} \ k {\ phi} $ と想定されています。</span><span class="sxs-lookup"><span data-stu-id="8a543-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="8a543-124">その後、の制御されたアプリケーションを `U(m)` 使用して、$ left (R \_ 1 (m) \ket{+} \ right) \ket{\phi} $ という状態を準備します。</span><span class="sxs-lookup"><span data-stu-id="8a543-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="8a543-125">クォンタムの場合と同様に、oracle の制御されたアプリケーションの効果は、 `U(m)` $ \ket{+} $ の不明なフェーズに対して $R _1 $ を適用した場合の効果とまったく同じです。そのため、$U $ の効果をこの簡単な方法で記述できます。</span><span class="sxs-lookup"><span data-stu-id="8a543-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="8a543-126">必要に応じて、アルゴリズムは $R _1 (-m-シータ) $ を適用してコントロール qubit を回転させます。これにより、$ \ket{\psi} = \ left (R \_ 1 (m [\phi-\theta]) \ket{+} \ right) \ket{\phi} $ $ という状態が取得されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="8a543-127">のコントロールとして使用される補助 qubit `U(m)` は、1つのクラシックを取得するために $X $ 単位で測定され `Result` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="8a543-128">この時点で、 `Result` 反復フェーズ推定によって取得された値からフェーズを再構築することは、従来の統計的な推論の問題です。</span><span class="sxs-lookup"><span data-stu-id="8a543-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="8a543-129">修正された推論方法で得られた情報を最大限に活用する $m $ の値は、単に統計の問題です。</span><span class="sxs-lookup"><span data-stu-id="8a543-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="8a543-130">この問題を解決するために、キャノンで提供される統計アルゴリズムの説明に進む前に、ベイジアンパラメーターの推定形式の理論レベルで反復フェーズ推定を簡単に説明しました Q# 。</span><span class="sxs-lookup"><span data-stu-id="8a543-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="8a543-131">Eigenstates のない反復フェーズ推定</span><span class="sxs-lookup"><span data-stu-id="8a543-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="8a543-132">Eigenstate ではない入力状態が指定されている場合、たとえば $U (m) \ket{\phi \_ j} = e ^ {im/phi \_ j} $ の場合、フェーズ推定のプロセスによって、クォンタム状態が1つのエネルギー eigenstate に対して非決定的に指示されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="8a543-133">最終的に収束される eigenstate は、観測されたを生成する可能性が最も高い eigenstate です `Result` 。</span><span class="sxs-lookup"><span data-stu-id="8a543-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="8a543-134">具体的には、PE の1つのステップで、状態が \begin{align} \ sum_j \ sqrt{/pr (\ phi j)} \ket{\phi j}/map (\ phi j) に対して、次の非ユニタリ変換が実行されます。 \_ \_ \_ \_ } \ sqrt{\ Pr (\ text{result} | \ phi \_ j)} \Ket{\phi \_ j}} {\ sqrt{/pr (\ phi \_ j) \ sum \_ k \ pr (\ text{result} |/phi \_ k)}}</span><span class="sxs-lookup"><span data-stu-id="8a543-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_k \Pr(\text{Result}|\phi\_k)}}.</span></span>
<span data-ttu-id="8a543-135">\end{align} このプロセスは複数の値に対して反復処理さ `Result` れるため、$ \ prod_k \ Pr (\ text{result} k | \ phi j) $ の最大値を持たない eigenstates \_ \_ は指数関数的に抑制されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="8a543-136">その結果、推論プロセスは、実験が適切に選択された場合に、1つの eigenvalue を持つ状態に収束する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="8a543-137">Bayes ' 定理は、フェーズ推定の結果の状態が \begin{align} \frac{\sqrt{\Pr (\ phi \_ j)} \ sqrt{/Pr (\ text{result} | \ phi j)} \ket{\phi j}} {/sqrtという形式で記述されていることを示唆しています。 \_ \_ {/pr (\ phi \_ j) \ sum \_ j \ pr (\ text{result} | \ phi \_ j)}} = \ sum_j \ sqrt{/pr (\ phi \_ j | \ text{result})} \ket{\phi \_ j}。</span><span class="sxs-lookup"><span data-stu-id="8a543-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="8a543-138">\end{align} ここ $ \ Pr (\ phi \_ j |/text{result}) $ は、指定された eigenstates に関する各仮説に対して、ある確率として interpretted にすることができます。</span><span class="sxs-lookup"><span data-stu-id="8a543-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="8a543-139">測定前のクォンタムの状態に関する知識</span><span class="sxs-lookup"><span data-stu-id="8a543-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="8a543-140">$U $ との eigenstates の知識</span><span class="sxs-lookup"><span data-stu-id="8a543-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="8a543-141">$U $ の固有値の情報。</span><span class="sxs-lookup"><span data-stu-id="8a543-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="8a543-142">この3つのことを学習するのは、従来のコンピューターでは指数関数的に困難です。</span><span class="sxs-lookup"><span data-stu-id="8a543-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="8a543-143">フェーズの推定のユーティリティは、このようなクォンタムの学習タスクを何も知らずに実行できるという事実から、小さな範囲ではなくなります。</span><span class="sxs-lookup"><span data-stu-id="8a543-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="8a543-144">この理由のフェーズ推定は、指数高速化を提供するさまざまなクォンタムアルゴリズムの中で表示されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="8a543-145">ベイジアンフェーズの推定</span><span class="sxs-lookup"><span data-stu-id="8a543-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="8a543-146">実際のベイジアンフェーズ推定の詳細については、 [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) サンプルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a543-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="8a543-147">ベイジアンフェーズの推定の概念は単純です。</span><span class="sxs-lookup"><span data-stu-id="8a543-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="8a543-148">フェーズ推定プロトコルから測定統計を収集した後、ベイジアン推論を使用して結果を処理し、パラメーターの推定値を指定します。</span><span class="sxs-lookup"><span data-stu-id="8a543-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="8a543-149">この処理により、その推定値の推定値だけでなく、eigenvalue の推定値も得られます。</span><span class="sxs-lookup"><span data-stu-id="8a543-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="8a543-150">また、アダプティブ実験を実行し、前の情報を利用することもできます。</span><span class="sxs-lookup"><span data-stu-id="8a543-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="8a543-151">メソッドの原則としての欠点は、コンピューティングの要件が高いことです。</span><span class="sxs-lookup"><span data-stu-id="8a543-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="8a543-152">このベイジアン推論プロセスのしくみを理解するために、1つの結果を処理するケースを考えてみましょう `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="8a543-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="8a543-153">$X = \ket{+} \ ロウ {+}-\ket \bra $ であることに注意 {-} {-} してください。 $ \ket{+} $ は、に対応する $X $ の唯一の正の eigenstate です `Zero` 。</span><span class="sxs-lookup"><span data-stu-id="8a543-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="8a543-154">入力状態が $ \ket{\psi}\ket{\phi} $ であることを指定して、最初の qubit の測定を観察する確率は、 `Zero` $ $ です。 \ Pr (\texttt{Zero} | \ psi) = \ left | \braket{+ | \psi}/right | ^ 2 です。 [ `PauliX` ](xref:microsoft.quantum.concepts.pauli)</span><span class="sxs-lookup"><span data-stu-id="8a543-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="8a543-155">\ket{\psi} 反復フェーズ推定の場合は、$ = R_1 (m [\phi-\theta]) \ket{+} $ があります。この場合、\begin{align} \ Pr (\texttt{Zero} | \ phi; m, \ シータ) & = \ left |\braket{+ |R_1 (m [\phi-\theta]) |+} \ right | ^ 2 \\ \\ & = \ left | \frac12 \ left (\bra {0} + \bra {1} \ right) \ left (\ket {0} + e ^ {i m [\phi-\theta]} \ket/ {1} right) \ right | ^ 2 \\ \\ & = \ left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \ right | ^ 2 \\ \\ & = \ cos ^ 2 (m [\phi-\theta]/2) \ tag{★} \ label{eq:}。</span><span class="sxs-lookup"><span data-stu-id="8a543-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="8a543-156">\end{align} は、反復的なフェーズ推定は、決まる正弦波関数の振幅頻度を学習することで構成されます。これにより、コインをその sinusoid によって指定されたバイアスと反転させることができます。</span><span class="sxs-lookup"><span data-stu-id="8a543-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="8a543-157">従来の古典的な用語の後で、$ \eqref{eq: フェーズ-予測確率} $ を呼び出して、反復フェーズ推定の *尤度関数* を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8a543-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="8a543-158">`Result`反復フェーズの推定確率関数を観察した後、Bayes のルールを使用して、その観測に従っていると判断する必要があることを規定することができます。</span><span class="sxs-lookup"><span data-stu-id="8a543-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="8a543-159">具体的に、\ begin{\frac{\Pr} \ pr (-phi | d) = (d | \ phi) \ pr (\ phi)} {\ int \ pr (d | \ phi) \ pr (& phi) {\mathrm d} \phi}/pr (¥ phi)、\ end{ \\ \Texttt{Zero}, \texttt{One}} $ の場合は、\ end{,} \\ $ はで、$ \ `Result` Pr (\ phi) $ は以前の信条について説明します。 $d</span><span class="sxs-lookup"><span data-stu-id="8a543-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="8a543-160">これにより、反復フェーズ推定の反復的な性質が明示的になります。事後 distribution $ \ Pr (-phi | d) $ は、次の観測の直前にある信条について説明し `Result` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="8a543-161">この手順のどの時点でも、クラシックコントローラーによって推論されたフェーズ $ \hat{\phi} $ を、\hat{\phi} \mathrel{として報告できます。 =} \ 期待 [\ phi | \ text{data}] = \ int \ phi \ Pr (\ phi | \ text{data}) {\mathrm d}/phi, \ end{の場合、$ \ text{data} $ は取得されたすべての値のレコード全体を表し `Result` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="8a543-162">正確なベイジアン推論は、実際には困難です。</span><span class="sxs-lookup"><span data-stu-id="8a543-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="8a543-163">これを確認するには、$ bit 変数 $x $ $n を学習します。</span><span class="sxs-lookup"><span data-stu-id="8a543-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="8a543-164">以前のディストリビューション $ \ Pr (x) $ は $x $ の $ 2 ^ n $ 仮定値をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="8a543-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="8a543-165">つまり、$x $ の推定精度が高い場合、ベイジアンフェーズの推定には、膨大なメモリと処理時間が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="8a543-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="8a543-166">クォンタムシミュレーションなどの一部のアプリケーションでは、必要な limitted の精度によって、そのような方法では、Shor のアルゴリズムなどの他のアプリケーションでは、そのフェーズの推定手順で正確なベイジアン推論を使用できません。</span><span class="sxs-lookup"><span data-stu-id="8a543-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="8a543-167">このため、 [ランダムウォークフェーズの推定 (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) や、 [堅牢なフェーズの推定](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation)などの非ベイジアンアプローチについても、おおよそのベイジアンメソッドの実装を提供しています。</span><span class="sxs-lookup"><span data-stu-id="8a543-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="8a543-168">堅牢なフェーズの推定</span><span class="sxs-lookup"><span data-stu-id="8a543-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="8a543-169">測定結果からのフェーズの見積もりの *posteriori* ベイジアン再構築の最大数は、最悪の場合には指数関数的に難しくなります。</span><span class="sxs-lookup"><span data-stu-id="8a543-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="8a543-170">このため、ほとんどの実用的なフェーズ推定アルゴリズムでは再構築の一部の品質を犠牲にしています。これは従来の後処理の多くを反映しています。これにより、polynomially は、実行される測定値に応じてスケーリングされます。</span><span class="sxs-lookup"><span data-stu-id="8a543-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="8a543-171">このような従来の処理後の手順の例として、 [堅牢なフェーズ推定アルゴリズム](https://arxiv.org/abs/1502.02677)と、上記の署名と入力があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="8a543-172">この例では、入力の $U が $ $ が型としてパッケージ化されていることを前提 `DiscreteOracle` としています。したがって、制御された $U $ の整数の累乗のみをクエリします。</span><span class="sxs-lookup"><span data-stu-id="8a543-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="8a543-173">レジスタ内の入力状態 `Qubit[]` が eigenstate $U \ket{\psi} = e ^ {i\ phi} \ k {\ psi} $ の場合、堅牢なフェーズの推定アルゴリズムはとして $/phi $ の推定 $ \hat{\phi}\in [-\ pi, \ pi) を返し `Double` ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="8a543-174">堅牢なフェーズの推定の最も重要な機能は、他の多くの便利なバリエーションと共有されています。 $ \hat{\phi} $ の再構築の品質は、意味のあるハイゼンベルグに限定されています。</span><span class="sxs-lookup"><span data-stu-id="8a543-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="8a543-175">つまり、true 値から $ \hat{\phi} $ の偏差が $-シグマ $ の場合、$/シグマ $ はクエリの合計数に反比例しています。これは、制御された $U $ (つまり、$ \ シグマ = \mathcal{O} (1/Q) $) に対して作成された $Q クエリの合計数に比例します。</span><span class="sxs-lookup"><span data-stu-id="8a543-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="8a543-176">現在、偏差の定義は、異なる推定アルゴリズムによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8a543-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="8a543-177">場合によっては、$ \mathcal{O} (1) の確率が少なくとも、推定エラー $ | \hat{\phi}-\phi | \_ であることを意味することがあります。\circ\le、シグマ $、いくつかの循環メジャー $ \ circ $。</span><span class="sxs-lookup"><span data-stu-id="8a543-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="8a543-178">堅牢なフェーズの推定については、周期的な差異は、厳密には $-シグマ ^ 2 = \mathbb{E} \_ \hat{\phi} [( \_ -mod {2 \ pi} (\hat{\phi}-\phi +-pi)--pi) ^ 2] $ になります。これは、周期的なフェーズを1つの有限の間隔 $ (-\ pi, lt pi] $ にラップ</span><span class="sxs-lookup"><span data-stu-id="8a543-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="8a543-179">より正確に言えば、堅牢なフェーズの推定の標準偏差は、不等ず $ $ \begin{align} 2.0 \ pi/Q/\end{align} $ {n}/le 10.7 \ pi/Q, $ $ に適合します。下限は asymptotically large $Q $ の上限に達し、上限は小さいサンプルサイズでも保証されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="8a543-180">入力によって選択された $ $n、$Q $ を暗黙的に定義することに注意して `bitsPrecision` ください。</span><span class="sxs-lookup"><span data-stu-id="8a543-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="8a543-181">関連するその他の詳細には、たとえば、$1 $ ancilla qubit だけの小さな領域のオーバーヘッド、またはプロシージャが非アダプティブであることを意味します。つまり、必要なクォンタム実験のシーケンスは、中間測定結果に依存しません。</span><span class="sxs-lookup"><span data-stu-id="8a543-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="8a543-182">この後の例では、フェーズ推定アルゴリズムの選択が重要であるため、1つは、などのドキュメントと、その @"microsoft.quantum.characterization.robustphaseestimation" 実装に関する詳細情報と参照されるパブリケーションを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="8a543-183">堅牢なフェーズ推定を使用するサンプルは多数あります。</span><span class="sxs-lookup"><span data-stu-id="8a543-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="8a543-184">さまざまな物理システムのグラウンドステートエネルギーを抽出するフェーズの推定については、「 [ **H2 シミュレーション** のサンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)」、「 [ **simpleising** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)」、および「" [**モデルのモデル**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard)化" サンプルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a543-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="8a543-185">継続的 Oracles</span><span class="sxs-lookup"><span data-stu-id="8a543-185">Continuous Oracles</span></span> ###

<span data-ttu-id="8a543-186">また、前に使用した oracle モデルから汎用化して、キャノンの種類でモデル化された継続時間の oracles を実現することもでき <xref:Microsoft.Quantum.Oracles.ContinuousOracle> ます。</span><span class="sxs-lookup"><span data-stu-id="8a543-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="8a543-187">1つのユニタリ演算子ではなく $ $U、$U (t) U (s) $ = $U (t + s) $ のように、\mathbb{R} $ の $t \ の $U (t) $ の一連のユニタリ演算子を使用します。</span><span class="sxs-lookup"><span data-stu-id="8a543-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="8a543-188">これは、個別のケースよりも弱いステートメントです <xref:Microsoft.Quantum.Oracles.DiscreteOracle> \, 。固定の $ \ デルタ t $ に対して $t = m \ デルタ t $ を制限することによってを構築できるためです。</span><span class="sxs-lookup"><span data-stu-id="8a543-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="8a543-189">$U (t) = \ exp (i H t) $ in a operator $H $ ($ \ exp $ [は、](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups) [「高度なマトリックス](xref:microsoft.quantum.concepts.matrix-advanced)」で説明されているマトリックス指数)。</span><span class="sxs-lookup"><span data-stu-id="8a543-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="8a543-190">$H $ の eigenstate $ \ket{\phi} $ ($H \ket{\phi} = \ phi \ket{\phi} $ は、すべて $t $, \ begin{\ket{\phi}.} U (t) \ket{\phi} = e ^ {i \ phi t} に対して $U (t) $ という eigenstate も使用されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="8a543-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="8a543-191">\end{equation}</span></span>

<span data-ttu-id="8a543-192">[ベイジアンフェーズの推定](#bayesian-phase-estimation)について説明したのとまったく同じ分析を適用できます。また、尤度関数は、このより一般的な oracle モデルとまったく同じです。 $ $ \ Pr (\texttt{Zero} | + phi; t,-シータ) = \ cos ^ 2 \ left (\frac{t [\ phi--シータ]} {2} \ right)。</span><span class="sxs-lookup"><span data-stu-id="8a543-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="8a543-193">さらに、$ $ $U $ は、 [Hamiltonian シミュレーション](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)の場合と同様に、$/phi $ をエネルギーとして解釈します。</span><span class="sxs-lookup"><span data-stu-id="8a543-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="8a543-194">したがって、継続的なクエリでフェーズ推定を使用すると、$t $ を整数にする必要があるため、選択した実験を損なうことなく、分子、[マテリアル](https://arxiv.org/abs/1510.03859)、または[フィールド理論](https://arxiv.org/abs/1111.3633v2)のシミュレートされた[エネルギー](https://arxiv.org/abs/quant-ph/0604193)範囲を学習できます。</span><span class="sxs-lookup"><span data-stu-id="8a543-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="8a543-195">ランダムウォークフェーズの推定</span><span class="sxs-lookup"><span data-stu-id="8a543-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="8a543-196">Q# では、反復フェーズ推定から取得したデータレコードに対してランダムなウォークを行うことによって動作するクォンタムデバイスの近くに使用するように設計された、ベイジアンフェーズ推定についての実用的な概算を提供しています。</span><span class="sxs-lookup"><span data-stu-id="8a543-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="8a543-197">このメソッドは、アダプティブで完全に決定的であり、メモリオーバーヘッドが非常に少ない推定フェーズ $ \hat{\phi} $ でのエラーのほぼ最適化されたスケーリングを可能にします。</span><span class="sxs-lookup"><span data-stu-id="8a543-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="8a543-198">このプロトコルでは、前の分布がガウスであることを前提として、おおよそのベイジアン推論方法が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="8a543-199">このガウス想定では、事後 variance を最小にする実験に分析式を使用できます。</span><span class="sxs-lookup"><span data-stu-id="8a543-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="8a543-200">次に、その実験の結果に基づいて、$ + phi $ の見積もりを事前に決められた量だけ左または右にシフトし、事前に決められた量だけ分散を縮小します。</span><span class="sxs-lookup"><span data-stu-id="8a543-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="8a543-201">この平均と分散によって、次の実験で $/phi $ の前にガウスを指定するために必要なすべての情報が得られます。</span><span class="sxs-lookup"><span data-stu-id="8a543-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="8a543-202">予期しない測定エラーが発生した場合、または初期の前に true が発生した場合、このメソッドは失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="8a543-203">現在の平均と標準偏差がシステムに適しているかどうかをテストする実験を実行することで、障害から復旧します。</span><span class="sxs-lookup"><span data-stu-id="8a543-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="8a543-204">それ以外の場合、アルゴリズムはウォークの逆の手順を実行し、プロセスは続行されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="8a543-205">また、後方にステップ実行する機能により、初期の標準偏差が inapropriately 小さい場合でもアルゴリズムが学習できるようになります。</span><span class="sxs-lookup"><span data-stu-id="8a543-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="8a543-206">フェーズ推定アルゴリズムの呼び出し</span><span class="sxs-lookup"><span data-stu-id="8a543-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="8a543-207">キャノンによって提供される各フェーズの推定操作では、 Q# 最終的な推定値 $ \hat{\phi} $ から得られる品質をパラメーター化します。</span><span class="sxs-lookup"><span data-stu-id="8a543-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="8a543-208">ただし、これらのさまざまな入力では、複数の入力が共通に共有されるため、品質パラメーターに対する部分的なアプリケーションによって共通のシグネチャが生成されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="8a543-209">たとえば、次の <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> セクションで説明する操作には次のシグネチャがあります。</span><span class="sxs-lookup"><span data-stu-id="8a543-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="8a543-210">`bitsPrecision`入力はに固有で `RobustPhaseEstimation` あり、 `oracle` と `eigenstate` は共通です。</span><span class="sxs-lookup"><span data-stu-id="8a543-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="8a543-211">そのため、 **H2Sample** に示されているように、操作は、 `(DiscreteOracle, Qubit[]) => Unit` ユーザーが任意のフェーズ推定アルゴリズムを指定できるように、フォームの入力と共に反復フェーズ推定アルゴリズムを受け入れることができます。</span><span class="sxs-lookup"><span data-stu-id="8a543-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="8a543-212">これらの多様なフェーズの推定アルゴリズムは、さまざまなプロパティと入力パラメーターに対して最適化されています。これは、ターゲットアプリケーションに最適な選択を行うために理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a543-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="8a543-213">たとえば、一部のフェーズ推定アルゴリズムはアダプティブです。つまり、将来の手順は、前の手順の測定結果によってクラシックデプロイ制御されます。</span><span class="sxs-lookup"><span data-stu-id="8a543-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="8a543-214">一部の機能では、任意の実数の累乗によってブラックボックスの exponentiate を計算する機能が必要であり、他のユーザーは整数の累乗のみを必要としますが、フェーズ推定剰余 $ 2 \ pi $ のみを解決できます。</span><span class="sxs-lookup"><span data-stu-id="8a543-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="8a543-215">多くの補助 qubits が必要であり、他のユーザーには1つしか必要ありません。</span><span class="sxs-lookup"><span data-stu-id="8a543-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="8a543-216">同様に、ランダムウォークフェーズの推定の使用は、キャノンで提供される他のアルゴリズムとほぼ同じように行われます。</span><span class="sxs-lookup"><span data-stu-id="8a543-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
