---
title: '標準ライブラリ内のアプリケーション :::no-loc(Q#):::'
description: クォンタムコンピューティングの2つの基本的なアプリケーション (Hamiltonian シミュレーションと Shor の検索アルゴリズム) について説明します。
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 5a29dcc74c638cb8ecbeb1f924d0e50d40d19f66
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692164"
---
# <a name="applications"></a><span data-ttu-id="c17ab-103">アプリケーション</span><span class="sxs-lookup"><span data-stu-id="c17ab-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="c17ab-104">ハミルトニアン シミュレーション</span><span class="sxs-lookup"><span data-stu-id="c17ab-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="c17ab-105">クォンタムシステムのシミュレーションは、クォンタム計算の最も優れたアプリケーションの1つです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="c17ab-106">従来のコンピューターでは、クォンタム機構をシミュレートするのが困難です。一般に、ディメンション $N、その状態ベクトル表現の $ を使用してスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="c17ab-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="c17ab-107">この表現は $n $ qubits $N = 2 ^ n $ の数で指数関数的に増加するため、 [次元の curse](xref:microsoft.quantum.concepts.multiple-qubits)とも呼ばれる特徴は困難です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="c17ab-108">ただし、この状況は、quantum ハードウェアでは大きく異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="c17ab-109">クォンタムシミュレーションの最も一般的なバリエーションは、時間に依存しない Hamiltonian シミュレーションの問題と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="c17ab-110">ここには、Hermitian マトリックスである system Hamiltonian $H $ の説明と、クォンタムコンピューター上の $n $ qubits で何らかの基準としてエンコードされた初期クォンタム状態 $ \ket{\psi (0)} $ の説明が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="c17ab-111">Closed システムのクォンタム状態は、Schrödinger 式 $ $ \begin{align} i\ket{\psi {d (t)}} {d t} & = H \ket{\psi (t)} の下で進化しています。 \end{align} $ $ 目標は、\ket{\psi (t)} = U (t) \ket{\psi (0)} $ が Schrödinger の式を解決できるように、特定の時刻に (t) = e ^ {-iht} $ という $U (t) = e ^ {-iht} $ を実装することです。 $t</span><span class="sxs-lookup"><span data-stu-id="c17ab-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="c17ab-112">と同様は、時間に依存する Hamiltonian シミュレーションの問題は同じ方程式を解決しますが、$H (t) $ は time の関数になりました。</span><span class="sxs-lookup"><span data-stu-id="c17ab-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="c17ab-113">Hamiltonian のシミュレーションは、他の多くのクォンタムシミュレーションの問題の主要なコンポーネントであり、Hamiltonian シミュレーションの問題の解決策としては、おおよそのからに対するプリミティブなクォンタムゲートのシーケンスを示すアルゴリズムがあります。これは、 \\ \\ [スペクトル基準](xref:microsoft.quantum.concepts.matrix-advanced)でエラー $ | \tilde{U}-U (t) |/le/イプシロン $ を使用します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="c17ab-114">これらのアルゴリズムの複雑さは、対象の Hamiltonian の説明が quantum コンピューターからアクセスできるようにする方法に非常に大きく依存しています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="c17ab-115">たとえば、最悪の場合、$n $ qubits の $H $ が $ 2 ^ n/times 2 ^ n $ n $ number のリストとして指定された場合 (各マトリックス要素に1つ)、単にデータを読み取るだけで、既に指数関数が必要になります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="c17ab-116">最良のケースでは、\ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ が問題を解決できるように、ブラックボックスのユニタリにアクセスする $O ことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="c17ab-117">これらの入力モデルはいずれも特に興味深いものではありません。従来のアプローチよりも優れていません。後者の場合は、その実装のプリミティブゲートの複雑さが隠されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="c17ab-118">Hamiltonians の説明</span><span class="sxs-lookup"><span data-stu-id="c17ab-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="c17ab-119">そのため、入力の形式に関する追加の前提条件が必要です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="c17ab-120">実際の物理システムや興味深い計算の問題の場合や、量子コンピューターで効率的に実装できるように十分に制限されている入力モデルなど、興味深い Hamiltonians を含む入力モデルの場合は、細かいバランスを取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="c17ab-121">この資料には、さまざまな簡単な入力モデルが含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="c17ab-122">クォンタム入力モデルの例として、 [サンプルベースの Hamiltonian シミュレーション](http://www.nature.com/articles/s41534-017-0013-7) は、密度マトリックス $ \rho $ のコピーを生成するクォンタム操作へのブラックボックスアクセスを想定しています。これは、Hamiltonian $H $ として使用されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="c17ab-123">[ユニタリアクセスモデル](https://arxiv.org/abs/1202.5822)では、Hamiltonian ではなく、unitaries $ $ \begin{align} H & = \ sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $a $ として、分解され \_ j>$0 が係数、$ \hat{U} \_ j $ は unitaries います。</span><span class="sxs-lookup"><span data-stu-id="c17ab-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="c17ab-124">次に、1つのには、必要な $ \hat{U} j $ を選択する、\ket{j}\bra{j}\otimes = \ sum ^ {d-1} {j = 0} \hat{U} j $ という、1つのブラックボックスへ $V のアクセスがあることを前提としています。 \_ \_ \_ oracle $A \ket {0} = \ sum ^ {d-1} \_ {j = 0} \ sqrt{j \_ /\ sum ^ {d-1} \_ {k = 0} \ alpha \_ j} \ket{j} $ は、これらの係数をエンコードするクォンタム状態を作成します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="c17ab-125">[スパース Hamiltonian シミュレーション](https://arxiv.org/abs/quant-ph/0301023)の場合、1つは、Hamiltonian がすべての行で $d = \mathcal{O} (\Text{polylog} (N)) $ 0 以外の要素のみを含むスパースマトリックスであることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="c17ab-126">さらに、これらのゼロ以外の要素の場所とその値を出力する効率的なクォンタム回線があることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="c17ab-127">[Hamiltonian シミュレーションアルゴリズム](xref:microsoft.quantum.more-information)の複雑さは、これらのブラックボックスに対するクエリ数の観点で評価されます。プリミティブゲートの複雑さは、これらの黒いボックスを実装する難しさに大きく依存します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="c17ab-128">ビッグ I/o 表記は、アルゴリズムの複雑さのスケーリングを説明するためによく使用されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="c17ab-129">2つの実関数 $f g $ では、式 $g (x) = \mathcal{O} (f (x)) $ は、 \_ すべての $0 $g に対して $x (x) \ le c f (x) $ が使用されるように、正の正の定数 $x 0、c>$0 が存在することを意味し \_ ます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="c17ab-130">クォンタムコンピューターに実装するほとんどの実用的なアプリケーションでは、これらのブラックボックスは、$ \mathcal{O} (\text{polylog} (N)) $ プリミティブ量子ゲートを使用して、効率的に実装できなければなりません。</span><span class="sxs-lookup"><span data-stu-id="c17ab-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="c17ab-131">より厳密で効率的に simulable Hamiltonians には、古典的な従来の説明が十分にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="c17ab-132">このような定式化では、Hamiltonian 分解されが Hermitian parts $ $ \begin{align} H & = \ sum ^ {d-1} _ {j = 0} H_j の合計になると想定されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="c17ab-133">\end{align} $ $ では、Hamiltonian $H j $ の各部分は簡単にシミュレートできると想定されてい \_ ます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="c17ab-134">これは、すべての時間に対して、$e ^ {-iH \_ j t} $ が $t $ \mathcal{O} (1) $ プリミティブ量子ゲートを使用して正確に実装できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="c17ab-135">たとえば、これは特殊なケースでは、各 $H \_ j $ がローカルの P\mathcal{O} li 演算子であることを意味します。つまり、空間的な終値で動作する $ (1) $ 非 Id p li 演算子のすべての製品であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="c17ab-136">このモデルは、条件の数が $d = \mathcal{O} (\text{polylog} (N)) $ であるため、制限されたローカルの相互作用を持つ物理システムに特に適用されます。また、クラシックデプロイについて説明されているように、多項式時間で明確に記述することもできます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="c17ab-137">パートの合計に分解する Hamiltonians は、Dynamical Generator 表現ライブラリを使用して記述できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="c17ab-138">詳細については、「Dynamical Generator 表現」の「 [データ構造](xref:microsoft.quantum.libraries.data-structures)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="c17ab-139">シミュレーションアルゴリズム</span><span class="sxs-lookup"><span data-stu-id="c17ab-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="c17ab-140">クォンタムシミュレーションアルゴリズムでは、Hamiltonian の指定された説明を、Hamiltonian と呼ばれるおおよその時間の推移的な一連のプリミティブクォンタムゲートに変換します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="c17ab-141">Hamiltonian 分解されが Hermitian パーツの合計になる特殊なケースでは、Trotter-Suzuki 分解は、Hermitian コンポーネントの合計に分解される Hamiltonians をシミュレートするための、特にシンプルで直感的なアルゴリズムです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="c17ab-142">たとえば、このファミリのファーストオーダーインテグレーターは、$ $ \begin{align} U (t) & = \ left (e ^ {-iH 0 t/r} \_ e ^ {-ih \_ 1 t/r}/cドット e ^ {-ih \_ {d-1} t/r} \ right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ |H \_ j \\ | ^ 2 t ^ 2/r)、\end{align} $ $ を使用して $r d $ terms の製品を使用します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="c17ab-143">サンプルでは、Trotter-Suzuki シミュレーションアルゴリズムのアプリケーションについて説明します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="c17ab-144">各ターゲットコンピューターによって提供される組み込み操作のみを使用する場合は、 [ **simpleising** サンプル](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="c17ab-145">Trotter-Suzuki library コントロール構造を使用した表示モデルについては、 [ **IsingTrotter** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="c17ab-146">Trotter-Suzuki library コントロール構造を使用した分子 Hydrogen については、「 [ **H2 シミュレーション** のサンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="c17ab-147">多くの場合、シミュレーションアルゴリズムを実装する必要がありますが、その実装の詳細には関心がありません。</span><span class="sxs-lookup"><span data-stu-id="c17ab-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="c17ab-148">たとえば、2番目の命令インテグレーターは、$ $ \begin{align} U (t) & = \ left (e ^ {-iH \_ 0 t/2r} e ^ {-ih \_ 1 t/2r}/cドット e ^ {-ih \_ {d-1} t/2r} を近似します。 e ^ {-ih \_ {d-1} t/2r} \ cドット e ^ {-ih \_ 1 t/2r} e ^ {-ih \_ 0 t/2r} \ 右) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ |H \_ j \\ | ^ 3 t ^ 3/r ^ 2)、$ 2rd $ terms の製品を使用する \end{align} $ $。</span><span class="sxs-lookup"><span data-stu-id="c17ab-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="c17ab-149">注文が大きいほど、さらに多くの用語と最適化されたバリエーションが必要になることがあります。その場合、指数には非常に重要な順序が必要になります</span><span class="sxs-lookup"><span data-stu-id="c17ab-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="c17ab-150">他の高度なアルゴリズムでは、中間ステップで ancilla qubits を使用することが必要になる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="c17ab-151">そのため、ユーザー定義型として、キャノンのシミュレーションアルゴリズムをパッケージ化します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="c17ab-152">最初のパラメーターは `Double` シミュレーションの時間で、データ構造の Dynamical Generator 表現セクションに記載されている2番目のパラメーターは、 `EvolutionGenerator` 時間に依存しない Hamiltonian の典型的な説明であり、Hamiltonian の各用語は、クォンタム回線によってシミュレートされる方法についての指示と共にパッケージ化されます。 [data-structures](xref:microsoft.quantum.libraries.data-structures)</span><span class="sxs-lookup"><span data-stu-id="c17ab-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="c17ab-153">このフォームの型では、3番目のパラメーターに対して、( `Qubit[]` シミュレートされたシステムのクォンタムの状態を格納するレジスタである) 3 番目のパラメーターに対して、$e におおよその単位が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="c17ab-154">時間に依存する場合と同様に、ユーザー定義型は `EvolutionSchedule` 、時間に依存する Hamiltonian の従来の説明である型を使用して定義します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="c17ab-155">例として、Trotter-Suzuki 分解は次のキャノン関数を使用して呼び出すことができます。パラメーターを使用すると、 `trotterStepSize` 各指数のシミュレーションの期間と、 `trotterOrder` 目的のインテグレーターの順序を変更できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="c17ab-156">シミュレーションライブラリのアプリケーションについては、「」のサンプルで説明されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="c17ab-157">を使用した表示モデルのフェーズ推定については `SimulationAlgorithm` 、 [ **IsingPhaseEstimation** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="c17ab-158">を使用した adiabatic モデルでの状態の準備の詳細について `TimeDependentSimulationAlgorithm` は、 [ **AdiabaticIsing** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="c17ab-159">Adiabatic 状態の準備 & フェーズの推定</span><span class="sxs-lookup"><span data-stu-id="c17ab-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="c17ab-160">Hamiltonian シミュレーションの1つの一般的なアプリケーションは、adiabatic 状態の準備です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="c17ab-161">ここでは、2つの Hamiltonians $H \_ {\ text{startno} $ と $H \_ {\ text{endno} $ と、start Hamiltonian $H \_ {\ text{start{1}} $ のグラウンド状態であるクォンタム状態 $ \ket{\psi (0)} $ を使用して提供されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="c17ab-162">通常、$H \_ {\ text{startno} $ が選択されているため、$ \ket{\psi (0)} $ はコンピューティングベースの状態 $ \ket{0\cdots 0} $ から簡単に準備できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c17ab-163">時間に依存するシミュレーションの問題でこれらの Hamiltonians 間を補間することによって、最終的な Hamiltonian $H \_ {\ text{end{2} $ の最上位の状態になる可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="c17ab-164">Hamiltonian のグランド州に対して十分な概算を準備することで、時間に依存する Hamiltonian シミュレーションアルゴリズムでサブルーチンとしてを呼び出すことによって、この方法で処理を進めることができますが、その他の概念的に異なる手法 eigensolver などが考えられます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="c17ab-165">しかし、量子化学に存在する別のアプリケーションは、化学の反応の中間手順を表す Hamiltonians のグラウンドステートエネルギーを推定することです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="c17ab-166">たとえば、このようなスキームでは、adiabatic 状態の準備に依存してグラウンド州を作成し、時間に依存しない Hamiltonian シミュレーションをフェーズ推定の特性のサブルーチンとして組み込んで、有限のエラーと成功の確率でこのエネルギーを抽出できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="c17ab-167">シミュレーションアルゴリズムをユーザー定義型として抽象化し、その `SimulationAlgorithm` `TimeDependentSimulationAlgorithm` 機能をより高度なクォンタムアルゴリズムに簡単に組み込むことができるようにします。</span><span class="sxs-lookup"><span data-stu-id="c17ab-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="c17ab-168">これは、一般的に使用されるサブルーチンに対して同じことをためします。</span><span class="sxs-lookup"><span data-stu-id="c17ab-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="c17ab-169">そのため、便利な関数を定義します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="c17ab-170">これにより、adiabatic 状態準備のすべてのステップを実装する、ユニタリ操作が返されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="c17ab-171">最初のパラメーターは、 `interpolatedTime` 2 番目のパラメーターによって記述される開始 Hamiltonian `evolutionGeneratorStart` と3番目のパラメーターによって記述される end Hamiltonian との間で線形に補間を補間する時間を定義し `evolutionGeneratorEnd` ます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="c17ab-172">4番目のパラメーターで `timeDependentSimulationAlgorithm` は、シミュレーションアルゴリズムを選択します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="c17ab-173">`interpolatedTime`が十分に長い場合、初期のグラウンド状態は、時間に依存するシミュレーションの期間全体にわたって Hamiltonian の瞬時の接地状態を維持するため、終了 Hamiltonian のグラウンドの状態で終了します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="c17ab-174">また、一般的な量子化学実験のすべての手順を自動的に実行する便利な操作も定義します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="c17ab-175">たとえば、次のものがあります。これにより、adiabatic 状態の準備によって生成された状態のエネルギー見積もりが返されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="c17ab-176">`nQubits` クォンタムの初期状態をエンコードするために使用される qubits の数です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="c17ab-177">`statePrepUnitary` 計算基準 $ \ket{0\cdots 0} $ から開始状態を準備します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c17ab-178">`adiabaticUnitary` は、関数によって生成されるように、adiabatic 状態の準備を実装する、ユニタリ操作です  `InterpolatedEvolution` 。</span><span class="sxs-lookup"><span data-stu-id="c17ab-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="c17ab-179">`qpeUnitary` 結果として得られるクォンタムの状態に対してフェーズ推定を実行するために使用される、ユニタリ操作です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="c17ab-180">`phaseEstAlgorithm` フェーズ推定アルゴリズムを選択します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="c17ab-181">Adiabatic の状態準備のアプリケーションについては、「」のサンプルで説明されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="c17ab-182">Adiabatic 状態の準備と関数の使用を手動による実装を使用している場合は、 `AdiabaticEvolution` [ **AdiabaticIsing** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="c17ab-183">Adiabatic モデルでのフェーズの推定と状態の準備については、 [ **IsingPhaseEstimation** サンプル](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ab-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="c17ab-184">[分子 Hydrogen のシミュレーション](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)は、興味深い簡単なサンプルです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="c17ab-185">O'Malley で報告されるモデルと実験結果 [。](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="c17ab-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="c17ab-186">に必要なのは、Pの Li マトリックスだけで、$ \ hat H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z 1} + g \_ \_ 4 {y 0} { \_ y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $ です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="c17ab-187">これは、2つの Hydrogen アトムの間の距離 $R $ から計算される定数 $g $ が2つの qubits のみを必要とする有効な Hamiltonian です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="c17ab-188">キャノン関数を使用すると、Paulis は unitaries 変換され、Trotter-Suzuki 分解を使用して短時間に進化します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="c17ab-189">_2 $ グラウンドの状態に $H 対しては、adiabatic 状態の準備を使用せずに作成することができます。そのため、キャノンからのフェーズの推定を利用して、グラウンドの状態エネルギーを直接見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="c17ab-190">Shor のアルゴリズム</span><span class="sxs-lookup"><span data-stu-id="c17ab-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="c17ab-191">Shor のアルゴリズムは、quantum コンピューターを使用して重要なクラシックデプロイ困難問題を解決できることを示しているため、クォンタムコンピューティングにおける最も重要な開発の1つです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="c17ab-192">Shor のアルゴリズムは、量子コンピューターを使用して大きな数値を因数分解するための高速な方法を提供します。これは *ファクタリング* と呼ばれる問題です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring* .</span></span>
<span data-ttu-id="c17ab-193">現在の日常的な暗号システムのセキュリティは、ファクタリングのための高速アルゴリズムが存在しないという前提に基づいています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="c17ab-194">そのため、シャードまたはのアルゴリズムは、クォンタム後の世界におけるセキュリティに対する考え方に大きな影響を与えていました。</span><span class="sxs-lookup"><span data-stu-id="c17ab-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="c17ab-195">Shor のアルゴリズムは、ハイブリッドアルゴリズムと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="c17ab-196">クォンタムコンピューターは、期間検索と呼ばれる計算ハードタスクを実行するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="c17ab-197">次に、期間を検索した結果がクラシックデプロイに処理され、係数が算出されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="c17ab-198">次の2つの手順を確認します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="c17ab-199">期間の検索</span><span class="sxs-lookup"><span data-stu-id="c17ab-199">Period Finding</span></span> ###

<span data-ttu-id="c17ab-200">クォンタムのフーリエの変革とフェーズの推定がどのように動作するかを見てきました (「 [クォンタムアルゴリズム](xref:microsoft.quantum.libraries.standard.algorithms)」を参照)。これらのツールを使用して、 *期間検索* と呼ばれるクラシックデプロイハード計算の問題を解決できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding* .</span></span>  <span data-ttu-id="c17ab-201">次のセクションでは、期間の検索をファクタリングに適用する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="c17ab-202">$ と $N $ $a 2 つの整数が指定されています。ここで $a<N $ の場合は、期間を検索することを目標と _してい_ ます。 n $ の場合、$r $ は $a $ {mod {Mod} N $ の最小正の整数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="c17ab-203">クォンタムコンピューターを使用して注文を検索するには、次の数値演算に適用されているフェーズ推定アルゴリズムを使用できます。 $U _a $: $ $ U_a \ket{x} \equiv \ket{(ax) \ text{mod} N}。 $ $ $U の固有ベクトルは、整数 _a $ および $ 0 \ $1 leq になります。 $ $ \ket{x_s} \equiv 1/\ sqrt{r} \ sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i sk} {r}} \ket{a ^ k\ text {mod} N}、$ $ は $U _a $ の _eigenstates_ です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="c17ab-204">$U _a $ の固有値は $ $ U \_ a \ket{x \_ s} = e ^ {2 \ pi i s/r} \ket{x \_ s} です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="c17ab-205">フェーズの推定では、固有値 $e ^ {2 \ pi i s/r} $ が出力されます。この場合、$r $ は $s/r $ の [継続分数](https://en.wikipedia.org/wiki/Continued_fraction) を使用して効率的に学習できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="c17ab-206">クォンタム期間を検索するためのサーキットダイアグラムは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="c17ab-206">The circuit diagram for quantum period finding is:</span></span>

![クォンタム期間の検索のサーキットダイアグラム](~/media/QPE.svg)

<span data-ttu-id="c17ab-208">$ 2n $ qubits は $ \ket $ に初期化され {0} $n、$ qubits は $ \ket $ に初期化され {1} ます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c17ab-209">また、このリーダーは、eigenstates を保持するクォンタムレジスタが $ \ket $ に初期化される理由を気にする可能性があります {1} 。</span><span class="sxs-lookup"><span data-stu-id="c17ab-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c17ab-210">$R $ の順序が事前にわからないため、実際には $ \ket{x_s} $ の状態を直接準備することはできません。</span><span class="sxs-lookup"><span data-stu-id="c17ab-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="c17ab-211">さいわい、$ 1/\ sqrt {r} \ sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket $ ということがわかりました {1} 。</span><span class="sxs-lookup"><span data-stu-id="c17ab-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="c17ab-212">実際に $ \ket{x} $! を準備する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c17ab-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="c17ab-213">状態が $ \ket $ の $n $ qubits のクォンタムレジスタを準備するだけで済み {1} ます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="c17ab-214">回路には、QFT および複数の制御されたゲートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="c17ab-215">QFT ゲートについては [既](xref:microsoft.quantum.libraries.standard.algorithms)に説明しました。</span><span class="sxs-lookup"><span data-stu-id="c17ab-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="c17ab-216">制御された $U _a $ gate マップ $ \ket{x} $ to $ \ket{(ax) \ text{mod} N} $ (コントロール qubit が $ \ket {1} $ の場合)。それ以外の場合は $ \ket{x} $ を $ \ket{x} $ にマップします。</span><span class="sxs-lookup"><span data-stu-id="c17ab-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="c17ab-217">$ (A ^ nx) \ text{mod} N $ を実現するには、制御された $U _ {a ^ N} $ を適用します。ここで、$a ^ n \ text{mod} N $ クラシックデプロイを計算して、quantum 回線に接続します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="c17ab-218">このようなモジュール式を実現する回路は、「 [クォンタム算術ドキュメント](./algorithms.md#arithmetic)」で説明されています。具体的には、制御された $U \_ {a ^ i} $ 操作を実装するには、モジュール式の累乗回路が必要です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="c17ab-219">上記の回線は [クォンタムフェーズ推定](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) に対応しており、順序の検索を明示的に有効にすると、必要な qubits の数を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="c17ab-220">[ArXiv: quant-ph/0205095v3 のページ8で](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)説明されているように、Beauregard の方法に従うか、または Microsoft の Quantum で利用可能なフェーズの推定ルーチンの1つを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="c17ab-221">たとえば、 [堅牢なフェーズの推定](xref:microsoft.quantum.characterization.robustphaseestimation) では、1つの追加の qubit も使用します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="c17ab-222">取り入れる</span><span class="sxs-lookup"><span data-stu-id="c17ab-222">Factoring</span></span> ###
<span data-ttu-id="c17ab-223">要素をファクタリングする目的は、$ $N 整数の2つの素要因を決定することです。 $ は、$ ビットの $n で $N $ です。</span><span class="sxs-lookup"><span data-stu-id="c17ab-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="c17ab-224">ファクタリングは、以下で説明する手順で構成されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="c17ab-225">これらの手順は、クラシック前処理ルーチン (1-4) という3つの部分に分かれています。$a \ text{mod} N $ (5) の順序を検索するためのクォンタムコンピューティングルーチン。また、従来の後処理ルーチンを通じて、順序から素数を導き出します (6-9)。</span><span class="sxs-lookup"><span data-stu-id="c17ab-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="c17ab-226">従来の前処理ルーチンは、次の手順で構成されています。</span><span class="sxs-lookup"><span data-stu-id="c17ab-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="c17ab-227">$N $ が偶数の場合は、素数 $2 $ を返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="c17ab-228">$N = p ^ q $ for $p \ geq1 $、$q-geq2 $ の場合は、素数 $p $ を返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="c17ab-229">このステップはクラシックデプロイに実行されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-229">This step is performed classically.</span></span>
3. <span data-ttu-id="c17ab-230">$1 < a < N-$1 である $a $ の乱数を選択します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="c17ab-231">$ \ Text{gcd} (a, N) >$1 の場合は、素数 $ \ text{gcd} (a, N) $ を返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="c17ab-232">このステップは、互除法のアルゴリズムを使用して計算されます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="c17ab-233">素数が返されない場合は、クォンタムルーチンに進みます。</span><span class="sxs-lookup"><span data-stu-id="c17ab-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="c17ab-234">クォンタム期間検索アルゴリズムを呼び出して、$r $ of $a \ text{mod} N $ の順序を計算します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="c17ab-235">従来の後処理ルーチンで $r $ を使用して、主な要因を決定します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="c17ab-236">$R $ が奇数の場合は、前処理手順 (3) に戻ります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="c17ab-237">$R $ が偶数で $a ^ {r/2} =-1 \ text {mod} N $ の場合は、前処理手順 (3) に戻ります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="c17ab-238">$ \ Text{gcd} (a ^ {r/2} + 1, N) $ が $N $ の重要な要素ではない場合、$-text{gcd} (a ^ {r/2} + 1, N) $ を返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="c17ab-239">$ \ Text{gcd} (a ^ {r/2}-1, N) $ が $N $ の重要な要素ではない場合、$-text{gcd} (a ^ {r/2}-1, N) $ を返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="c17ab-240">ファクタリングアルゴリズムは確率論的です。これには、確率が少なくとも1つ含まれています。これは $r $ が偶数であることを示し、^ {r/2} \ neq-1 \ text{mod} N $ を $a して、素数を生成します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="c17ab-241">(詳細については、 [Shor のオリジナルペーパー](https://doi.org/10.1109/SFCS.1994.365700)を参照してください [。詳細に](xref:microsoft.quantum.more-information)ついては、「」の *基本的なクォンタム計算* テキストのいずれかを参照してください)。</span><span class="sxs-lookup"><span data-stu-id="c17ab-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="c17ab-242">素数が返されない場合は、単に手順 (1) からアルゴリズムを繰り返します。</span><span class="sxs-lookup"><span data-stu-id="c17ab-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="c17ab-243">$ 試行を $n た後、すべての試行が失敗した確率は、最大で $ 2 ^ {-n} $ になります。</span><span class="sxs-lookup"><span data-stu-id="c17ab-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="c17ab-244">したがって、アルゴリズムを繰り返しても、成功する回数はほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="c17ab-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
