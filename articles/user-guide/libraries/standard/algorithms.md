---
title: Q でのクォンタムアルゴリズム#
description: 振幅増幅、フーリエ変換、Draper、Beauregard adders、フェーズの推定など、基本的なクォンタムコンピューティングアルゴリズムについて説明します。
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 7f4916353c53d6459356243098281ccb16b17278
ms.sourcegitcommit: cdf67362d7b157254e6fe5c63a1c5551183fc589
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/21/2020
ms.locfileid: "86871316"
---
# <a name="quantum-algorithms"></a>クォンタムアルゴリズム #

## <a name="amplitude-amplification"></a>振幅増幅 ##

*振幅増幅*は、クォンタムコンピューティングの基本的なツールの1つです。 これは、Grover の検索、振幅推定、および多くのクォンタム機械学習アルゴリズムを基盤とする基本的なアイデアです。  さまざまなバリエーションがあります。 Q # では、無関係の振幅増幅に基づいて、部分的な反射を持つ一般的なバージョンを提供し、最も広い範囲のアプリケーションを可能にします。

振幅増幅の背後にある中心となる考え方は、一連の反射を行うことによって、目的の結果が発生する確率を増幅することです。  これらの反射は、初期状態を目的の状態 (マークされた状態と呼ばれることもあります) の近くに向かって回転させます。  具体的には、初期状態がマーク付きの状態になる確率が $ \ sin ^ 2 (-シータ) $ である場合、振幅増幅を適用した後 $m $/sin ^ 2 ((2m + 1) \ シータ) $ になります。  これは、$ \ シータ = \ pi/[2 (2n + 1)] $ $n の値がある場合に $ を使用すると、振幅増幅の $n $ の反復処理の後、成功の確率を $100% $ に上げることができることを意味し \\ ます。  $ \ シータ = \ sin ^ {-1} (\ sqrt{/Pr (success)}) $ であるため、成功を取得するために必要なイテレーションの数は、ランダムサンプリングを使用して、非確定的としてマークされた状態を検出するために必要な数よりも quadratically 低くなります。

振幅増幅の各反復処理では、2つのリフレクション演算子が指定されている必要があります。 具体的には、$Q $ が振幅増幅で反復処理され、$P 0 $ がプロジェクターの最初のサブ空間にあり、$P _1 $ がプロジェクターのマークされたサブ $Q 空間にある場合は、=-(\ bold one-2P_0) (\ bold 完了-2P_1) $ となります。  プロジェクターは Hermitian 演算子であり、固有値 $ + $1 および $0 $ があることを思い出してください。 $ () $ は、unity (この場合は $ pm $1) のルートである固有値を持つため、その結果として $ (\ bold 完了-2P_0) $ になります。 例として、Grover の search が初期状態 $H ^ {\ otimes n} \ket $ で、状態が $ \ket{m} $P $ とマークされている場合を考えてみます。この場合は、 {0} \ket {0} \bra {0} h ^ {\ otimes n} $ と $P _1 = \ket{m}\bra{m} $ というマークが付いています。  ほとんどのアプリケーションでは、$P 0 $ はプロジェクターの初期状態になります。これは、一部の vector $ \ket{\psi} $; に対して $P 0 = k {\ psi} $ が設定されていることを意味します。ただし、無関係振幅 $P amplication では、通常、0 $ は多くのクォンタム状態に投影されます (つまり、$ + $1 eigenvalue of $P 0 $ の複数要素の接続性は $1 $ を超えています)。

振幅増幅の背後にあるロジックは、$Q $ の eigen 分解から直接たどります。  具体的には、初期状態がゼロ以外のサポートを持つ $Q $ の固有ベクトルは、$P 0 $ と $P _1 $ の $ + $1 固有ベクトルの線形組み合わせとして表示できます。  具体的には、振幅増幅の初期状態 ($P の $ + $1 eigenvector) は、$ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \ left (e ^ {i\ シータ} \ k {\ psi_ +} + e ^ {-ik} \ {\ psi_-}/right) として記述できます。 $ $ where $ \ket{\ psi_ \ pm} $ は $Q $ と固有値 $e ^ {/pm 2i \ シータ} $ で、$ + $1 固有ベクトル (0 $ および $P _1 $) でのみサポートされています。 $P  固有値が $e ^ {\ pm i > $ の場合、演算子 $Q $ は、2つのプロジェクターによって指定された2次元のサブ空間で回転を実行し、回転角度が $ 2 \ シータ $ である初期状態を意味します。  このため、$ iteration $m $ iteration $Q $ の成功確率は $ \ sin ^ 2 ([2m + 1] \ シータ) $ です。

このようなもう1つの便利なプロパティとして、eigenvalue $/シータ $ は、初期状態がマークされる確率に直接関係しています ($P 0 $ がプロジェクターを初期状態にする場合)。  $Q $ の eigenphases は $ 2 \ シータ = 2 \ sin ^ {-1} (\ sqrt{/Pr (success)}) $ であるため、次のようにします。これは、$Q $ にフェーズの推定を適用した場合に、その処理が完了する確率を調べることができることを示しています。  これは、それ以外の場合に必要な成功の確率を知るために、クォンタムプロシージャの quadratically を減らす必要があるため便利です。

Q # では、無関係の振幅増幅の特殊化として振幅増幅が導入されています。  無関係の振幅増幅は、初期状態でプロジェクターを使用する必要がないため、このモニカーを獲得します。  この意味では、プロトコルは初期状態に無関係ます。  無関係の振幅増幅の重要なアプリケーションは、初期状態が不明であるものの、シミュレーションプロトコルで ancilla レジスタを使用してありになる、ユニタリ Hamiltonian シミュレーションメソッド*の線形組み合わせ*です。  この ancilla register が固定値 ($0 $ など) として測定された場合、このシミュレーションメソッドは、必要なユニタリ変換を残りの qubits (システムレジスタと呼びます) に適用します。  それ以外のすべての測定結果は失敗につながります。  無関係の振幅増幅を使用すると \\ 、上記の理由を使用して、この測定値の成功率を $100% $ に上げることができます。  さらに、通常の振幅増幅は、システムレジスタが空の場合に相当します。  このため、Q # は無関係の振幅増幅を基本的な振幅増幅のサブルーチンとして使用します。

一般ルーチン ( `AmpAmpObliviousByReflectionPhases` ) には、とを呼び出す2つのレジスタがあり `ancillaRegister` `systemRegister` ます。 また、必要な反射に対して2つの oracles も受け入れます。 は `ReflectionOracle` 、に対してのみ機能しますが、は `ancillaRegister` `ObliviousOracle` 両方のレジスタに連携します。 への入力は、 `ancillaRegister` 最初のリフレクション演算子 $-2P_1 $ の-1 eigenstate に初期化する必要があります。

通常、oracle はコンピューティングベース $ \ket{0...0} $ で状態を準備します。 この実装では、 `ancillaRegister` と、必要な ancillas の残りの部分を制御する1つの qubit ( `flagQubit` ) のように `stateOracle` なります。 `stateOracle`が $ \ket $ の場合は、が適用され `flagQubit` {1} ます。

また、の呼び出しに `StateOracle` よって、反射ではなく oracles を提供する場合もあり `ObliviousOracle` `AmpAmpObliviousByOraclePhases` ます。

前述のように、従来の振幅増幅は、これらのルーチンの特殊なケースにすぎ `ObliviousOracle` ません。が id 演算子であり、システム qubits (つまり、が空) ではありません `systemRegister` 。 部分的な反射 (Grover 検索など) のフェーズを取得する場合は、関数を `AmpAmpPhasesStandard` 使用できます。 `DatabaseSearch.qs`Grover のアルゴリズムの実装例については、「」を参照してください。

この記事では、 [G.H. Low, 語](https://arxiv.org/abs/1707.05391)によって説明されているように、単一の qubit 回転フェーズをリフレクション演算子フェーズに関連付けています。 使用されている固定ポイントフェーズは、[語、低、および](https://arxiv.org/abs/1409.3305)語の各フェーズと共に、最低でも[Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996)でも詳しく説明しています。

背景については、[標準の振幅増幅](https://arxiv.org/abs/quant-ph/0005055)から開始し、無関係の[振幅増幅](https://arxiv.org/abs/1312.1414)の概要に進み、最後に[低と語](https://arxiv.org/abs/1610.06546)で示されている一般化を行うことができます。 この領域全体 (Hamiltonian シミュレーションに関連する) のわかりやすい概要が[Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)によって提供されています。

## <a name="quantum-fourier-transform"></a>クォンタムフーリエ変換 ##

フーリエ変換は、古典的な分析の基本ツールであり、クォンタムの計算において非常に重要です。
さらに、 *quantum のフーリエ変換*(qft) の効率が、クォンタムアルゴリズムを設計するときに選択する最初のツールの1つとして、従来のコンピューターで可能なことをはるかに上回ります。

QFT のおおよその汎化として、 <xref:microsoft.quantum.canon.approximateqft> 目的のアルゴリズムの精度に対して厳密には必要のない回転を排除することによって、さらなる最適化を可能にする操作を提供します。
おおよその QFT では、操作だけでなく、dyadic $Z $ ローテーション操作が必要です <xref:microsoft.quantum.intrinsic.rfrac> <xref:microsoft.quantum.intrinsic.h> 。
入力と出力はビッグエンディアン---エンコーディングでエンコードされていると想定されています。つまり、qubit with index `0` は、バイナリ整数表現の左端 (最上位) でエンコードされます。
これは、 [k 表記](xref:microsoft.quantum.concepts.dirac)と整合しています。これは、状態 $ \ket $ 内の3つの qubits のレジスタとして、 {100} $q 0 $ は状態 $ \ket $ に対応し、 {1} $q _1 $ と $q _2 $ は両方とも状態 $ \ket {0} $ になります。
近似パラメーター $a $ は、$ ローテーション $Z の排除レベルを決定します。つまり、[0.. n] $ に $a ます。
この例では、$ $Z $ ローテーション $ 2 \ pi/2 ^ k $ として $k > $ が QFT 回線から削除されます。
$K \ log_2 (n) + \ log_2 (1//イプシロン) + $3 であることがわかっています。 $ | をバインドすることができ \\ ます。 $ |-演算子 name{qft}--演算子 name{アク ft} \\ | </イプシロン $。
ここで \\ 、$ | \ cdot \\ | $ は演算子の基準です。この例では、$ ( [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) -operator name{qft}-\ operator name{cft}-\ operator name{cft}--operator name{cft}--演算子 name{cft}) ^/ダガー $ の平方根です。

## <a name="arithmetic"></a>算術 ##

算術演算が従来のコンピューティングで中心的な役割を果たしているのと同じように、クォンタムコンピューティングにも不可欠です。  Shor のファクタリングアルゴリズム、クォンタムシミュレーションメソッド、および多くの oracular アルゴリズムなどのアルゴリズムは、一貫した算術演算に依存しています。  クォンタムを作成するためのほとんどの方法は、クォンタムを作成することです。  最も単純な追加では、$b $ という従来の入力を受け取り、整数 $ \ket{a} $ を保持するクォンタム状態に値を追加します。  数学的には、追加の追加 (従来の入力 $b $) に対して $-演算子を使用することを意味します。このプロパティは、

$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.
$ $ この基本的な追加回線は、追加の incrementer よりも大きくなります。
このメソッドは、$ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}、$ $ $n を介して2つのクォンタム入力を持つ追加を行うことができます。この形式では、\begin{align} \ の形式で制御されるアプリケーションを使用して、$ $ の制御されたアプリケーションを使用します。 \ket{a} \ket{b} & = \ lambda \_ { \_ a 0} \_ \_ オペレーター名 {adders (2) \ 右) \ ラムダ \_ {a \_ 2} \ 左 (\ 演算子 name{adders (4)) \ cドット \_ /ラムダ {a \_ {n-1}} \ 左 (\ 演算子名 {1}} ({{n-1}}) \ right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}、$n $-bit 整数 $a $ and $b $ および加算剰余 $ 2 ^ n $。  $-ラムダ x (A) $ という表記では、$ という表記では、操作の制御されたバージョンが、 \_ コントロールとして qubit $x $ で $A 参照されていることを思い出してください。

同様に、クラシックデプロイに制御された乗算 (Shor のファクタリングアルゴリズムに不可欠なモジュール形式の形式) は、次のように制御される同様の一連の追加を使用して実行できます。 \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \ ラムダ \_ {x \_ 0} \ left (\ 演算子 name{add} (2 ^ 0 a) \ right) \ ラムダ \_ {a \_ 1} \ 左 (\ 演算子名 {add} (2 ^ 1a) \ 右) \ ラムダ \_ {a \_ 2} \ 左 (\ オペレーター名 {add} (2 ^ 2 a) \ 右) \ cドット & ラムダ \_ {x \_ {n-1}} \ 左 (\ 演算子 name{add} ({2 ^ {n-1}} a) \ right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + ax}。
\end{align} には、上に示した $ \operatorname{Mult} $ の定義から気付く可能性がある、量子コンピューターに対する乗算のはらみがあります。  加算とは異なり、この回線のクォンタムバージョンは入力の製品を入力レジスタではなく補助レジスタに格納します。  この例では、レジスタは $ $b 値を使用して初期化されますが、通常は値0の保持が開始されます。  このことが必要なのは、一般に、一般的な $a $ と $x $ の乗算が逆ではないためです。  すべてのクォンタム操作、測定値の保存は元に戻せるため、乗算を反転させるために十分な情報を保持する必要があります。  このため、結果は別の配列に格納されます。  このように、元に戻せない操作の出力を別のレジスタに保存することは、Charlie Bennett 後の "Bennett トリック" と呼ばれ、元に戻すことができ、クォンタムコンピューティングの両方で基本的なツールとなります。

多くのクォンタム回線の追加が提案されており、それぞれが qubits (space) の数と必要なゲート操作の数という点で異なるトレードオフを調べています。  Draper の追加と Beauregard の追加と呼ばれる、2つの高い領域を効率的にすることを確認します。

### <a name="draper-adder"></a>Draper の後に ###

Draper 追加は、追加を実行するためにクォンタムプロパティを直接呼び出すため、最も洗練されたクォンタムの1つです。  Draper の配置の背後にある洞察は、フーリエ変換を使用してフェーズシフトをビットシフトに変換できることです。  次に、フーリエ変換を適用し、適切なフェーズシフトを適用して、フーリエ変換を元に戻します。これにより、付属を実装できます。  提案されている他の多くの追加ファイルとは異なり、Draper 追加は、quantum フーリエ変換を通じて導入されたクォンタム効果を明示的に使用します。  自然な従来の対応するものはありません。  Draper の割り当ての具体的な手順を以下に示します。

2つの $n $-bit qubit レジスタに整数が格納されているとします。 $ と $b $ $a すべての $a $ $ $ \operatorname{QFT}\ket{a} = \ frac {1} {-sqrt{2 ^ n}} \ sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj)/2 ^ n} \ket{j}.
$ $ \Ket{\phi \_ k (a)} = \ frac {1} {\ sqrt {2} } \ left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket) を定義した場合、$ $ {1} \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 (a)} \ otimes/cドット/otimes \ket{\phi \_ n (a)} が表示されます。
$ $ 入力の合計は、$ $ \ket{a + b} = \ 演算子 name{qft} ^ {-1} \ket{\phi \_ 1 (a + b)}/otimes/cドット/otimes \ket{\phi \_ n (a + b)} として書き込むことができることを観察した後、明確になります。
$ $ $B $ と $a $ の整数を加算するには、$b $ としてのビットを使用して、分解の各 qubits に対して制御フェーズのローテーションを実行します。

この拡張は、任意の整数 $j $ と実数 $x $、$e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $ に対してさらに簡略化できます。  これは、円で $ 360 ^ {\circ} $ 度 ($ 2 \ pi $ ラジアン) を回転させると、開始位置が正確になるためです。  このため、$x $ for $e ^ {i2\pi x} $ の唯一の重要な部分は $x $ の小数部分です。  具体的には、$x = y +0 の形式のバイナリ展開があるとします。 x \_ 0x \_ 2 \ ldots x \_ n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1})} $。そのため、$ $ \ket{\phi \_ k (a + b)} = & lt; & lt {1} {2} ;/sqrt} \ 左 (\ket {0} + e ^ {i2\pi [a/2 ^ k +0 です。 b \_ Klドット b \_ 1]} \Ket {1} )。 $ $ これは、$ \ket{a} $ のフーリエ変換を展開することによって追加された各要素を増やすことで加算を実行すると、回転数が $k $ 減少として縮小されることを意味します。  これにより、増加に必要なクォンタムゲートの数が大幅に削減されます。  ここでは、フーリエの変換、フェーズの追加、および逆フーリエ変換のステップを示します。これは、$ Draper の追加を $ & left (-phi > qft} ^) として構成し {-1} \\ \! ます。 この単純化を使用してプロセス全体を実装するクォンタム回線は、次のようになります。

![サーキットダイアグラムとして表示される Draper の表示](~/media/draper.svg)

回線の制御された $e ^ {i2 \ pi/k} $ ゲートはそれぞれ、制御されたフェーズゲートを参照します。  このようなゲートには、それらが動作する qubits のペアに対するプロパティがあります。このプロパティは、$ \ket {00} \ map\ket {00} $ ではなく $ \ket {11} です。 $ {i2 \ pi/k} \ k {11} $ です。  この回線では、入力と出力を格納するために必要なものとは別に、追加の qubits を使用しないで追加を実行できます。

### <a name="beauregard-adder"></a>Beauregard の後に ###

Beauregard 追加は、任意の値の正の整数 $N $ に対して $ $N 加算の剰余を実行するために、Draper 追加を使用する、クォンタムモジュール化追加モジュールです。  Beauregard の追加など、量子モジュール化されたモジュールの有意性は、シャードまたはのアルゴリズム内のモジュール式の指数演算での使用から大きな範囲になります。  Quantum モジュール型の配置では、クォンタム入力 $ \ket{b} $ と古典 $a 入力に対して次のアクションを実行します $。 $a $ と $b $ $N は、$ [0, \ lドット, N-1] $ の範囲内にあることを意味します。

$ $ \ket{b}\rightarrow \ket{b + a \ text{mod} N} = \begin{cases} \ket{b + a}、& b + a < N \\ \\ \ket{b + a-N}、& (b + a)、および \end{cases}.
$$

Beauregard の追加には、Draper 追加記号、またはより具体的には $ $ を使用し \\ \! 、フェーズで $a $ と $b $ を追加します。  次に、同じ操作を使用して $a + b <N $ を $N $ を減算し、$a + b-N<$0 があるかどうかを確認します。  回線は、この情報を補助 qubit に格納し、$a + b<N $ の場合はレジスタ $N $ back に追加します。  その後、この補助ビットを非コンピューティングにします (この手順は、ancilla を呼び出した後に割り当てを解除できるようにするために必要です)。  Beauregard のための回線は、次のように指定されています。

![サーキットダイアグラムとして表示される Beauregard の表示](~/media/beau.svg)

ここでは、$- \\ \! phi/演算子の add} $ と同じ形式 \\ \! で、このコンテキストでは、入力が量子ではなく古典であることを除きます。  これにより、$-Phi-演算子 name{add} $ の制御されたフェーズをフェーズゲートに置き換えることができます。これは、より少数の操作にまとめてコンパイルすることにより、追加に \\ \! 必要な qubits 数とゲート数の両方を減らすことができます。

詳細については、Beth と[d.](https://arxiv.org/abs/quant-ph/0201067). [Roetteler](http://doi.org/10.1007/s00200-008-0072-2 )を参照してください。

### <a name="quantum-phase-estimation"></a>量子位相推定 ###

クォンタムフーリエ変換の特に重要なアプリケーションの1つは、*フェーズ推定*と呼ばれる問題である、ユニタリ演算子の固有値を学習することです。
' $ \Ket{\phi} $ ' は、不明な eigenstate $/phi $, \ket{\phi} {\ phi} = \phi\ket{\phi}. を使用して $U $ の eigenstate であるため、$U $ と state $ $ のようにします。
、oracle として $U $ にアクセスできるだけの場合は、制御され $Z た操作のターゲットに適用されている $ ローテーションをコントロールに反映させることで、フェーズ $-phi $ を学習できます。

$V $ が $U $ の制御されたアプリケーションであるとします。たとえば、\begin{align} V (\ket/ {0} otimes \ket{\phi}) & = \ket/ {0} otimes \ket{\phi} \\ \\ \t extrm{and} V (\ket/ {1} otimes \ket{\phi}) & = e ^ {i \phi} \ket/ {1} otimes \ket{\phi}.
\end{align}、直線性、\begin{align} V (\ket{+} \ otimes \ket{\phi}) & = \frac{(\ket/ {0} otimes \ket{\phi}) + e ^ {i \phi} (\ket/ {1} otimes \ket{\phi})} {/sqrt {2} }。
\end{align} \begin{align} V (\ket{+}/otimes \ket{\phi}) & = \frac{\ket {0} + e ^ {i \phi} \ket {1} } {/sqrt {2} }/otimes \ket{\phi} \\ \\ & = (R_1 (\ phi) \ket{+}) \ otimes \ket{\phi}, \end{align} ($R _1 $ が操作によって適用されるユニタリ <xref:microsoft.quantum.intrinsic.r1> ) を見つけることができます。
別の方法として、$V $ を適用した場合の効果は、$V $ に oracle としてしかアクセスできない場合でも、$R _1 $ を不明な角度で適用することとまったく同じです。
そのため、この説明の残りの部分では、$R _1 (\ phi) $ の観点からフェーズの推定について説明します。これは、いわゆる*フェーズ kickback*を使用して実装します。

このプロセスの後、コントロールとターゲットのレジスタは untangled のままであるため、$ \ket{\phi} $ を $U ^ $2 の制御されたアプリケーションのターゲットとして再利用して、2番目のコントロール qubit $R _1 (2 + phi) \ket{+} $ にすることができます。
この方法では、\begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j-phi) \ket{+} \\ \\ & \ propto \ bigotimes_ {j = 0} ^ {n}/left (\ket + \ exp) の形式のレジスタを取得できます。 {0} (i 2 ^ {j} \ phi) \ket] {1} \\ \\ & \ sum_ {k = 0} ^ {2 ^ n-1} \ exp (i-phi k) \ket{k} \end{align}。ここで $n $ は、必要な精度のビット数です。また、$ {} \ propto $ を使用して {} 、正規化係数 $1/\ sqrt{2 ^ n} $ が抑制されていることを示しています。

$-Phi = 2-pi p/2 ^ k $ が整数 $p $ であると仮定した場合、$ \ket{\psi} = p_1 p_0 \ket{p_n} $ として認識されます。ここで、$p _j $ は $j ^ {\t extrm{th} $ bit of $2/phi $ です。
クォンタムのフーリエ変換の adjoint を適用するため、クォンタムの状態としてエンコードされたフェーズのバイナリ表現を取得します。

Q # では、これは操作によって実装されます。これは <xref:microsoft.quantum.characterization.quantumphaseestimation> <xref:microsoft.quantum.oracles.discreteoracle> $U ^ m $ の実装アプリケーションを、正の整数 $m $ の関数として取得します。
